var Nf=Object.defineProperty;var Cf=(n,t,e)=>t in n?Nf(n,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):n[t]=e;var de=(n,t,e)=>Cf(n,typeof t!="symbol"?t+"":t,e);import{g as Ti,a as Fr}from"./react-vendor-faCf7XlP.js";var ps={},gn={},pa;function Bf(){if(pa)return gn;pa=1,gn.byteLength=a,gn.toByteArray=p,gn.fromByteArray=R;for(var n=[],t=[],e=typeof Uint8Array<"u"?Uint8Array:Array,r="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",s=0,i=r.length;s<i;++s)n[s]=r[s],t[r.charCodeAt(s)]=s;t[45]=62,t[95]=63;function o(_){var I=_.length;if(I%4>0)throw new Error("Invalid string. Length must be a multiple of 4");var O=_.indexOf("=");O===-1&&(O=I);var x=O===I?0:4-O%4;return[O,x]}function a(_){var I=o(_),O=I[0],x=I[1];return(O+x)*3/4-x}function l(_,I,O){return(I+O)*3/4-O}function p(_){var I,O=o(_),x=O[0],M=O[1],H=new e(l(_,x,M)),P=0,q=M>0?x-4:x,G;for(G=0;G<q;G+=4)I=t[_.charCodeAt(G)]<<18|t[_.charCodeAt(G+1)]<<12|t[_.charCodeAt(G+2)]<<6|t[_.charCodeAt(G+3)],H[P++]=I>>16&255,H[P++]=I>>8&255,H[P++]=I&255;return M===2&&(I=t[_.charCodeAt(G)]<<2|t[_.charCodeAt(G+1)]>>4,H[P++]=I&255),M===1&&(I=t[_.charCodeAt(G)]<<10|t[_.charCodeAt(G+1)]<<4|t[_.charCodeAt(G+2)]>>2,H[P++]=I>>8&255,H[P++]=I&255),H}function m(_){return n[_>>18&63]+n[_>>12&63]+n[_>>6&63]+n[_&63]}function S(_,I,O){for(var x,M=[],H=I;H<O;H+=3)x=(_[H]<<16&16711680)+(_[H+1]<<8&65280)+(_[H+2]&255),M.push(m(x));return M.join("")}function R(_){for(var I,O=_.length,x=O%3,M=[],H=16383,P=0,q=O-x;P<q;P+=H)M.push(S(_,P,P+H>q?q:P+H));return x===1?(I=_[O-1],M.push(n[I>>2]+n[I<<4&63]+"==")):x===2&&(I=(_[O-2]<<8)+_[O-1],M.push(n[I>>10]+n[I>>4&63]+n[I<<2&63]+"=")),M.join("")}return gn}var Vn={};/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */var ya;function Mf(){return ya||(ya=1,Vn.read=function(n,t,e,r,s){var i,o,a=s*8-r-1,l=(1<<a)-1,p=l>>1,m=-7,S=e?s-1:0,R=e?-1:1,_=n[t+S];for(S+=R,i=_&(1<<-m)-1,_>>=-m,m+=a;m>0;i=i*256+n[t+S],S+=R,m-=8);for(o=i&(1<<-m)-1,i>>=-m,m+=r;m>0;o=o*256+n[t+S],S+=R,m-=8);if(i===0)i=1-p;else{if(i===l)return o?NaN:(_?-1:1)*(1/0);o=o+Math.pow(2,r),i=i-p}return(_?-1:1)*o*Math.pow(2,i-r)},Vn.write=function(n,t,e,r,s,i){var o,a,l,p=i*8-s-1,m=(1<<p)-1,S=m>>1,R=s===23?Math.pow(2,-24)-Math.pow(2,-77):0,_=r?0:i-1,I=r?1:-1,O=t<0||t===0&&1/t<0?1:0;for(t=Math.abs(t),isNaN(t)||t===1/0?(a=isNaN(t)?1:0,o=m):(o=Math.floor(Math.log(t)/Math.LN2),t*(l=Math.pow(2,-o))<1&&(o--,l*=2),o+S>=1?t+=R/l:t+=R*Math.pow(2,1-S),t*l>=2&&(o++,l/=2),o+S>=m?(a=0,o=m):o+S>=1?(a=(t*l-1)*Math.pow(2,s),o=o+S):(a=t*Math.pow(2,S-1)*Math.pow(2,s),o=0));s>=8;n[e+_]=a&255,_+=I,a/=256,s-=8);for(o=o<<s|a,p+=s;p>0;n[e+_]=o&255,_+=I,o/=256,p-=8);n[e+_-I]|=O*128}),Vn}/*!
* The buffer module from node.js, for the browser.
*
* @author   Feross Aboukhadijeh <https://feross.org>
* @license  MIT
*/var ga;function Ro(){return ga||(ga=1,(function(n){const t=Bf(),e=Mf(),r=typeof Symbol=="function"&&typeof Symbol.for=="function"?Symbol.for("nodejs.util.inspect.custom"):null;n.Buffer=a,n.SlowBuffer=H,n.INSPECT_MAX_BYTES=50;const s=2147483647;n.kMaxLength=s,a.TYPED_ARRAY_SUPPORT=i(),!a.TYPED_ARRAY_SUPPORT&&typeof console<"u"&&typeof console.error=="function"&&console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");function i(){try{const k=new Uint8Array(1),y={foo:function(){return 42}};return Object.setPrototypeOf(y,Uint8Array.prototype),Object.setPrototypeOf(k,y),k.foo()===42}catch{return!1}}Object.defineProperty(a.prototype,"parent",{enumerable:!0,get:function(){if(a.isBuffer(this))return this.buffer}}),Object.defineProperty(a.prototype,"offset",{enumerable:!0,get:function(){if(a.isBuffer(this))return this.byteOffset}});function o(k){if(k>s)throw new RangeError('The value "'+k+'" is invalid for option "size"');const y=new Uint8Array(k);return Object.setPrototypeOf(y,a.prototype),y}function a(k,y,w){if(typeof k=="number"){if(typeof y=="string")throw new TypeError('The "string" argument must be of type string. Received type number');return S(k)}return l(k,y,w)}a.poolSize=8192;function l(k,y,w){if(typeof k=="string")return R(k,y);if(ArrayBuffer.isView(k))return I(k);if(k==null)throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof k);if(Ce(k,ArrayBuffer)||k&&Ce(k.buffer,ArrayBuffer)||typeof SharedArrayBuffer<"u"&&(Ce(k,SharedArrayBuffer)||k&&Ce(k.buffer,SharedArrayBuffer)))return O(k,y,w);if(typeof k=="number")throw new TypeError('The "value" argument must not be of type number. Received type number');const B=k.valueOf&&k.valueOf();if(B!=null&&B!==k)return a.from(B,y,w);const $=x(k);if($)return $;if(typeof Symbol<"u"&&Symbol.toPrimitive!=null&&typeof k[Symbol.toPrimitive]=="function")return a.from(k[Symbol.toPrimitive]("string"),y,w);throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof k)}a.from=function(k,y,w){return l(k,y,w)},Object.setPrototypeOf(a.prototype,Uint8Array.prototype),Object.setPrototypeOf(a,Uint8Array);function p(k){if(typeof k!="number")throw new TypeError('"size" argument must be of type number');if(k<0)throw new RangeError('The value "'+k+'" is invalid for option "size"')}function m(k,y,w){return p(k),k<=0?o(k):y!==void 0?typeof w=="string"?o(k).fill(y,w):o(k).fill(y):o(k)}a.alloc=function(k,y,w){return m(k,y,w)};function S(k){return p(k),o(k<0?0:M(k)|0)}a.allocUnsafe=function(k){return S(k)},a.allocUnsafeSlow=function(k){return S(k)};function R(k,y){if((typeof y!="string"||y==="")&&(y="utf8"),!a.isEncoding(y))throw new TypeError("Unknown encoding: "+y);const w=P(k,y)|0;let B=o(w);const $=B.write(k,y);return $!==w&&(B=B.slice(0,$)),B}function _(k){const y=k.length<0?0:M(k.length)|0,w=o(y);for(let B=0;B<y;B+=1)w[B]=k[B]&255;return w}function I(k){if(Ce(k,Uint8Array)){const y=new Uint8Array(k);return O(y.buffer,y.byteOffset,y.byteLength)}return _(k)}function O(k,y,w){if(y<0||k.byteLength<y)throw new RangeError('"offset" is outside of buffer bounds');if(k.byteLength<y+(w||0))throw new RangeError('"length" is outside of buffer bounds');let B;return y===void 0&&w===void 0?B=new Uint8Array(k):w===void 0?B=new Uint8Array(k,y):B=new Uint8Array(k,y,w),Object.setPrototypeOf(B,a.prototype),B}function x(k){if(a.isBuffer(k)){const y=M(k.length)|0,w=o(y);return w.length===0||k.copy(w,0,0,y),w}if(k.length!==void 0)return typeof k.length!="number"||Dt(k.length)?o(0):_(k);if(k.type==="Buffer"&&Array.isArray(k.data))return _(k.data)}function M(k){if(k>=s)throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x"+s.toString(16)+" bytes");return k|0}function H(k){return+k!=k&&(k=0),a.alloc(+k)}a.isBuffer=function(y){return y!=null&&y._isBuffer===!0&&y!==a.prototype},a.compare=function(y,w){if(Ce(y,Uint8Array)&&(y=a.from(y,y.offset,y.byteLength)),Ce(w,Uint8Array)&&(w=a.from(w,w.offset,w.byteLength)),!a.isBuffer(y)||!a.isBuffer(w))throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');if(y===w)return 0;let B=y.length,$=w.length;for(let V=0,X=Math.min(B,$);V<X;++V)if(y[V]!==w[V]){B=y[V],$=w[V];break}return B<$?-1:$<B?1:0},a.isEncoding=function(y){switch(String(y).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"latin1":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return!0;default:return!1}},a.concat=function(y,w){if(!Array.isArray(y))throw new TypeError('"list" argument must be an Array of Buffers');if(y.length===0)return a.alloc(0);let B;if(w===void 0)for(w=0,B=0;B<y.length;++B)w+=y[B].length;const $=a.allocUnsafe(w);let V=0;for(B=0;B<y.length;++B){let X=y[B];if(Ce(X,Uint8Array))V+X.length>$.length?(a.isBuffer(X)||(X=a.from(X)),X.copy($,V)):Uint8Array.prototype.set.call($,X,V);else if(a.isBuffer(X))X.copy($,V);else throw new TypeError('"list" argument must be an Array of Buffers');V+=X.length}return $};function P(k,y){if(a.isBuffer(k))return k.length;if(ArrayBuffer.isView(k)||Ce(k,ArrayBuffer))return k.byteLength;if(typeof k!="string")throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type '+typeof k);const w=k.length,B=arguments.length>2&&arguments[2]===!0;if(!B&&w===0)return 0;let $=!1;for(;;)switch(y){case"ascii":case"latin1":case"binary":return w;case"utf8":case"utf-8":return Ut(k).length;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return w*2;case"hex":return w>>>1;case"base64":return Ft(k).length;default:if($)return B?-1:Ut(k).length;y=(""+y).toLowerCase(),$=!0}}a.byteLength=P;function q(k,y,w){let B=!1;if((y===void 0||y<0)&&(y=0),y>this.length||((w===void 0||w>this.length)&&(w=this.length),w<=0)||(w>>>=0,y>>>=0,w<=y))return"";for(k||(k="utf8");;)switch(k){case"hex":return A(this,y,w);case"utf8":case"utf-8":return c(this,y,w);case"ascii":return T(this,y,w);case"latin1":case"binary":return N(this,y,w);case"base64":return b(this,y,w);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return g(this,y,w);default:if(B)throw new TypeError("Unknown encoding: "+k);k=(k+"").toLowerCase(),B=!0}}a.prototype._isBuffer=!0;function G(k,y,w){const B=k[y];k[y]=k[w],k[w]=B}a.prototype.swap16=function(){const y=this.length;if(y%2!==0)throw new RangeError("Buffer size must be a multiple of 16-bits");for(let w=0;w<y;w+=2)G(this,w,w+1);return this},a.prototype.swap32=function(){const y=this.length;if(y%4!==0)throw new RangeError("Buffer size must be a multiple of 32-bits");for(let w=0;w<y;w+=4)G(this,w,w+3),G(this,w+1,w+2);return this},a.prototype.swap64=function(){const y=this.length;if(y%8!==0)throw new RangeError("Buffer size must be a multiple of 64-bits");for(let w=0;w<y;w+=8)G(this,w,w+7),G(this,w+1,w+6),G(this,w+2,w+5),G(this,w+3,w+4);return this},a.prototype.toString=function(){const y=this.length;return y===0?"":arguments.length===0?c(this,0,y):q.apply(this,arguments)},a.prototype.toLocaleString=a.prototype.toString,a.prototype.equals=function(y){if(!a.isBuffer(y))throw new TypeError("Argument must be a Buffer");return this===y?!0:a.compare(this,y)===0},a.prototype.inspect=function(){let y="";const w=n.INSPECT_MAX_BYTES;return y=this.toString("hex",0,w).replace(/(.{2})/g,"$1 ").trim(),this.length>w&&(y+=" ... "),"<Buffer "+y+">"},r&&(a.prototype[r]=a.prototype.inspect),a.prototype.compare=function(y,w,B,$,V){if(Ce(y,Uint8Array)&&(y=a.from(y,y.offset,y.byteLength)),!a.isBuffer(y))throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type '+typeof y);if(w===void 0&&(w=0),B===void 0&&(B=y?y.length:0),$===void 0&&($=0),V===void 0&&(V=this.length),w<0||B>y.length||$<0||V>this.length)throw new RangeError("out of range index");if($>=V&&w>=B)return 0;if($>=V)return-1;if(w>=B)return 1;if(w>>>=0,B>>>=0,$>>>=0,V>>>=0,this===y)return 0;let X=V-$,wt=B-w;const gt=Math.min(X,wt),yt=this.slice($,V),Pt=y.slice(w,B);for(let pt=0;pt<gt;++pt)if(yt[pt]!==Pt[pt]){X=yt[pt],wt=Pt[pt];break}return X<wt?-1:wt<X?1:0};function J(k,y,w,B,$){if(k.length===0)return-1;if(typeof w=="string"?(B=w,w=0):w>2147483647?w=2147483647:w<-2147483648&&(w=-2147483648),w=+w,Dt(w)&&(w=$?0:k.length-1),w<0&&(w=k.length+w),w>=k.length){if($)return-1;w=k.length-1}else if(w<0)if($)w=0;else return-1;if(typeof y=="string"&&(y=a.from(y,B)),a.isBuffer(y))return y.length===0?-1:Q(k,y,w,B,$);if(typeof y=="number")return y=y&255,typeof Uint8Array.prototype.indexOf=="function"?$?Uint8Array.prototype.indexOf.call(k,y,w):Uint8Array.prototype.lastIndexOf.call(k,y,w):Q(k,[y],w,B,$);throw new TypeError("val must be string, number or Buffer")}function Q(k,y,w,B,$){let V=1,X=k.length,wt=y.length;if(B!==void 0&&(B=String(B).toLowerCase(),B==="ucs2"||B==="ucs-2"||B==="utf16le"||B==="utf-16le")){if(k.length<2||y.length<2)return-1;V=2,X/=2,wt/=2,w/=2}function gt(Pt,pt){return V===1?Pt[pt]:Pt.readUInt16BE(pt*V)}let yt;if($){let Pt=-1;for(yt=w;yt<X;yt++)if(gt(k,yt)===gt(y,Pt===-1?0:yt-Pt)){if(Pt===-1&&(Pt=yt),yt-Pt+1===wt)return Pt*V}else Pt!==-1&&(yt-=yt-Pt),Pt=-1}else for(w+wt>X&&(w=X-wt),yt=w;yt>=0;yt--){let Pt=!0;for(let pt=0;pt<wt;pt++)if(gt(k,yt+pt)!==gt(y,pt)){Pt=!1;break}if(Pt)return yt}return-1}a.prototype.includes=function(y,w,B){return this.indexOf(y,w,B)!==-1},a.prototype.indexOf=function(y,w,B){return J(this,y,w,B,!0)},a.prototype.lastIndexOf=function(y,w,B){return J(this,y,w,B,!1)};function tt(k,y,w,B){w=Number(w)||0;const $=k.length-w;B?(B=Number(B),B>$&&(B=$)):B=$;const V=y.length;B>V/2&&(B=V/2);let X;for(X=0;X<B;++X){const wt=parseInt(y.substr(X*2,2),16);if(Dt(wt))return X;k[w+X]=wt}return X}function L(k,y,w,B){return Lt(Ut(y,k.length-w),k,w,B)}function U(k,y,w,B){return Lt($t(y),k,w,B)}function F(k,y,w,B){return Lt(Ft(y),k,w,B)}function z(k,y,w,B){return Lt($n(y,k.length-w),k,w,B)}a.prototype.write=function(y,w,B,$){if(w===void 0)$="utf8",B=this.length,w=0;else if(B===void 0&&typeof w=="string")$=w,B=this.length,w=0;else if(isFinite(w))w=w>>>0,isFinite(B)?(B=B>>>0,$===void 0&&($="utf8")):($=B,B=void 0);else throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");const V=this.length-w;if((B===void 0||B>V)&&(B=V),y.length>0&&(B<0||w<0)||w>this.length)throw new RangeError("Attempt to write outside buffer bounds");$||($="utf8");let X=!1;for(;;)switch($){case"hex":return tt(this,y,w,B);case"utf8":case"utf-8":return L(this,y,w,B);case"ascii":case"latin1":case"binary":return U(this,y,w,B);case"base64":return F(this,y,w,B);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return z(this,y,w,B);default:if(X)throw new TypeError("Unknown encoding: "+$);$=(""+$).toLowerCase(),X=!0}},a.prototype.toJSON=function(){return{type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}};function b(k,y,w){return y===0&&w===k.length?t.fromByteArray(k):t.fromByteArray(k.slice(y,w))}function c(k,y,w){w=Math.min(k.length,w);const B=[];let $=y;for(;$<w;){const V=k[$];let X=null,wt=V>239?4:V>223?3:V>191?2:1;if($+wt<=w){let gt,yt,Pt,pt;switch(wt){case 1:V<128&&(X=V);break;case 2:gt=k[$+1],(gt&192)===128&&(pt=(V&31)<<6|gt&63,pt>127&&(X=pt));break;case 3:gt=k[$+1],yt=k[$+2],(gt&192)===128&&(yt&192)===128&&(pt=(V&15)<<12|(gt&63)<<6|yt&63,pt>2047&&(pt<55296||pt>57343)&&(X=pt));break;case 4:gt=k[$+1],yt=k[$+2],Pt=k[$+3],(gt&192)===128&&(yt&192)===128&&(Pt&192)===128&&(pt=(V&15)<<18|(gt&63)<<12|(yt&63)<<6|Pt&63,pt>65535&&pt<1114112&&(X=pt))}}X===null?(X=65533,wt=1):X>65535&&(X-=65536,B.push(X>>>10&1023|55296),X=56320|X&1023),B.push(X),$+=wt}return E(B)}const f=4096;function E(k){const y=k.length;if(y<=f)return String.fromCharCode.apply(String,k);let w="",B=0;for(;B<y;)w+=String.fromCharCode.apply(String,k.slice(B,B+=f));return w}function T(k,y,w){let B="";w=Math.min(k.length,w);for(let $=y;$<w;++$)B+=String.fromCharCode(k[$]&127);return B}function N(k,y,w){let B="";w=Math.min(k.length,w);for(let $=y;$<w;++$)B+=String.fromCharCode(k[$]);return B}function A(k,y,w){const B=k.length;(!y||y<0)&&(y=0),(!w||w<0||w>B)&&(w=B);let $="";for(let V=y;V<w;++V)$+=Vt[k[V]];return $}function g(k,y,w){const B=k.slice(y,w);let $="";for(let V=0;V<B.length-1;V+=2)$+=String.fromCharCode(B[V]+B[V+1]*256);return $}a.prototype.slice=function(y,w){const B=this.length;y=~~y,w=w===void 0?B:~~w,y<0?(y+=B,y<0&&(y=0)):y>B&&(y=B),w<0?(w+=B,w<0&&(w=0)):w>B&&(w=B),w<y&&(w=y);const $=this.subarray(y,w);return Object.setPrototypeOf($,a.prototype),$};function d(k,y,w){if(k%1!==0||k<0)throw new RangeError("offset is not uint");if(k+y>w)throw new RangeError("Trying to access beyond buffer length")}a.prototype.readUintLE=a.prototype.readUIntLE=function(y,w,B){y=y>>>0,w=w>>>0,B||d(y,w,this.length);let $=this[y],V=1,X=0;for(;++X<w&&(V*=256);)$+=this[y+X]*V;return $},a.prototype.readUintBE=a.prototype.readUIntBE=function(y,w,B){y=y>>>0,w=w>>>0,B||d(y,w,this.length);let $=this[y+--w],V=1;for(;w>0&&(V*=256);)$+=this[y+--w]*V;return $},a.prototype.readUint8=a.prototype.readUInt8=function(y,w){return y=y>>>0,w||d(y,1,this.length),this[y]},a.prototype.readUint16LE=a.prototype.readUInt16LE=function(y,w){return y=y>>>0,w||d(y,2,this.length),this[y]|this[y+1]<<8},a.prototype.readUint16BE=a.prototype.readUInt16BE=function(y,w){return y=y>>>0,w||d(y,2,this.length),this[y]<<8|this[y+1]},a.prototype.readUint32LE=a.prototype.readUInt32LE=function(y,w){return y=y>>>0,w||d(y,4,this.length),(this[y]|this[y+1]<<8|this[y+2]<<16)+this[y+3]*16777216},a.prototype.readUint32BE=a.prototype.readUInt32BE=function(y,w){return y=y>>>0,w||d(y,4,this.length),this[y]*16777216+(this[y+1]<<16|this[y+2]<<8|this[y+3])},a.prototype.readBigUInt64LE=Fe(function(y){y=y>>>0,Pe(y,"offset");const w=this[y],B=this[y+7];(w===void 0||B===void 0)&&Ct(y,this.length-8);const $=w+this[++y]*2**8+this[++y]*2**16+this[++y]*2**24,V=this[++y]+this[++y]*2**8+this[++y]*2**16+B*2**24;return BigInt($)+(BigInt(V)<<BigInt(32))}),a.prototype.readBigUInt64BE=Fe(function(y){y=y>>>0,Pe(y,"offset");const w=this[y],B=this[y+7];(w===void 0||B===void 0)&&Ct(y,this.length-8);const $=w*2**24+this[++y]*2**16+this[++y]*2**8+this[++y],V=this[++y]*2**24+this[++y]*2**16+this[++y]*2**8+B;return(BigInt($)<<BigInt(32))+BigInt(V)}),a.prototype.readIntLE=function(y,w,B){y=y>>>0,w=w>>>0,B||d(y,w,this.length);let $=this[y],V=1,X=0;for(;++X<w&&(V*=256);)$+=this[y+X]*V;return V*=128,$>=V&&($-=Math.pow(2,8*w)),$},a.prototype.readIntBE=function(y,w,B){y=y>>>0,w=w>>>0,B||d(y,w,this.length);let $=w,V=1,X=this[y+--$];for(;$>0&&(V*=256);)X+=this[y+--$]*V;return V*=128,X>=V&&(X-=Math.pow(2,8*w)),X},a.prototype.readInt8=function(y,w){return y=y>>>0,w||d(y,1,this.length),this[y]&128?(255-this[y]+1)*-1:this[y]},a.prototype.readInt16LE=function(y,w){y=y>>>0,w||d(y,2,this.length);const B=this[y]|this[y+1]<<8;return B&32768?B|4294901760:B},a.prototype.readInt16BE=function(y,w){y=y>>>0,w||d(y,2,this.length);const B=this[y+1]|this[y]<<8;return B&32768?B|4294901760:B},a.prototype.readInt32LE=function(y,w){return y=y>>>0,w||d(y,4,this.length),this[y]|this[y+1]<<8|this[y+2]<<16|this[y+3]<<24},a.prototype.readInt32BE=function(y,w){return y=y>>>0,w||d(y,4,this.length),this[y]<<24|this[y+1]<<16|this[y+2]<<8|this[y+3]},a.prototype.readBigInt64LE=Fe(function(y){y=y>>>0,Pe(y,"offset");const w=this[y],B=this[y+7];(w===void 0||B===void 0)&&Ct(y,this.length-8);const $=this[y+4]+this[y+5]*2**8+this[y+6]*2**16+(B<<24);return(BigInt($)<<BigInt(32))+BigInt(w+this[++y]*2**8+this[++y]*2**16+this[++y]*2**24)}),a.prototype.readBigInt64BE=Fe(function(y){y=y>>>0,Pe(y,"offset");const w=this[y],B=this[y+7];(w===void 0||B===void 0)&&Ct(y,this.length-8);const $=(w<<24)+this[++y]*2**16+this[++y]*2**8+this[++y];return(BigInt($)<<BigInt(32))+BigInt(this[++y]*2**24+this[++y]*2**16+this[++y]*2**8+B)}),a.prototype.readFloatLE=function(y,w){return y=y>>>0,w||d(y,4,this.length),e.read(this,y,!0,23,4)},a.prototype.readFloatBE=function(y,w){return y=y>>>0,w||d(y,4,this.length),e.read(this,y,!1,23,4)},a.prototype.readDoubleLE=function(y,w){return y=y>>>0,w||d(y,8,this.length),e.read(this,y,!0,52,8)},a.prototype.readDoubleBE=function(y,w){return y=y>>>0,w||d(y,8,this.length),e.read(this,y,!1,52,8)};function u(k,y,w,B,$,V){if(!a.isBuffer(k))throw new TypeError('"buffer" argument must be a Buffer instance');if(y>$||y<V)throw new RangeError('"value" argument is out of bounds');if(w+B>k.length)throw new RangeError("Index out of range")}a.prototype.writeUintLE=a.prototype.writeUIntLE=function(y,w,B,$){if(y=+y,w=w>>>0,B=B>>>0,!$){const wt=Math.pow(2,8*B)-1;u(this,y,w,B,wt,0)}let V=1,X=0;for(this[w]=y&255;++X<B&&(V*=256);)this[w+X]=y/V&255;return w+B},a.prototype.writeUintBE=a.prototype.writeUIntBE=function(y,w,B,$){if(y=+y,w=w>>>0,B=B>>>0,!$){const wt=Math.pow(2,8*B)-1;u(this,y,w,B,wt,0)}let V=B-1,X=1;for(this[w+V]=y&255;--V>=0&&(X*=256);)this[w+V]=y/X&255;return w+B},a.prototype.writeUint8=a.prototype.writeUInt8=function(y,w,B){return y=+y,w=w>>>0,B||u(this,y,w,1,255,0),this[w]=y&255,w+1},a.prototype.writeUint16LE=a.prototype.writeUInt16LE=function(y,w,B){return y=+y,w=w>>>0,B||u(this,y,w,2,65535,0),this[w]=y&255,this[w+1]=y>>>8,w+2},a.prototype.writeUint16BE=a.prototype.writeUInt16BE=function(y,w,B){return y=+y,w=w>>>0,B||u(this,y,w,2,65535,0),this[w]=y>>>8,this[w+1]=y&255,w+2},a.prototype.writeUint32LE=a.prototype.writeUInt32LE=function(y,w,B){return y=+y,w=w>>>0,B||u(this,y,w,4,4294967295,0),this[w+3]=y>>>24,this[w+2]=y>>>16,this[w+1]=y>>>8,this[w]=y&255,w+4},a.prototype.writeUint32BE=a.prototype.writeUInt32BE=function(y,w,B){return y=+y,w=w>>>0,B||u(this,y,w,4,4294967295,0),this[w]=y>>>24,this[w+1]=y>>>16,this[w+2]=y>>>8,this[w+3]=y&255,w+4};function h(k,y,w,B,$){Nt(y,B,$,k,w,7);let V=Number(y&BigInt(4294967295));k[w++]=V,V=V>>8,k[w++]=V,V=V>>8,k[w++]=V,V=V>>8,k[w++]=V;let X=Number(y>>BigInt(32)&BigInt(4294967295));return k[w++]=X,X=X>>8,k[w++]=X,X=X>>8,k[w++]=X,X=X>>8,k[w++]=X,w}function v(k,y,w,B,$){Nt(y,B,$,k,w,7);let V=Number(y&BigInt(4294967295));k[w+7]=V,V=V>>8,k[w+6]=V,V=V>>8,k[w+5]=V,V=V>>8,k[w+4]=V;let X=Number(y>>BigInt(32)&BigInt(4294967295));return k[w+3]=X,X=X>>8,k[w+2]=X,X=X>>8,k[w+1]=X,X=X>>8,k[w]=X,w+8}a.prototype.writeBigUInt64LE=Fe(function(y,w=0){return h(this,y,w,BigInt(0),BigInt("0xffffffffffffffff"))}),a.prototype.writeBigUInt64BE=Fe(function(y,w=0){return v(this,y,w,BigInt(0),BigInt("0xffffffffffffffff"))}),a.prototype.writeIntLE=function(y,w,B,$){if(y=+y,w=w>>>0,!$){const gt=Math.pow(2,8*B-1);u(this,y,w,B,gt-1,-gt)}let V=0,X=1,wt=0;for(this[w]=y&255;++V<B&&(X*=256);)y<0&&wt===0&&this[w+V-1]!==0&&(wt=1),this[w+V]=(y/X>>0)-wt&255;return w+B},a.prototype.writeIntBE=function(y,w,B,$){if(y=+y,w=w>>>0,!$){const gt=Math.pow(2,8*B-1);u(this,y,w,B,gt-1,-gt)}let V=B-1,X=1,wt=0;for(this[w+V]=y&255;--V>=0&&(X*=256);)y<0&&wt===0&&this[w+V+1]!==0&&(wt=1),this[w+V]=(y/X>>0)-wt&255;return w+B},a.prototype.writeInt8=function(y,w,B){return y=+y,w=w>>>0,B||u(this,y,w,1,127,-128),y<0&&(y=255+y+1),this[w]=y&255,w+1},a.prototype.writeInt16LE=function(y,w,B){return y=+y,w=w>>>0,B||u(this,y,w,2,32767,-32768),this[w]=y&255,this[w+1]=y>>>8,w+2},a.prototype.writeInt16BE=function(y,w,B){return y=+y,w=w>>>0,B||u(this,y,w,2,32767,-32768),this[w]=y>>>8,this[w+1]=y&255,w+2},a.prototype.writeInt32LE=function(y,w,B){return y=+y,w=w>>>0,B||u(this,y,w,4,2147483647,-2147483648),this[w]=y&255,this[w+1]=y>>>8,this[w+2]=y>>>16,this[w+3]=y>>>24,w+4},a.prototype.writeInt32BE=function(y,w,B){return y=+y,w=w>>>0,B||u(this,y,w,4,2147483647,-2147483648),y<0&&(y=4294967295+y+1),this[w]=y>>>24,this[w+1]=y>>>16,this[w+2]=y>>>8,this[w+3]=y&255,w+4},a.prototype.writeBigInt64LE=Fe(function(y,w=0){return h(this,y,w,-BigInt("0x8000000000000000"),BigInt("0x7fffffffffffffff"))}),a.prototype.writeBigInt64BE=Fe(function(y,w=0){return v(this,y,w,-BigInt("0x8000000000000000"),BigInt("0x7fffffffffffffff"))});function C(k,y,w,B,$,V){if(w+B>k.length)throw new RangeError("Index out of range");if(w<0)throw new RangeError("Index out of range")}function K(k,y,w,B,$){return y=+y,w=w>>>0,$||C(k,y,w,4),e.write(k,y,w,B,23,4),w+4}a.prototype.writeFloatLE=function(y,w,B){return K(this,y,w,!0,B)},a.prototype.writeFloatBE=function(y,w,B){return K(this,y,w,!1,B)};function Z(k,y,w,B,$){return y=+y,w=w>>>0,$||C(k,y,w,8),e.write(k,y,w,B,52,8),w+8}a.prototype.writeDoubleLE=function(y,w,B){return Z(this,y,w,!0,B)},a.prototype.writeDoubleBE=function(y,w,B){return Z(this,y,w,!1,B)},a.prototype.copy=function(y,w,B,$){if(!a.isBuffer(y))throw new TypeError("argument should be a Buffer");if(B||(B=0),!$&&$!==0&&($=this.length),w>=y.length&&(w=y.length),w||(w=0),$>0&&$<B&&($=B),$===B||y.length===0||this.length===0)return 0;if(w<0)throw new RangeError("targetStart out of bounds");if(B<0||B>=this.length)throw new RangeError("Index out of range");if($<0)throw new RangeError("sourceEnd out of bounds");$>this.length&&($=this.length),y.length-w<$-B&&($=y.length-w+B);const V=$-B;return this===y&&typeof Uint8Array.prototype.copyWithin=="function"?this.copyWithin(w,B,$):Uint8Array.prototype.set.call(y,this.subarray(B,$),w),V},a.prototype.fill=function(y,w,B,$){if(typeof y=="string"){if(typeof w=="string"?($=w,w=0,B=this.length):typeof B=="string"&&($=B,B=this.length),$!==void 0&&typeof $!="string")throw new TypeError("encoding must be a string");if(typeof $=="string"&&!a.isEncoding($))throw new TypeError("Unknown encoding: "+$);if(y.length===1){const X=y.charCodeAt(0);($==="utf8"&&X<128||$==="latin1")&&(y=X)}}else typeof y=="number"?y=y&255:typeof y=="boolean"&&(y=Number(y));if(w<0||this.length<w||this.length<B)throw new RangeError("Out of range index");if(B<=w)return this;w=w>>>0,B=B===void 0?this.length:B>>>0,y||(y=0);let V;if(typeof y=="number")for(V=w;V<B;++V)this[V]=y;else{const X=a.isBuffer(y)?y:a.from(y,$),wt=X.length;if(wt===0)throw new TypeError('The value "'+y+'" is invalid for argument "value"');for(V=0;V<B-w;++V)this[V+w]=X[V%wt]}return this};const it={};function ut(k,y,w){it[k]=class extends w{constructor(){super(),Object.defineProperty(this,"message",{value:y.apply(this,arguments),writable:!0,configurable:!0}),this.name=`${this.name} [${k}]`,this.stack,delete this.name}get code(){return k}set code($){Object.defineProperty(this,"code",{configurable:!0,enumerable:!0,value:$,writable:!0})}toString(){return`${this.name} [${k}]: ${this.message}`}}}ut("ERR_BUFFER_OUT_OF_BOUNDS",function(k){return k?`${k} is outside of buffer bounds`:"Attempt to access memory outside buffer bounds"},RangeError),ut("ERR_INVALID_ARG_TYPE",function(k,y){return`The "${k}" argument must be of type number. Received type ${typeof y}`},TypeError),ut("ERR_OUT_OF_RANGE",function(k,y,w){let B=`The value of "${k}" is out of range.`,$=w;return Number.isInteger(w)&&Math.abs(w)>2**32?$=St(String(w)):typeof w=="bigint"&&($=String(w),(w>BigInt(2)**BigInt(32)||w<-(BigInt(2)**BigInt(32)))&&($=St($)),$+="n"),B+=` It must be ${y}. Received ${$}`,B},RangeError);function St(k){let y="",w=k.length;const B=k[0]==="-"?1:0;for(;w>=B+4;w-=3)y=`_${k.slice(w-3,w)}${y}`;return`${k.slice(0,w)}${y}`}function kt(k,y,w){Pe(y,"offset"),(k[y]===void 0||k[y+w]===void 0)&&Ct(y,k.length-(w+1))}function Nt(k,y,w,B,$,V){if(k>w||k<y){const X=typeof y=="bigint"?"n":"";let wt;throw y===0||y===BigInt(0)?wt=`>= 0${X} and < 2${X} ** ${(V+1)*8}${X}`:wt=`>= -(2${X} ** ${(V+1)*8-1}${X}) and < 2 ** ${(V+1)*8-1}${X}`,new it.ERR_OUT_OF_RANGE("value",wt,k)}kt(B,$,V)}function Pe(k,y){if(typeof k!="number")throw new it.ERR_INVALID_ARG_TYPE(y,"number",k)}function Ct(k,y,w){throw Math.floor(k)!==k?(Pe(k,w),new it.ERR_OUT_OF_RANGE("offset","an integer",k)):y<0?new it.ERR_BUFFER_OUT_OF_BOUNDS:new it.ERR_OUT_OF_RANGE("offset",`>= 0 and <= ${y}`,k)}const qt=/[^+/0-9A-Za-z-_]/g;function qn(k){if(k=k.split("=")[0],k=k.trim().replace(qt,""),k.length<2)return"";for(;k.length%4!==0;)k=k+"=";return k}function Ut(k,y){y=y||1/0;let w;const B=k.length;let $=null;const V=[];for(let X=0;X<B;++X){if(w=k.charCodeAt(X),w>55295&&w<57344){if(!$){if(w>56319){(y-=3)>-1&&V.push(239,191,189);continue}else if(X+1===B){(y-=3)>-1&&V.push(239,191,189);continue}$=w;continue}if(w<56320){(y-=3)>-1&&V.push(239,191,189),$=w;continue}w=($-55296<<10|w-56320)+65536}else $&&(y-=3)>-1&&V.push(239,191,189);if($=null,w<128){if((y-=1)<0)break;V.push(w)}else if(w<2048){if((y-=2)<0)break;V.push(w>>6|192,w&63|128)}else if(w<65536){if((y-=3)<0)break;V.push(w>>12|224,w>>6&63|128,w&63|128)}else if(w<1114112){if((y-=4)<0)break;V.push(w>>18|240,w>>12&63|128,w>>6&63|128,w&63|128)}else throw new Error("Invalid code point")}return V}function $t(k){const y=[];for(let w=0;w<k.length;++w)y.push(k.charCodeAt(w)&255);return y}function $n(k,y){let w,B,$;const V=[];for(let X=0;X<k.length&&!((y-=2)<0);++X)w=k.charCodeAt(X),B=w>>8,$=w%256,V.push($),V.push(B);return V}function Ft(k){return t.toByteArray(qn(k))}function Lt(k,y,w,B){let $;for($=0;$<B&&!($+w>=y.length||$>=k.length);++$)y[$+w]=k[$];return $}function Ce(k,y){return k instanceof y||k!=null&&k.constructor!=null&&k.constructor.name!=null&&k.constructor.name===y.name}function Dt(k){return k!==k}const Vt=(function(){const k="0123456789abcdef",y=new Array(256);for(let w=0;w<16;++w){const B=w*16;for(let $=0;$<16;++$)y[B+$]=k[w]+k[$]}return y})();function Fe(k){return typeof BigInt>"u"?Wt:k}function Wt(){throw new Error("BigInt not supported")}})(ps)),ps}var ht=Ro();const Wr=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Cn(n){return n instanceof Uint8Array||ArrayBuffer.isView(n)&&n.constructor.name==="Uint8Array"}function An(n){if(!Number.isSafeInteger(n)||n<0)throw new Error("positive integer expected, got "+n)}function hr(n,...t){if(!Cn(n))throw new Error("Uint8Array expected");if(t.length>0&&!t.includes(n.length))throw new Error("Uint8Array expected of length "+t+", got length="+n.length)}function ru(n){if(typeof n!="function"||typeof n.create!="function")throw new Error("Hash should be wrapped by utils.createHasher");An(n.outputLen),An(n.blockLen)}function on(n,t=!0){if(n.destroyed)throw new Error("Hash instance has been destroyed");if(t&&n.finished)throw new Error("Hash#digest() has already been called")}function nu(n,t){hr(n);const e=t.outputLen;if(n.length<e)throw new Error("digestInto() expects output buffer of length at least "+e)}function Lf(n){return new Uint32Array(n.buffer,n.byteOffset,Math.floor(n.byteLength/4))}function vr(...n){for(let t=0;t<n.length;t++)n[t].fill(0)}function ys(n){return new DataView(n.buffer,n.byteOffset,n.byteLength)}function $e(n,t){return n<<32-t|n>>>t}const Pf=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;function Uf(n){return n<<24&4278190080|n<<8&16711680|n>>>8&65280|n>>>24&255}function Df(n){for(let t=0;t<n.length;t++)n[t]=Uf(n[t]);return n}const ma=Pf?n=>n:Df,iu=typeof Uint8Array.from([]).toHex=="function"&&typeof Uint8Array.fromHex=="function",Hf=Array.from({length:256},(n,t)=>t.toString(16).padStart(2,"0"));function Lr(n){if(hr(n),iu)return n.toHex();let t="";for(let e=0;e<n.length;e++)t+=Hf[n[e]];return t}const tr={_0:48,_9:57,A:65,F:70,a:97,f:102};function wa(n){if(n>=tr._0&&n<=tr._9)return n-tr._0;if(n>=tr.A&&n<=tr.F)return n-(tr.A-10);if(n>=tr.a&&n<=tr.f)return n-(tr.a-10)}function fi(n){if(typeof n!="string")throw new Error("hex string expected, got "+typeof n);if(iu)return Uint8Array.fromHex(n);const t=n.length,e=t/2;if(t%2)throw new Error("hex string expected, got unpadded hex of length "+t);const r=new Uint8Array(e);for(let s=0,i=0;s<e;s++,i+=2){const o=wa(n.charCodeAt(i)),a=wa(n.charCodeAt(i+1));if(o===void 0||a===void 0){const l=n[i]+n[i+1];throw new Error('hex string expected, got non-hex character "'+l+'" at index '+i)}r[s]=o*16+a}return r}function Ff(n){if(typeof n!="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(n))}function Oi(n){return typeof n=="string"&&(n=Ff(n)),hr(n),n}function Ge(...n){let t=0;for(let r=0;r<n.length;r++){const s=n[r];hr(s),t+=s.length}const e=new Uint8Array(t);for(let r=0,s=0;r<n.length;r++){const i=n[r];e.set(i,s),s+=i.length}return e}class vo{}function Ao(n){const t=r=>n().update(Oi(r)).digest(),e=n();return t.outputLen=e.outputLen,t.blockLen=e.blockLen,t.create=()=>n(),t}function Io(n=32){if(Wr&&typeof Wr.getRandomValues=="function")return Wr.getRandomValues(new Uint8Array(n));if(Wr&&typeof Wr.randomBytes=="function")return Uint8Array.from(Wr.randomBytes(n));throw new Error("crypto.getRandomValues must be defined")}function zf(n,t,e,r){if(typeof n.setBigUint64=="function")return n.setBigUint64(t,e,r);const s=BigInt(32),i=BigInt(4294967295),o=Number(e>>s&i),a=Number(e&i),l=r?4:0,p=r?0:4;n.setUint32(t+l,o,r),n.setUint32(t+p,a,r)}function Kf(n,t,e){return n&t^~n&e}function qf(n,t,e){return n&t^n&e^t&e}class su extends vo{constructor(t,e,r,s){super(),this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.blockLen=t,this.outputLen=e,this.padOffset=r,this.isLE=s,this.buffer=new Uint8Array(t),this.view=ys(this.buffer)}update(t){on(this),t=Oi(t),hr(t);const{view:e,buffer:r,blockLen:s}=this,i=t.length;for(let o=0;o<i;){const a=Math.min(s-this.pos,i-o);if(a===s){const l=ys(t);for(;s<=i-o;o+=s)this.process(l,o);continue}r.set(t.subarray(o,o+a),this.pos),this.pos+=a,o+=a,this.pos===s&&(this.process(e,0),this.pos=0)}return this.length+=t.length,this.roundClean(),this}digestInto(t){on(this),nu(t,this),this.finished=!0;const{buffer:e,view:r,blockLen:s,isLE:i}=this;let{pos:o}=this;e[o++]=128,vr(this.buffer.subarray(o)),this.padOffset>s-o&&(this.process(r,0),o=0);for(let S=o;S<s;S++)e[S]=0;zf(r,s-8,BigInt(this.length*8),i),this.process(r,0);const a=ys(t),l=this.outputLen;if(l%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const p=l/4,m=this.get();if(p>m.length)throw new Error("_sha2: outputLen bigger than state");for(let S=0;S<p;S++)a.setUint32(4*S,m[S],i)}digest(){const{buffer:t,outputLen:e}=this;this.digestInto(t);const r=t.slice(0,e);return this.destroy(),r}_cloneInto(t){t||(t=new this.constructor),t.set(...this.get());const{blockLen:e,buffer:r,length:s,finished:i,destroyed:o,pos:a}=this;return t.destroyed=o,t.finished=i,t.length=s,t.pos=a,s%e&&t.buffer.set(r),t}clone(){return this._cloneInto()}}const dr=Uint32Array.from([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),Re=Uint32Array.from([1779033703,4089235720,3144134277,2227873595,1013904242,4271175723,2773480762,1595750129,1359893119,2917565137,2600822924,725511199,528734635,4215389547,1541459225,327033209]),Wn=BigInt(2**32-1),_a=BigInt(32);function $f(n,t=!1){return t?{h:Number(n&Wn),l:Number(n>>_a&Wn)}:{h:Number(n>>_a&Wn)|0,l:Number(n&Wn)|0}}function ou(n,t=!1){const e=n.length;let r=new Uint32Array(e),s=new Uint32Array(e);for(let i=0;i<e;i++){const{h:o,l:a}=$f(n[i],t);[r[i],s[i]]=[o,a]}return[r,s]}const ba=(n,t,e)=>n>>>e,Ea=(n,t,e)=>n<<32-e|t>>>e,Gr=(n,t,e)=>n>>>e|t<<32-e,jr=(n,t,e)=>n<<32-e|t>>>e,Gn=(n,t,e)=>n<<64-e|t>>>e-32,jn=(n,t,e)=>n>>>e-32|t<<64-e,Vf=(n,t,e)=>n<<e|t>>>32-e,Wf=(n,t,e)=>t<<e|n>>>32-e,Gf=(n,t,e)=>t<<e-32|n>>>64-e,jf=(n,t,e)=>n<<e-32|t>>>64-e;function er(n,t,e,r){const s=(t>>>0)+(r>>>0);return{h:n+e+(s/2**32|0)|0,l:s|0}}const Yf=(n,t,e)=>(n>>>0)+(t>>>0)+(e>>>0),Zf=(n,t,e,r)=>t+e+r+(n/2**32|0)|0,Xf=(n,t,e,r)=>(n>>>0)+(t>>>0)+(e>>>0)+(r>>>0),Jf=(n,t,e,r,s)=>t+e+r+s+(n/2**32|0)|0,Qf=(n,t,e,r,s)=>(n>>>0)+(t>>>0)+(e>>>0)+(r>>>0)+(s>>>0),td=(n,t,e,r,s,i)=>t+e+r+s+i+(n/2**32|0)|0,ed=Uint32Array.from([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),pr=new Uint32Array(64);class rd extends su{constructor(t=32){super(64,t,8,!1),this.A=dr[0]|0,this.B=dr[1]|0,this.C=dr[2]|0,this.D=dr[3]|0,this.E=dr[4]|0,this.F=dr[5]|0,this.G=dr[6]|0,this.H=dr[7]|0}get(){const{A:t,B:e,C:r,D:s,E:i,F:o,G:a,H:l}=this;return[t,e,r,s,i,o,a,l]}set(t,e,r,s,i,o,a,l){this.A=t|0,this.B=e|0,this.C=r|0,this.D=s|0,this.E=i|0,this.F=o|0,this.G=a|0,this.H=l|0}process(t,e){for(let S=0;S<16;S++,e+=4)pr[S]=t.getUint32(e,!1);for(let S=16;S<64;S++){const R=pr[S-15],_=pr[S-2],I=$e(R,7)^$e(R,18)^R>>>3,O=$e(_,17)^$e(_,19)^_>>>10;pr[S]=O+pr[S-7]+I+pr[S-16]|0}let{A:r,B:s,C:i,D:o,E:a,F:l,G:p,H:m}=this;for(let S=0;S<64;S++){const R=$e(a,6)^$e(a,11)^$e(a,25),_=m+R+Kf(a,l,p)+ed[S]+pr[S]|0,O=($e(r,2)^$e(r,13)^$e(r,22))+qf(r,s,i)|0;m=p,p=l,l=a,a=o+_|0,o=i,i=s,s=r,r=_+O|0}r=r+this.A|0,s=s+this.B|0,i=i+this.C|0,o=o+this.D|0,a=a+this.E|0,l=l+this.F|0,p=p+this.G|0,m=m+this.H|0,this.set(r,s,i,o,a,l,p,m)}roundClean(){vr(pr)}destroy(){this.set(0,0,0,0,0,0,0,0),vr(this.buffer)}}const au=ou(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(n=>BigInt(n))),nd=au[0],id=au[1],yr=new Uint32Array(80),gr=new Uint32Array(80);class sd extends su{constructor(t=64){super(128,t,16,!1),this.Ah=Re[0]|0,this.Al=Re[1]|0,this.Bh=Re[2]|0,this.Bl=Re[3]|0,this.Ch=Re[4]|0,this.Cl=Re[5]|0,this.Dh=Re[6]|0,this.Dl=Re[7]|0,this.Eh=Re[8]|0,this.El=Re[9]|0,this.Fh=Re[10]|0,this.Fl=Re[11]|0,this.Gh=Re[12]|0,this.Gl=Re[13]|0,this.Hh=Re[14]|0,this.Hl=Re[15]|0}get(){const{Ah:t,Al:e,Bh:r,Bl:s,Ch:i,Cl:o,Dh:a,Dl:l,Eh:p,El:m,Fh:S,Fl:R,Gh:_,Gl:I,Hh:O,Hl:x}=this;return[t,e,r,s,i,o,a,l,p,m,S,R,_,I,O,x]}set(t,e,r,s,i,o,a,l,p,m,S,R,_,I,O,x){this.Ah=t|0,this.Al=e|0,this.Bh=r|0,this.Bl=s|0,this.Ch=i|0,this.Cl=o|0,this.Dh=a|0,this.Dl=l|0,this.Eh=p|0,this.El=m|0,this.Fh=S|0,this.Fl=R|0,this.Gh=_|0,this.Gl=I|0,this.Hh=O|0,this.Hl=x|0}process(t,e){for(let P=0;P<16;P++,e+=4)yr[P]=t.getUint32(e),gr[P]=t.getUint32(e+=4);for(let P=16;P<80;P++){const q=yr[P-15]|0,G=gr[P-15]|0,J=Gr(q,G,1)^Gr(q,G,8)^ba(q,G,7),Q=jr(q,G,1)^jr(q,G,8)^Ea(q,G,7),tt=yr[P-2]|0,L=gr[P-2]|0,U=Gr(tt,L,19)^Gn(tt,L,61)^ba(tt,L,6),F=jr(tt,L,19)^jn(tt,L,61)^Ea(tt,L,6),z=Xf(Q,F,gr[P-7],gr[P-16]),b=Jf(z,J,U,yr[P-7],yr[P-16]);yr[P]=b|0,gr[P]=z|0}let{Ah:r,Al:s,Bh:i,Bl:o,Ch:a,Cl:l,Dh:p,Dl:m,Eh:S,El:R,Fh:_,Fl:I,Gh:O,Gl:x,Hh:M,Hl:H}=this;for(let P=0;P<80;P++){const q=Gr(S,R,14)^Gr(S,R,18)^Gn(S,R,41),G=jr(S,R,14)^jr(S,R,18)^jn(S,R,41),J=S&_^~S&O,Q=R&I^~R&x,tt=Qf(H,G,Q,id[P],gr[P]),L=td(tt,M,q,J,nd[P],yr[P]),U=tt|0,F=Gr(r,s,28)^Gn(r,s,34)^Gn(r,s,39),z=jr(r,s,28)^jn(r,s,34)^jn(r,s,39),b=r&i^r&a^i&a,c=s&o^s&l^o&l;M=O|0,H=x|0,O=_|0,x=I|0,_=S|0,I=R|0,{h:S,l:R}=er(p|0,m|0,L|0,U|0),p=a|0,m=l|0,a=i|0,l=o|0,i=r|0,o=s|0;const f=Yf(U,z,c);r=Zf(f,L,F,b),s=f|0}({h:r,l:s}=er(this.Ah|0,this.Al|0,r|0,s|0)),{h:i,l:o}=er(this.Bh|0,this.Bl|0,i|0,o|0),{h:a,l}=er(this.Ch|0,this.Cl|0,a|0,l|0),{h:p,l:m}=er(this.Dh|0,this.Dl|0,p|0,m|0),{h:S,l:R}=er(this.Eh|0,this.El|0,S|0,R|0),{h:_,l:I}=er(this.Fh|0,this.Fl|0,_|0,I|0),{h:O,l:x}=er(this.Gh|0,this.Gl|0,O|0,x|0),{h:M,l:H}=er(this.Hh|0,this.Hl|0,M|0,H|0),this.set(r,s,i,o,a,l,p,m,S,R,_,I,O,x,M,H)}roundClean(){vr(yr,gr)}destroy(){vr(this.buffer),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}const cu=Ao(()=>new rd),od=Ao(()=>new sd);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const So=BigInt(0),ro=BigInt(1);function Pr(n,t=""){if(typeof n!="boolean"){const e=t&&`"${t}"`;throw new Error(e+"expected boolean, got type="+typeof n)}return n}function ze(n,t,e=""){const r=Cn(n),s=n?.length,i=t!==void 0;if(!r||i&&s!==t){const o=e&&`"${e}" `,a=i?` of length ${t}`:"",l=r?`length=${s}`:`type=${typeof n}`;throw new Error(o+"expected Uint8Array"+a+", got "+l)}return n}function Yn(n){const t=n.toString(16);return t.length&1?"0"+t:t}function uu(n){if(typeof n!="string")throw new Error("hex string expected, got "+typeof n);return n===""?So:BigInt("0x"+n)}function xi(n){return uu(Lr(n))}function In(n){return hr(n),uu(Lr(Uint8Array.from(n).reverse()))}function ko(n,t){return fi(n.toString(16).padStart(t*2,"0"))}function lu(n,t){return ko(n,t).reverse()}function jt(n,t,e){let r;if(typeof t=="string")try{r=fi(t)}catch(i){throw new Error(n+" must be hex string or Uint8Array, cause: "+i)}else if(Cn(t))r=Uint8Array.from(t);else throw new Error(n+" must be hex string or Uint8Array");const s=r.length;if(typeof e=="number"&&s!==e)throw new Error(n+" of length "+e+" expected, got "+s);return r}function Ra(n){return Uint8Array.from(n)}const gs=n=>typeof n=="bigint"&&So<=n;function ad(n,t,e){return gs(n)&&gs(t)&&gs(e)&&t<=n&&n<e}function no(n,t,e,r){if(!ad(t,e,r))throw new Error("expected valid "+n+": "+e+" <= n < "+r+", got "+t)}function hu(n){let t;for(t=0;n>So;n>>=ro,t+=1);return t}const Bn=n=>(ro<<BigInt(n))-ro;function cd(n,t,e){if(typeof n!="number"||n<2)throw new Error("hashLen must be a number");if(typeof t!="number"||t<2)throw new Error("qByteLen must be a number");if(typeof e!="function")throw new Error("hmacFn must be a function");const r=_=>new Uint8Array(_),s=_=>Uint8Array.of(_);let i=r(n),o=r(n),a=0;const l=()=>{i.fill(1),o.fill(0),a=0},p=(..._)=>e(o,i,..._),m=(_=r(0))=>{o=p(s(0),_),i=p(),_.length!==0&&(o=p(s(1),_),i=p())},S=()=>{if(a++>=1e3)throw new Error("drbg: tried 1000 values");let _=0;const I=[];for(;_<t;){i=p();const O=i.slice();I.push(O),_+=i.length}return Ge(...I)};return(_,I)=>{l(),m(_);let O;for(;!(O=I(S()));)m();return l(),O}}function Mn(n,t,e={}){if(!n||typeof n!="object")throw new Error("expected valid options object");function r(s,i,o){const a=n[s];if(o&&a===void 0)return;const l=typeof a;if(l!==i||a===null)throw new Error(`param "${s}" is invalid: expected ${i}, got ${l}`)}Object.entries(t).forEach(([s,i])=>r(s,i,!1)),Object.entries(e).forEach(([s,i])=>r(s,i,!0))}function di(n){const t=new WeakMap;return(e,...r)=>{const s=t.get(e);if(s!==void 0)return s;const i=n(e,...r);return t.set(e,i),i}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const xe=BigInt(0),Ee=BigInt(1),Or=BigInt(2),fu=BigInt(3),du=BigInt(4),pu=BigInt(5),ud=BigInt(7),yu=BigInt(8),ld=BigInt(9),gu=BigInt(16);function pe(n,t){const e=n%t;return e>=xe?e:t+e}function Gt(n,t,e){let r=n;for(;t-- >xe;)r*=r,r%=e;return r}function va(n,t){if(n===xe)throw new Error("invert: expected non-zero number");if(t<=xe)throw new Error("invert: expected positive modulus, got "+t);let e=pe(n,t),r=t,s=xe,i=Ee;for(;e!==xe;){const a=r/e,l=r%e,p=s-i*a;r=e,e=l,s=i,i=p}if(r!==Ee)throw new Error("invert: does not exist");return pe(s,t)}function To(n,t,e){if(!n.eql(n.sqr(t),e))throw new Error("Cannot find square root")}function mu(n,t){const e=(n.ORDER+Ee)/du,r=n.pow(t,e);return To(n,r,t),r}function hd(n,t){const e=(n.ORDER-pu)/yu,r=n.mul(t,Or),s=n.pow(r,e),i=n.mul(t,s),o=n.mul(n.mul(i,Or),s),a=n.mul(i,n.sub(o,n.ONE));return To(n,a,t),a}function fd(n){const t=zr(n),e=wu(n),r=e(t,t.neg(t.ONE)),s=e(t,r),i=e(t,t.neg(r)),o=(n+ud)/gu;return(a,l)=>{let p=a.pow(l,o),m=a.mul(p,r);const S=a.mul(p,s),R=a.mul(p,i),_=a.eql(a.sqr(m),l),I=a.eql(a.sqr(S),l);p=a.cmov(p,m,_),m=a.cmov(R,S,I);const O=a.eql(a.sqr(m),l),x=a.cmov(p,m,O);return To(a,x,l),x}}function wu(n){if(n<fu)throw new Error("sqrt is not defined for small field");let t=n-Ee,e=0;for(;t%Or===xe;)t/=Or,e++;let r=Or;const s=zr(n);for(;Aa(s,r)===1;)if(r++>1e3)throw new Error("Cannot find square root: probably non-prime P");if(e===1)return mu;let i=s.pow(r,t);const o=(t+Ee)/Or;return function(l,p){if(l.is0(p))return p;if(Aa(l,p)!==1)throw new Error("Cannot find square root");let m=e,S=l.mul(l.ONE,i),R=l.pow(p,t),_=l.pow(p,o);for(;!l.eql(R,l.ONE);){if(l.is0(R))return l.ZERO;let I=1,O=l.sqr(R);for(;!l.eql(O,l.ONE);)if(I++,O=l.sqr(O),I===m)throw new Error("Cannot find square root");const x=Ee<<BigInt(m-I-1),M=l.pow(S,x);m=I,S=l.sqr(M),R=l.mul(R,S),_=l.mul(_,M)}return _}}function dd(n){return n%du===fu?mu:n%yu===pu?hd:n%gu===ld?fd(n):wu(n)}const pd=(n,t)=>(pe(n,t)&Ee)===Ee,yd=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function gd(n){const t={ORDER:"bigint",MASK:"bigint",BYTES:"number",BITS:"number"},e=yd.reduce((r,s)=>(r[s]="function",r),t);return Mn(n,e),n}function md(n,t,e){if(e<xe)throw new Error("invalid exponent, negatives unsupported");if(e===xe)return n.ONE;if(e===Ee)return t;let r=n.ONE,s=t;for(;e>xe;)e&Ee&&(r=n.mul(r,s)),s=n.sqr(s),e>>=Ee;return r}function _u(n,t,e=!1){const r=new Array(t.length).fill(e?n.ZERO:void 0),s=t.reduce((o,a,l)=>n.is0(a)?o:(r[l]=o,n.mul(o,a)),n.ONE),i=n.inv(s);return t.reduceRight((o,a,l)=>n.is0(a)?o:(r[l]=n.mul(o,r[l]),n.mul(o,a)),i),r}function Aa(n,t){const e=(n.ORDER-Ee)/Or,r=n.pow(t,e),s=n.eql(r,n.ONE),i=n.eql(r,n.ZERO),o=n.eql(r,n.neg(n.ONE));if(!s&&!i&&!o)throw new Error("invalid Legendre symbol result");return s?1:i?0:-1}function bu(n,t){t!==void 0&&An(t);const e=t!==void 0?t:n.toString(2).length,r=Math.ceil(e/8);return{nBitLength:e,nByteLength:r}}function zr(n,t,e=!1,r={}){if(n<=xe)throw new Error("invalid field: expected ORDER > 0, got "+n);let s,i,o=!1,a;if(typeof t=="object"&&t!=null){if(r.sqrt||e)throw new Error("cannot specify opts in two arguments");const R=t;R.BITS&&(s=R.BITS),R.sqrt&&(i=R.sqrt),typeof R.isLE=="boolean"&&(e=R.isLE),typeof R.modFromBytes=="boolean"&&(o=R.modFromBytes),a=R.allowedLengths}else typeof t=="number"&&(s=t),r.sqrt&&(i=r.sqrt);const{nBitLength:l,nByteLength:p}=bu(n,s);if(p>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let m;const S=Object.freeze({ORDER:n,isLE:e,BITS:l,BYTES:p,MASK:Bn(l),ZERO:xe,ONE:Ee,allowedLengths:a,create:R=>pe(R,n),isValid:R=>{if(typeof R!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof R);return xe<=R&&R<n},is0:R=>R===xe,isValidNot0:R=>!S.is0(R)&&S.isValid(R),isOdd:R=>(R&Ee)===Ee,neg:R=>pe(-R,n),eql:(R,_)=>R===_,sqr:R=>pe(R*R,n),add:(R,_)=>pe(R+_,n),sub:(R,_)=>pe(R-_,n),mul:(R,_)=>pe(R*_,n),pow:(R,_)=>md(S,R,_),div:(R,_)=>pe(R*va(_,n),n),sqrN:R=>R*R,addN:(R,_)=>R+_,subN:(R,_)=>R-_,mulN:(R,_)=>R*_,inv:R=>va(R,n),sqrt:i||(R=>(m||(m=dd(n)),m(S,R))),toBytes:R=>e?lu(R,p):ko(R,p),fromBytes:(R,_=!0)=>{if(a){if(!a.includes(R.length)||R.length>p)throw new Error("Field.fromBytes: expected "+a+" bytes, got "+R.length);const O=new Uint8Array(p);O.set(R,e?0:O.length-R.length),R=O}if(R.length!==p)throw new Error("Field.fromBytes: expected "+p+" bytes, got "+R.length);let I=e?In(R):xi(R);if(o&&(I=pe(I,n)),!_&&!S.isValid(I))throw new Error("invalid field element: outside of range 0..ORDER");return I},invertBatch:R=>_u(S,R),cmov:(R,_,I)=>I?_:R});return Object.freeze(S)}function Eu(n){if(typeof n!="bigint")throw new Error("field order must be bigint");const t=n.toString(2).length;return Math.ceil(t/8)}function Ru(n){const t=Eu(n);return t+Math.ceil(t/2)}function wd(n,t,e=!1){const r=n.length,s=Eu(t),i=Ru(t);if(r<16||r<i||r>1024)throw new Error("expected "+i+"-1024 bytes of input, got "+r);const o=e?In(n):xi(n),a=pe(o,t-Ee)+Ee;return e?lu(a,s):ko(a,s)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const an=BigInt(0),xr=BigInt(1);function pi(n,t){const e=t.negate();return n?e:t}function Nr(n,t){const e=_u(n.Fp,t.map(r=>r.Z));return t.map((r,s)=>n.fromAffine(r.toAffine(e[s])))}function vu(n,t){if(!Number.isSafeInteger(n)||n<=0||n>t)throw new Error("invalid window size, expected [1.."+t+"], got W="+n)}function ms(n,t){vu(n,t);const e=Math.ceil(t/n)+1,r=2**(n-1),s=2**n,i=Bn(n),o=BigInt(n);return{windows:e,windowSize:r,mask:i,maxNumber:s,shiftBy:o}}function Ia(n,t,e){const{windowSize:r,mask:s,maxNumber:i,shiftBy:o}=e;let a=Number(n&s),l=n>>o;a>r&&(a-=i,l+=xr);const p=t*r,m=p+Math.abs(a)-1,S=a===0,R=a<0,_=t%2!==0;return{nextN:l,offset:m,isZero:S,isNeg:R,isNegF:_,offsetF:p}}function _d(n,t){if(!Array.isArray(n))throw new Error("array expected");n.forEach((e,r)=>{if(!(e instanceof t))throw new Error("invalid point at index "+r)})}function bd(n,t){if(!Array.isArray(n))throw new Error("array of scalars expected");n.forEach((e,r)=>{if(!t.isValid(e))throw new Error("invalid scalar at index "+r)})}const ws=new WeakMap,Au=new WeakMap;function _s(n){return Au.get(n)||1}function Sa(n){if(n!==an)throw new Error("invalid wNAF")}class Iu{constructor(t,e){this.BASE=t.BASE,this.ZERO=t.ZERO,this.Fn=t.Fn,this.bits=e}_unsafeLadder(t,e,r=this.ZERO){let s=t;for(;e>an;)e&xr&&(r=r.add(s)),s=s.double(),e>>=xr;return r}precomputeWindow(t,e){const{windows:r,windowSize:s}=ms(e,this.bits),i=[];let o=t,a=o;for(let l=0;l<r;l++){a=o,i.push(a);for(let p=1;p<s;p++)a=a.add(o),i.push(a);o=a.double()}return i}wNAF(t,e,r){if(!this.Fn.isValid(r))throw new Error("invalid scalar");let s=this.ZERO,i=this.BASE;const o=ms(t,this.bits);for(let a=0;a<o.windows;a++){const{nextN:l,offset:p,isZero:m,isNeg:S,isNegF:R,offsetF:_}=Ia(r,a,o);r=l,m?i=i.add(pi(R,e[_])):s=s.add(pi(S,e[p]))}return Sa(r),{p:s,f:i}}wNAFUnsafe(t,e,r,s=this.ZERO){const i=ms(t,this.bits);for(let o=0;o<i.windows&&r!==an;o++){const{nextN:a,offset:l,isZero:p,isNeg:m}=Ia(r,o,i);if(r=a,!p){const S=e[l];s=s.add(m?S.negate():S)}}return Sa(r),s}getPrecomputes(t,e,r){let s=ws.get(e);return s||(s=this.precomputeWindow(e,t),t!==1&&(typeof r=="function"&&(s=r(s)),ws.set(e,s))),s}cached(t,e,r){const s=_s(t);return this.wNAF(s,this.getPrecomputes(s,t,r),e)}unsafe(t,e,r,s){const i=_s(t);return i===1?this._unsafeLadder(t,e,s):this.wNAFUnsafe(i,this.getPrecomputes(i,t,r),e,s)}createCache(t,e){vu(e,this.bits),Au.set(t,e),ws.delete(t)}hasCache(t){return _s(t)!==1}}function Ed(n,t,e,r){let s=t,i=n.ZERO,o=n.ZERO;for(;e>an||r>an;)e&xr&&(i=i.add(s)),r&xr&&(o=o.add(s)),s=s.double(),e>>=xr,r>>=xr;return{p1:i,p2:o}}function Su(n,t,e,r){_d(e,n),bd(r,t);const s=e.length,i=r.length;if(s!==i)throw new Error("arrays of points and scalars must have equal length");const o=n.ZERO,a=hu(BigInt(s));let l=1;a>12?l=a-3:a>4?l=a-2:a>0&&(l=2);const p=Bn(l),m=new Array(Number(p)+1).fill(o),S=Math.floor((t.BITS-1)/l)*l;let R=o;for(let _=S;_>=0;_-=l){m.fill(o);for(let O=0;O<i;O++){const x=r[O],M=Number(x>>BigInt(_)&p);m[M]=m[M].add(e[O])}let I=o;for(let O=m.length-1,x=o;O>0;O--)x=x.add(m[O]),I=I.add(x);if(R=R.add(I),_!==0)for(let O=0;O<l;O++)R=R.double()}return R}function ka(n,t,e){if(t){if(t.ORDER!==n)throw new Error("Field.ORDER must match order: Fp == p, Fn == n");return gd(t),t}else return zr(n,{isLE:e})}function ku(n,t,e={},r){if(r===void 0&&(r=n==="edwards"),!t||typeof t!="object")throw new Error(`expected valid ${n} CURVE object`);for(const l of["p","n","h"]){const p=t[l];if(!(typeof p=="bigint"&&p>an))throw new Error(`CURVE.${l} must be positive bigint`)}const s=ka(t.p,e.Fp,r),i=ka(t.n,e.Fn,r),a=["Gx","Gy","a",n==="weierstrass"?"b":"d"];for(const l of a)if(!s.isValid(t[l]))throw new Error(`CURVE.${l} must be valid field element of CURVE.Fp`);return t=Object.freeze(Object.assign({},t)),{CURVE:t,Fp:s,Fn:i}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const mr=BigInt(0),me=BigInt(1),bs=BigInt(2),Rd=BigInt(8);function vd(n,t,e,r){const s=n.sqr(e),i=n.sqr(r),o=n.add(n.mul(t.a,s),i),a=n.add(n.ONE,n.mul(t.d,n.mul(s,i)));return n.eql(o,a)}function Ad(n,t={}){const e=ku("edwards",n,t,t.FpFnLE),{Fp:r,Fn:s}=e;let i=e.CURVE;const{h:o}=i;Mn(t,{},{uvRatio:"function"});const a=bs<<BigInt(s.BYTES*8)-me,l=x=>r.create(x),p=t.uvRatio||((x,M)=>{try{return{isValid:!0,value:r.sqrt(r.div(x,M))}}catch{return{isValid:!1,value:mr}}});if(!vd(r,i,i.Gx,i.Gy))throw new Error("bad curve params: generator point");function m(x,M,H=!1){const P=H?me:mr;return no("coordinate "+x,M,P,a),M}function S(x){if(!(x instanceof I))throw new Error("ExtendedPoint expected")}const R=di((x,M)=>{const{X:H,Y:P,Z:q}=x,G=x.is0();M==null&&(M=G?Rd:r.inv(q));const J=l(H*M),Q=l(P*M),tt=r.mul(q,M);if(G)return{x:mr,y:me};if(tt!==me)throw new Error("invZ was invalid");return{x:J,y:Q}}),_=di(x=>{const{a:M,d:H}=i;if(x.is0())throw new Error("bad point: ZERO");const{X:P,Y:q,Z:G,T:J}=x,Q=l(P*P),tt=l(q*q),L=l(G*G),U=l(L*L),F=l(Q*M),z=l(L*l(F+tt)),b=l(U+l(H*l(Q*tt)));if(z!==b)throw new Error("bad point: equation left != right (1)");const c=l(P*q),f=l(G*J);if(c!==f)throw new Error("bad point: equation left != right (2)");return!0});class I{constructor(M,H,P,q){this.X=m("x",M),this.Y=m("y",H),this.Z=m("z",P,!0),this.T=m("t",q),Object.freeze(this)}static CURVE(){return i}static fromAffine(M){if(M instanceof I)throw new Error("extended point not allowed");const{x:H,y:P}=M||{};return m("x",H),m("y",P),new I(H,P,me,l(H*P))}static fromBytes(M,H=!1){const P=r.BYTES,{a:q,d:G}=i;M=Ra(ze(M,P,"point")),Pr(H,"zip215");const J=Ra(M),Q=M[P-1];J[P-1]=Q&-129;const tt=In(J),L=H?a:r.ORDER;no("point.y",tt,mr,L);const U=l(tt*tt),F=l(U-me),z=l(G*U-q);let{isValid:b,value:c}=p(F,z);if(!b)throw new Error("bad point: invalid y coordinate");const f=(c&me)===me,E=(Q&128)!==0;if(!H&&c===mr&&E)throw new Error("bad point: x=0 and x_0=1");return E!==f&&(c=l(-c)),I.fromAffine({x:c,y:tt})}static fromHex(M,H=!1){return I.fromBytes(jt("point",M),H)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}precompute(M=8,H=!0){return O.createCache(this,M),H||this.multiply(bs),this}assertValidity(){_(this)}equals(M){S(M);const{X:H,Y:P,Z:q}=this,{X:G,Y:J,Z:Q}=M,tt=l(H*Q),L=l(G*q),U=l(P*Q),F=l(J*q);return tt===L&&U===F}is0(){return this.equals(I.ZERO)}negate(){return new I(l(-this.X),this.Y,this.Z,l(-this.T))}double(){const{a:M}=i,{X:H,Y:P,Z:q}=this,G=l(H*H),J=l(P*P),Q=l(bs*l(q*q)),tt=l(M*G),L=H+P,U=l(l(L*L)-G-J),F=tt+J,z=F-Q,b=tt-J,c=l(U*z),f=l(F*b),E=l(U*b),T=l(z*F);return new I(c,f,T,E)}add(M){S(M);const{a:H,d:P}=i,{X:q,Y:G,Z:J,T:Q}=this,{X:tt,Y:L,Z:U,T:F}=M,z=l(q*tt),b=l(G*L),c=l(Q*P*F),f=l(J*U),E=l((q+G)*(tt+L)-z-b),T=f-c,N=f+c,A=l(b-H*z),g=l(E*T),d=l(N*A),u=l(E*A),h=l(T*N);return new I(g,d,h,u)}subtract(M){return this.add(M.negate())}multiply(M){if(!s.isValidNot0(M))throw new Error("invalid scalar: expected 1 <= sc < curve.n");const{p:H,f:P}=O.cached(this,M,q=>Nr(I,q));return Nr(I,[H,P])[0]}multiplyUnsafe(M,H=I.ZERO){if(!s.isValid(M))throw new Error("invalid scalar: expected 0 <= sc < curve.n");return M===mr?I.ZERO:this.is0()||M===me?this:O.unsafe(this,M,P=>Nr(I,P),H)}isSmallOrder(){return this.multiplyUnsafe(o).is0()}isTorsionFree(){return O.unsafe(this,i.n).is0()}toAffine(M){return R(this,M)}clearCofactor(){return o===me?this:this.multiplyUnsafe(o)}toBytes(){const{x:M,y:H}=this.toAffine(),P=r.toBytes(H);return P[P.length-1]|=M&me?128:0,P}toHex(){return Lr(this.toBytes())}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}get ex(){return this.X}get ey(){return this.Y}get ez(){return this.Z}get et(){return this.T}static normalizeZ(M){return Nr(I,M)}static msm(M,H){return Su(I,s,M,H)}_setWindowSize(M){this.precompute(M)}toRawBytes(){return this.toBytes()}}I.BASE=new I(i.Gx,i.Gy,me,l(i.Gx*i.Gy)),I.ZERO=new I(mr,me,me,mr),I.Fp=r,I.Fn=s;const O=new Iu(I,s.BITS);return I.BASE.precompute(8),I}function Id(n,t,e={}){if(typeof t!="function")throw new Error('"hash" function param is required');Mn(e,{},{adjustScalarBytes:"function",randomBytes:"function",domain:"function",prehash:"function",mapToCurve:"function"});const{prehash:r}=e,{BASE:s,Fp:i,Fn:o}=n,a=e.randomBytes||Io,l=e.adjustScalarBytes||(L=>L),p=e.domain||((L,U,F)=>{if(Pr(F,"phflag"),U.length||F)throw new Error("Contexts/pre-hash are not supported");return L});function m(L){return o.create(In(L))}function S(L){const U=P.secretKey;L=jt("private key",L,U);const F=jt("hashed private key",t(L),2*U),z=l(F.slice(0,U)),b=F.slice(U,2*U),c=m(z);return{head:z,prefix:b,scalar:c}}function R(L){const{head:U,prefix:F,scalar:z}=S(L),b=s.multiply(z),c=b.toBytes();return{head:U,prefix:F,scalar:z,point:b,pointBytes:c}}function _(L){return R(L).pointBytes}function I(L=Uint8Array.of(),...U){const F=Ge(...U);return m(t(p(F,jt("context",L),!!r)))}function O(L,U,F={}){L=jt("message",L),r&&(L=r(L));const{prefix:z,scalar:b,pointBytes:c}=R(U),f=I(F.context,z,L),E=s.multiply(f).toBytes(),T=I(F.context,E,c,L),N=o.create(f+T*b);if(!o.isValid(N))throw new Error("sign failed: invalid s");const A=Ge(E,o.toBytes(N));return ze(A,P.signature,"result")}const x={zip215:!0};function M(L,U,F,z=x){const{context:b,zip215:c}=z,f=P.signature;L=jt("signature",L,f),U=jt("message",U),F=jt("publicKey",F,P.publicKey),c!==void 0&&Pr(c,"zip215"),r&&(U=r(U));const E=f/2,T=L.subarray(0,E),N=In(L.subarray(E,f));let A,g,d;try{A=n.fromBytes(F,c),g=n.fromBytes(T,c),d=s.multiplyUnsafe(N)}catch{return!1}if(!c&&A.isSmallOrder())return!1;const u=I(b,g.toBytes(),A.toBytes(),U);return g.add(A.multiplyUnsafe(u)).subtract(d).clearCofactor().is0()}const H=i.BYTES,P={secretKey:H,publicKey:H,signature:2*H,seed:H};function q(L=a(P.seed)){return ze(L,P.seed,"seed")}function G(L){const U=tt.randomSecretKey(L);return{secretKey:U,publicKey:_(U)}}function J(L){return Cn(L)&&L.length===o.BYTES}function Q(L,U){try{return!!n.fromBytes(L,U)}catch{return!1}}const tt={getExtendedPublicKey:R,randomSecretKey:q,isValidSecretKey:J,isValidPublicKey:Q,toMontgomery(L){const{y:U}=n.fromBytes(L),F=P.publicKey,z=F===32;if(!z&&F!==57)throw new Error("only defined for 25519 and 448");const b=z?i.div(me+U,me-U):i.div(U-me,U+me);return i.toBytes(b)},toMontgomerySecret(L){const U=P.secretKey;ze(L,U);const F=t(L.subarray(0,U));return l(F).subarray(0,U)},randomPrivateKey:q,precompute(L=8,U=n.BASE){return U.precompute(L,!1)}};return Object.freeze({keygen:G,getPublicKey:_,sign:O,verify:M,utils:tt,Point:n,lengths:P})}function Sd(n){const t={a:n.a,d:n.d,p:n.Fp.ORDER,n:n.n,h:n.h,Gx:n.Gx,Gy:n.Gy},e=n.Fp,r=zr(t.n,n.nBitLength,!0),s={Fp:e,Fn:r,uvRatio:n.uvRatio},i={randomBytes:n.randomBytes,adjustScalarBytes:n.adjustScalarBytes,domain:n.domain,prehash:n.prehash,mapToCurve:n.mapToCurve};return{CURVE:t,curveOpts:s,hash:n.hash,eddsaOpts:i}}function kd(n,t){const e=t.Point;return Object.assign({},t,{ExtendedPoint:e,CURVE:n,nBitLength:e.Fn.BITS,nByteLength:e.Fn.BYTES})}function Td(n){const{CURVE:t,curveOpts:e,hash:r,eddsaOpts:s}=Sd(n),i=Ad(t,e),o=Id(i,r,s);return kd(n,o)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Od=BigInt(1),Ta=BigInt(2);BigInt(3);const xd=BigInt(5),Nd=BigInt(8),Oo=BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed"),Tu={p:Oo,n:BigInt("0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed"),h:Nd,a:BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec"),d:BigInt("0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3"),Gx:BigInt("0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a"),Gy:BigInt("0x6666666666666666666666666666666666666666666666666666666666666658")};function Cd(n){const t=BigInt(10),e=BigInt(20),r=BigInt(40),s=BigInt(80),i=Oo,a=n*n%i*n%i,l=Gt(a,Ta,i)*a%i,p=Gt(l,Od,i)*n%i,m=Gt(p,xd,i)*p%i,S=Gt(m,t,i)*m%i,R=Gt(S,e,i)*S%i,_=Gt(R,r,i)*R%i,I=Gt(_,s,i)*_%i,O=Gt(I,s,i)*_%i,x=Gt(O,t,i)*m%i;return{pow_p_5_8:Gt(x,Ta,i)*n%i,b2:a}}function Bd(n){return n[0]&=248,n[31]&=127,n[31]|=64,n}const Oa=BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");function Md(n,t){const e=Oo,r=pe(t*t*t,e),s=pe(r*r*t,e),i=Cd(n*s).pow_p_5_8;let o=pe(n*r*i,e);const a=pe(t*o*o,e),l=o,p=pe(o*Oa,e),m=a===n,S=a===pe(-n,e),R=a===pe(-n*Oa,e);return m&&(o=l),(S||R)&&(o=p),pd(o,e)&&(o=pe(-o,e)),{isValid:m||S,value:o}}const Ld=zr(Tu.p,{isLE:!0}),Pd={...Tu,Fp:Ld,hash:od,adjustScalarBytes:Bd,uvRatio:Md},hn=Td(Pd);var ai={exports:{}};const Ud={},Dd=Object.freeze({__proto__:null,default:Ud}),Hd=Ti(Dd);var Fd=ai.exports,xa;function xo(){return xa||(xa=1,(function(n){(function(t,e){function r(b,c){if(!b)throw new Error(c||"Assertion failed")}function s(b,c){b.super_=c;var f=function(){};f.prototype=c.prototype,b.prototype=new f,b.prototype.constructor=b}function i(b,c,f){if(i.isBN(b))return b;this.negative=0,this.words=null,this.length=0,this.red=null,b!==null&&((c==="le"||c==="be")&&(f=c,c=10),this._init(b||0,c||10,f||"be"))}typeof t=="object"?t.exports=i:e.BN=i,i.BN=i,i.wordSize=26;var o;try{typeof window<"u"&&typeof window.Buffer<"u"?o=window.Buffer:o=Hd.Buffer}catch{}i.isBN=function(c){return c instanceof i?!0:c!==null&&typeof c=="object"&&c.constructor.wordSize===i.wordSize&&Array.isArray(c.words)},i.max=function(c,f){return c.cmp(f)>0?c:f},i.min=function(c,f){return c.cmp(f)<0?c:f},i.prototype._init=function(c,f,E){if(typeof c=="number")return this._initNumber(c,f,E);if(typeof c=="object")return this._initArray(c,f,E);f==="hex"&&(f=16),r(f===(f|0)&&f>=2&&f<=36),c=c.toString().replace(/\s+/g,"");var T=0;c[0]==="-"&&(T++,this.negative=1),T<c.length&&(f===16?this._parseHex(c,T,E):(this._parseBase(c,f,T),E==="le"&&this._initArray(this.toArray(),f,E)))},i.prototype._initNumber=function(c,f,E){c<0&&(this.negative=1,c=-c),c<67108864?(this.words=[c&67108863],this.length=1):c<4503599627370496?(this.words=[c&67108863,c/67108864&67108863],this.length=2):(r(c<9007199254740992),this.words=[c&67108863,c/67108864&67108863,1],this.length=3),E==="le"&&this._initArray(this.toArray(),f,E)},i.prototype._initArray=function(c,f,E){if(r(typeof c.length=="number"),c.length<=0)return this.words=[0],this.length=1,this;this.length=Math.ceil(c.length/3),this.words=new Array(this.length);for(var T=0;T<this.length;T++)this.words[T]=0;var N,A,g=0;if(E==="be")for(T=c.length-1,N=0;T>=0;T-=3)A=c[T]|c[T-1]<<8|c[T-2]<<16,this.words[N]|=A<<g&67108863,this.words[N+1]=A>>>26-g&67108863,g+=24,g>=26&&(g-=26,N++);else if(E==="le")for(T=0,N=0;T<c.length;T+=3)A=c[T]|c[T+1]<<8|c[T+2]<<16,this.words[N]|=A<<g&67108863,this.words[N+1]=A>>>26-g&67108863,g+=24,g>=26&&(g-=26,N++);return this._strip()};function a(b,c){var f=b.charCodeAt(c);if(f>=48&&f<=57)return f-48;if(f>=65&&f<=70)return f-55;if(f>=97&&f<=102)return f-87;r(!1,"Invalid character in "+b)}function l(b,c,f){var E=a(b,f);return f-1>=c&&(E|=a(b,f-1)<<4),E}i.prototype._parseHex=function(c,f,E){this.length=Math.ceil((c.length-f)/6),this.words=new Array(this.length);for(var T=0;T<this.length;T++)this.words[T]=0;var N=0,A=0,g;if(E==="be")for(T=c.length-1;T>=f;T-=2)g=l(c,f,T)<<N,this.words[A]|=g&67108863,N>=18?(N-=18,A+=1,this.words[A]|=g>>>26):N+=8;else{var d=c.length-f;for(T=d%2===0?f+1:f;T<c.length;T+=2)g=l(c,f,T)<<N,this.words[A]|=g&67108863,N>=18?(N-=18,A+=1,this.words[A]|=g>>>26):N+=8}this._strip()};function p(b,c,f,E){for(var T=0,N=0,A=Math.min(b.length,f),g=c;g<A;g++){var d=b.charCodeAt(g)-48;T*=E,d>=49?N=d-49+10:d>=17?N=d-17+10:N=d,r(d>=0&&N<E,"Invalid character"),T+=N}return T}i.prototype._parseBase=function(c,f,E){this.words=[0],this.length=1;for(var T=0,N=1;N<=67108863;N*=f)T++;T--,N=N/f|0;for(var A=c.length-E,g=A%T,d=Math.min(A,A-g)+E,u=0,h=E;h<d;h+=T)u=p(c,h,h+T,f),this.imuln(N),this.words[0]+u<67108864?this.words[0]+=u:this._iaddn(u);if(g!==0){var v=1;for(u=p(c,h,c.length,f),h=0;h<g;h++)v*=f;this.imuln(v),this.words[0]+u<67108864?this.words[0]+=u:this._iaddn(u)}this._strip()},i.prototype.copy=function(c){c.words=new Array(this.length);for(var f=0;f<this.length;f++)c.words[f]=this.words[f];c.length=this.length,c.negative=this.negative,c.red=this.red};function m(b,c){b.words=c.words,b.length=c.length,b.negative=c.negative,b.red=c.red}if(i.prototype._move=function(c){m(c,this)},i.prototype.clone=function(){var c=new i(null);return this.copy(c),c},i.prototype._expand=function(c){for(;this.length<c;)this.words[this.length++]=0;return this},i.prototype._strip=function(){for(;this.length>1&&this.words[this.length-1]===0;)this.length--;return this._normSign()},i.prototype._normSign=function(){return this.length===1&&this.words[0]===0&&(this.negative=0),this},typeof Symbol<"u"&&typeof Symbol.for=="function")try{i.prototype[Symbol.for("nodejs.util.inspect.custom")]=S}catch{i.prototype.inspect=S}else i.prototype.inspect=S;function S(){return(this.red?"<BN-R: ":"<BN: ")+this.toString(16)+">"}var R=["","0","00","000","0000","00000","000000","0000000","00000000","000000000","0000000000","00000000000","000000000000","0000000000000","00000000000000","000000000000000","0000000000000000","00000000000000000","000000000000000000","0000000000000000000","00000000000000000000","000000000000000000000","0000000000000000000000","00000000000000000000000","000000000000000000000000","0000000000000000000000000"],_=[0,0,25,16,12,11,10,9,8,8,7,7,7,7,6,6,6,6,6,6,6,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5],I=[0,0,33554432,43046721,16777216,48828125,60466176,40353607,16777216,43046721,1e7,19487171,35831808,62748517,7529536,11390625,16777216,24137569,34012224,47045881,64e6,4084101,5153632,6436343,7962624,9765625,11881376,14348907,17210368,20511149,243e5,28629151,33554432,39135393,45435424,52521875,60466176];i.prototype.toString=function(c,f){c=c||10,f=f|0||1;var E;if(c===16||c==="hex"){E="";for(var T=0,N=0,A=0;A<this.length;A++){var g=this.words[A],d=((g<<T|N)&16777215).toString(16);N=g>>>24-T&16777215,T+=2,T>=26&&(T-=26,A--),N!==0||A!==this.length-1?E=R[6-d.length]+d+E:E=d+E}for(N!==0&&(E=N.toString(16)+E);E.length%f!==0;)E="0"+E;return this.negative!==0&&(E="-"+E),E}if(c===(c|0)&&c>=2&&c<=36){var u=_[c],h=I[c];E="";var v=this.clone();for(v.negative=0;!v.isZero();){var C=v.modrn(h).toString(c);v=v.idivn(h),v.isZero()?E=C+E:E=R[u-C.length]+C+E}for(this.isZero()&&(E="0"+E);E.length%f!==0;)E="0"+E;return this.negative!==0&&(E="-"+E),E}r(!1,"Base should be between 2 and 36")},i.prototype.toNumber=function(){var c=this.words[0];return this.length===2?c+=this.words[1]*67108864:this.length===3&&this.words[2]===1?c+=4503599627370496+this.words[1]*67108864:this.length>2&&r(!1,"Number can only safely store up to 53 bits"),this.negative!==0?-c:c},i.prototype.toJSON=function(){return this.toString(16,2)},o&&(i.prototype.toBuffer=function(c,f){return this.toArrayLike(o,c,f)}),i.prototype.toArray=function(c,f){return this.toArrayLike(Array,c,f)};var O=function(c,f){return c.allocUnsafe?c.allocUnsafe(f):new c(f)};i.prototype.toArrayLike=function(c,f,E){this._strip();var T=this.byteLength(),N=E||Math.max(1,T);r(T<=N,"byte array longer than desired length"),r(N>0,"Requested array length <= 0");var A=O(c,N),g=f==="le"?"LE":"BE";return this["_toArrayLike"+g](A,T),A},i.prototype._toArrayLikeLE=function(c,f){for(var E=0,T=0,N=0,A=0;N<this.length;N++){var g=this.words[N]<<A|T;c[E++]=g&255,E<c.length&&(c[E++]=g>>8&255),E<c.length&&(c[E++]=g>>16&255),A===6?(E<c.length&&(c[E++]=g>>24&255),T=0,A=0):(T=g>>>24,A+=2)}if(E<c.length)for(c[E++]=T;E<c.length;)c[E++]=0},i.prototype._toArrayLikeBE=function(c,f){for(var E=c.length-1,T=0,N=0,A=0;N<this.length;N++){var g=this.words[N]<<A|T;c[E--]=g&255,E>=0&&(c[E--]=g>>8&255),E>=0&&(c[E--]=g>>16&255),A===6?(E>=0&&(c[E--]=g>>24&255),T=0,A=0):(T=g>>>24,A+=2)}if(E>=0)for(c[E--]=T;E>=0;)c[E--]=0},Math.clz32?i.prototype._countBits=function(c){return 32-Math.clz32(c)}:i.prototype._countBits=function(c){var f=c,E=0;return f>=4096&&(E+=13,f>>>=13),f>=64&&(E+=7,f>>>=7),f>=8&&(E+=4,f>>>=4),f>=2&&(E+=2,f>>>=2),E+f},i.prototype._zeroBits=function(c){if(c===0)return 26;var f=c,E=0;return(f&8191)===0&&(E+=13,f>>>=13),(f&127)===0&&(E+=7,f>>>=7),(f&15)===0&&(E+=4,f>>>=4),(f&3)===0&&(E+=2,f>>>=2),(f&1)===0&&E++,E},i.prototype.bitLength=function(){var c=this.words[this.length-1],f=this._countBits(c);return(this.length-1)*26+f};function x(b){for(var c=new Array(b.bitLength()),f=0;f<c.length;f++){var E=f/26|0,T=f%26;c[f]=b.words[E]>>>T&1}return c}i.prototype.zeroBits=function(){if(this.isZero())return 0;for(var c=0,f=0;f<this.length;f++){var E=this._zeroBits(this.words[f]);if(c+=E,E!==26)break}return c},i.prototype.byteLength=function(){return Math.ceil(this.bitLength()/8)},i.prototype.toTwos=function(c){return this.negative!==0?this.abs().inotn(c).iaddn(1):this.clone()},i.prototype.fromTwos=function(c){return this.testn(c-1)?this.notn(c).iaddn(1).ineg():this.clone()},i.prototype.isNeg=function(){return this.negative!==0},i.prototype.neg=function(){return this.clone().ineg()},i.prototype.ineg=function(){return this.isZero()||(this.negative^=1),this},i.prototype.iuor=function(c){for(;this.length<c.length;)this.words[this.length++]=0;for(var f=0;f<c.length;f++)this.words[f]=this.words[f]|c.words[f];return this._strip()},i.prototype.ior=function(c){return r((this.negative|c.negative)===0),this.iuor(c)},i.prototype.or=function(c){return this.length>c.length?this.clone().ior(c):c.clone().ior(this)},i.prototype.uor=function(c){return this.length>c.length?this.clone().iuor(c):c.clone().iuor(this)},i.prototype.iuand=function(c){var f;this.length>c.length?f=c:f=this;for(var E=0;E<f.length;E++)this.words[E]=this.words[E]&c.words[E];return this.length=f.length,this._strip()},i.prototype.iand=function(c){return r((this.negative|c.negative)===0),this.iuand(c)},i.prototype.and=function(c){return this.length>c.length?this.clone().iand(c):c.clone().iand(this)},i.prototype.uand=function(c){return this.length>c.length?this.clone().iuand(c):c.clone().iuand(this)},i.prototype.iuxor=function(c){var f,E;this.length>c.length?(f=this,E=c):(f=c,E=this);for(var T=0;T<E.length;T++)this.words[T]=f.words[T]^E.words[T];if(this!==f)for(;T<f.length;T++)this.words[T]=f.words[T];return this.length=f.length,this._strip()},i.prototype.ixor=function(c){return r((this.negative|c.negative)===0),this.iuxor(c)},i.prototype.xor=function(c){return this.length>c.length?this.clone().ixor(c):c.clone().ixor(this)},i.prototype.uxor=function(c){return this.length>c.length?this.clone().iuxor(c):c.clone().iuxor(this)},i.prototype.inotn=function(c){r(typeof c=="number"&&c>=0);var f=Math.ceil(c/26)|0,E=c%26;this._expand(f),E>0&&f--;for(var T=0;T<f;T++)this.words[T]=~this.words[T]&67108863;return E>0&&(this.words[T]=~this.words[T]&67108863>>26-E),this._strip()},i.prototype.notn=function(c){return this.clone().inotn(c)},i.prototype.setn=function(c,f){r(typeof c=="number"&&c>=0);var E=c/26|0,T=c%26;return this._expand(E+1),f?this.words[E]=this.words[E]|1<<T:this.words[E]=this.words[E]&~(1<<T),this._strip()},i.prototype.iadd=function(c){var f;if(this.negative!==0&&c.negative===0)return this.negative=0,f=this.isub(c),this.negative^=1,this._normSign();if(this.negative===0&&c.negative!==0)return c.negative=0,f=this.isub(c),c.negative=1,f._normSign();var E,T;this.length>c.length?(E=this,T=c):(E=c,T=this);for(var N=0,A=0;A<T.length;A++)f=(E.words[A]|0)+(T.words[A]|0)+N,this.words[A]=f&67108863,N=f>>>26;for(;N!==0&&A<E.length;A++)f=(E.words[A]|0)+N,this.words[A]=f&67108863,N=f>>>26;if(this.length=E.length,N!==0)this.words[this.length]=N,this.length++;else if(E!==this)for(;A<E.length;A++)this.words[A]=E.words[A];return this},i.prototype.add=function(c){var f;return c.negative!==0&&this.negative===0?(c.negative=0,f=this.sub(c),c.negative^=1,f):c.negative===0&&this.negative!==0?(this.negative=0,f=c.sub(this),this.negative=1,f):this.length>c.length?this.clone().iadd(c):c.clone().iadd(this)},i.prototype.isub=function(c){if(c.negative!==0){c.negative=0;var f=this.iadd(c);return c.negative=1,f._normSign()}else if(this.negative!==0)return this.negative=0,this.iadd(c),this.negative=1,this._normSign();var E=this.cmp(c);if(E===0)return this.negative=0,this.length=1,this.words[0]=0,this;var T,N;E>0?(T=this,N=c):(T=c,N=this);for(var A=0,g=0;g<N.length;g++)f=(T.words[g]|0)-(N.words[g]|0)+A,A=f>>26,this.words[g]=f&67108863;for(;A!==0&&g<T.length;g++)f=(T.words[g]|0)+A,A=f>>26,this.words[g]=f&67108863;if(A===0&&g<T.length&&T!==this)for(;g<T.length;g++)this.words[g]=T.words[g];return this.length=Math.max(this.length,g),T!==this&&(this.negative=1),this._strip()},i.prototype.sub=function(c){return this.clone().isub(c)};function M(b,c,f){f.negative=c.negative^b.negative;var E=b.length+c.length|0;f.length=E,E=E-1|0;var T=b.words[0]|0,N=c.words[0]|0,A=T*N,g=A&67108863,d=A/67108864|0;f.words[0]=g;for(var u=1;u<E;u++){for(var h=d>>>26,v=d&67108863,C=Math.min(u,c.length-1),K=Math.max(0,u-b.length+1);K<=C;K++){var Z=u-K|0;T=b.words[Z]|0,N=c.words[K]|0,A=T*N+v,h+=A/67108864|0,v=A&67108863}f.words[u]=v|0,d=h|0}return d!==0?f.words[u]=d|0:f.length--,f._strip()}var H=function(c,f,E){var T=c.words,N=f.words,A=E.words,g=0,d,u,h,v=T[0]|0,C=v&8191,K=v>>>13,Z=T[1]|0,it=Z&8191,ut=Z>>>13,St=T[2]|0,kt=St&8191,Nt=St>>>13,Pe=T[3]|0,Ct=Pe&8191,qt=Pe>>>13,qn=T[4]|0,Ut=qn&8191,$t=qn>>>13,$n=T[5]|0,Ft=$n&8191,Lt=$n>>>13,Ce=T[6]|0,Dt=Ce&8191,Vt=Ce>>>13,Fe=T[7]|0,Wt=Fe&8191,k=Fe>>>13,y=T[8]|0,w=y&8191,B=y>>>13,$=T[9]|0,V=$&8191,X=$>>>13,wt=N[0]|0,gt=wt&8191,yt=wt>>>13,Pt=N[1]|0,pt=Pt&8191,Zt=Pt>>>13,oa=N[2]|0,Xt=oa&8191,Jt=oa>>>13,aa=N[3]|0,Qt=aa&8191,te=aa>>>13,ca=N[4]|0,ee=ca&8191,re=ca>>>13,ua=N[5]|0,ne=ua&8191,ie=ua>>>13,la=N[6]|0,se=la&8191,oe=la>>>13,ha=N[7]|0,ae=ha&8191,ce=ha>>>13,fa=N[8]|0,ue=fa&8191,le=fa>>>13,da=N[9]|0,he=da&8191,fe=da>>>13;E.negative=c.negative^f.negative,E.length=19,d=Math.imul(C,gt),u=Math.imul(C,yt),u=u+Math.imul(K,gt)|0,h=Math.imul(K,yt);var Yi=(g+d|0)+((u&8191)<<13)|0;g=(h+(u>>>13)|0)+(Yi>>>26)|0,Yi&=67108863,d=Math.imul(it,gt),u=Math.imul(it,yt),u=u+Math.imul(ut,gt)|0,h=Math.imul(ut,yt),d=d+Math.imul(C,pt)|0,u=u+Math.imul(C,Zt)|0,u=u+Math.imul(K,pt)|0,h=h+Math.imul(K,Zt)|0;var Zi=(g+d|0)+((u&8191)<<13)|0;g=(h+(u>>>13)|0)+(Zi>>>26)|0,Zi&=67108863,d=Math.imul(kt,gt),u=Math.imul(kt,yt),u=u+Math.imul(Nt,gt)|0,h=Math.imul(Nt,yt),d=d+Math.imul(it,pt)|0,u=u+Math.imul(it,Zt)|0,u=u+Math.imul(ut,pt)|0,h=h+Math.imul(ut,Zt)|0,d=d+Math.imul(C,Xt)|0,u=u+Math.imul(C,Jt)|0,u=u+Math.imul(K,Xt)|0,h=h+Math.imul(K,Jt)|0;var Xi=(g+d|0)+((u&8191)<<13)|0;g=(h+(u>>>13)|0)+(Xi>>>26)|0,Xi&=67108863,d=Math.imul(Ct,gt),u=Math.imul(Ct,yt),u=u+Math.imul(qt,gt)|0,h=Math.imul(qt,yt),d=d+Math.imul(kt,pt)|0,u=u+Math.imul(kt,Zt)|0,u=u+Math.imul(Nt,pt)|0,h=h+Math.imul(Nt,Zt)|0,d=d+Math.imul(it,Xt)|0,u=u+Math.imul(it,Jt)|0,u=u+Math.imul(ut,Xt)|0,h=h+Math.imul(ut,Jt)|0,d=d+Math.imul(C,Qt)|0,u=u+Math.imul(C,te)|0,u=u+Math.imul(K,Qt)|0,h=h+Math.imul(K,te)|0;var Ji=(g+d|0)+((u&8191)<<13)|0;g=(h+(u>>>13)|0)+(Ji>>>26)|0,Ji&=67108863,d=Math.imul(Ut,gt),u=Math.imul(Ut,yt),u=u+Math.imul($t,gt)|0,h=Math.imul($t,yt),d=d+Math.imul(Ct,pt)|0,u=u+Math.imul(Ct,Zt)|0,u=u+Math.imul(qt,pt)|0,h=h+Math.imul(qt,Zt)|0,d=d+Math.imul(kt,Xt)|0,u=u+Math.imul(kt,Jt)|0,u=u+Math.imul(Nt,Xt)|0,h=h+Math.imul(Nt,Jt)|0,d=d+Math.imul(it,Qt)|0,u=u+Math.imul(it,te)|0,u=u+Math.imul(ut,Qt)|0,h=h+Math.imul(ut,te)|0,d=d+Math.imul(C,ee)|0,u=u+Math.imul(C,re)|0,u=u+Math.imul(K,ee)|0,h=h+Math.imul(K,re)|0;var Qi=(g+d|0)+((u&8191)<<13)|0;g=(h+(u>>>13)|0)+(Qi>>>26)|0,Qi&=67108863,d=Math.imul(Ft,gt),u=Math.imul(Ft,yt),u=u+Math.imul(Lt,gt)|0,h=Math.imul(Lt,yt),d=d+Math.imul(Ut,pt)|0,u=u+Math.imul(Ut,Zt)|0,u=u+Math.imul($t,pt)|0,h=h+Math.imul($t,Zt)|0,d=d+Math.imul(Ct,Xt)|0,u=u+Math.imul(Ct,Jt)|0,u=u+Math.imul(qt,Xt)|0,h=h+Math.imul(qt,Jt)|0,d=d+Math.imul(kt,Qt)|0,u=u+Math.imul(kt,te)|0,u=u+Math.imul(Nt,Qt)|0,h=h+Math.imul(Nt,te)|0,d=d+Math.imul(it,ee)|0,u=u+Math.imul(it,re)|0,u=u+Math.imul(ut,ee)|0,h=h+Math.imul(ut,re)|0,d=d+Math.imul(C,ne)|0,u=u+Math.imul(C,ie)|0,u=u+Math.imul(K,ne)|0,h=h+Math.imul(K,ie)|0;var ts=(g+d|0)+((u&8191)<<13)|0;g=(h+(u>>>13)|0)+(ts>>>26)|0,ts&=67108863,d=Math.imul(Dt,gt),u=Math.imul(Dt,yt),u=u+Math.imul(Vt,gt)|0,h=Math.imul(Vt,yt),d=d+Math.imul(Ft,pt)|0,u=u+Math.imul(Ft,Zt)|0,u=u+Math.imul(Lt,pt)|0,h=h+Math.imul(Lt,Zt)|0,d=d+Math.imul(Ut,Xt)|0,u=u+Math.imul(Ut,Jt)|0,u=u+Math.imul($t,Xt)|0,h=h+Math.imul($t,Jt)|0,d=d+Math.imul(Ct,Qt)|0,u=u+Math.imul(Ct,te)|0,u=u+Math.imul(qt,Qt)|0,h=h+Math.imul(qt,te)|0,d=d+Math.imul(kt,ee)|0,u=u+Math.imul(kt,re)|0,u=u+Math.imul(Nt,ee)|0,h=h+Math.imul(Nt,re)|0,d=d+Math.imul(it,ne)|0,u=u+Math.imul(it,ie)|0,u=u+Math.imul(ut,ne)|0,h=h+Math.imul(ut,ie)|0,d=d+Math.imul(C,se)|0,u=u+Math.imul(C,oe)|0,u=u+Math.imul(K,se)|0,h=h+Math.imul(K,oe)|0;var es=(g+d|0)+((u&8191)<<13)|0;g=(h+(u>>>13)|0)+(es>>>26)|0,es&=67108863,d=Math.imul(Wt,gt),u=Math.imul(Wt,yt),u=u+Math.imul(k,gt)|0,h=Math.imul(k,yt),d=d+Math.imul(Dt,pt)|0,u=u+Math.imul(Dt,Zt)|0,u=u+Math.imul(Vt,pt)|0,h=h+Math.imul(Vt,Zt)|0,d=d+Math.imul(Ft,Xt)|0,u=u+Math.imul(Ft,Jt)|0,u=u+Math.imul(Lt,Xt)|0,h=h+Math.imul(Lt,Jt)|0,d=d+Math.imul(Ut,Qt)|0,u=u+Math.imul(Ut,te)|0,u=u+Math.imul($t,Qt)|0,h=h+Math.imul($t,te)|0,d=d+Math.imul(Ct,ee)|0,u=u+Math.imul(Ct,re)|0,u=u+Math.imul(qt,ee)|0,h=h+Math.imul(qt,re)|0,d=d+Math.imul(kt,ne)|0,u=u+Math.imul(kt,ie)|0,u=u+Math.imul(Nt,ne)|0,h=h+Math.imul(Nt,ie)|0,d=d+Math.imul(it,se)|0,u=u+Math.imul(it,oe)|0,u=u+Math.imul(ut,se)|0,h=h+Math.imul(ut,oe)|0,d=d+Math.imul(C,ae)|0,u=u+Math.imul(C,ce)|0,u=u+Math.imul(K,ae)|0,h=h+Math.imul(K,ce)|0;var rs=(g+d|0)+((u&8191)<<13)|0;g=(h+(u>>>13)|0)+(rs>>>26)|0,rs&=67108863,d=Math.imul(w,gt),u=Math.imul(w,yt),u=u+Math.imul(B,gt)|0,h=Math.imul(B,yt),d=d+Math.imul(Wt,pt)|0,u=u+Math.imul(Wt,Zt)|0,u=u+Math.imul(k,pt)|0,h=h+Math.imul(k,Zt)|0,d=d+Math.imul(Dt,Xt)|0,u=u+Math.imul(Dt,Jt)|0,u=u+Math.imul(Vt,Xt)|0,h=h+Math.imul(Vt,Jt)|0,d=d+Math.imul(Ft,Qt)|0,u=u+Math.imul(Ft,te)|0,u=u+Math.imul(Lt,Qt)|0,h=h+Math.imul(Lt,te)|0,d=d+Math.imul(Ut,ee)|0,u=u+Math.imul(Ut,re)|0,u=u+Math.imul($t,ee)|0,h=h+Math.imul($t,re)|0,d=d+Math.imul(Ct,ne)|0,u=u+Math.imul(Ct,ie)|0,u=u+Math.imul(qt,ne)|0,h=h+Math.imul(qt,ie)|0,d=d+Math.imul(kt,se)|0,u=u+Math.imul(kt,oe)|0,u=u+Math.imul(Nt,se)|0,h=h+Math.imul(Nt,oe)|0,d=d+Math.imul(it,ae)|0,u=u+Math.imul(it,ce)|0,u=u+Math.imul(ut,ae)|0,h=h+Math.imul(ut,ce)|0,d=d+Math.imul(C,ue)|0,u=u+Math.imul(C,le)|0,u=u+Math.imul(K,ue)|0,h=h+Math.imul(K,le)|0;var ns=(g+d|0)+((u&8191)<<13)|0;g=(h+(u>>>13)|0)+(ns>>>26)|0,ns&=67108863,d=Math.imul(V,gt),u=Math.imul(V,yt),u=u+Math.imul(X,gt)|0,h=Math.imul(X,yt),d=d+Math.imul(w,pt)|0,u=u+Math.imul(w,Zt)|0,u=u+Math.imul(B,pt)|0,h=h+Math.imul(B,Zt)|0,d=d+Math.imul(Wt,Xt)|0,u=u+Math.imul(Wt,Jt)|0,u=u+Math.imul(k,Xt)|0,h=h+Math.imul(k,Jt)|0,d=d+Math.imul(Dt,Qt)|0,u=u+Math.imul(Dt,te)|0,u=u+Math.imul(Vt,Qt)|0,h=h+Math.imul(Vt,te)|0,d=d+Math.imul(Ft,ee)|0,u=u+Math.imul(Ft,re)|0,u=u+Math.imul(Lt,ee)|0,h=h+Math.imul(Lt,re)|0,d=d+Math.imul(Ut,ne)|0,u=u+Math.imul(Ut,ie)|0,u=u+Math.imul($t,ne)|0,h=h+Math.imul($t,ie)|0,d=d+Math.imul(Ct,se)|0,u=u+Math.imul(Ct,oe)|0,u=u+Math.imul(qt,se)|0,h=h+Math.imul(qt,oe)|0,d=d+Math.imul(kt,ae)|0,u=u+Math.imul(kt,ce)|0,u=u+Math.imul(Nt,ae)|0,h=h+Math.imul(Nt,ce)|0,d=d+Math.imul(it,ue)|0,u=u+Math.imul(it,le)|0,u=u+Math.imul(ut,ue)|0,h=h+Math.imul(ut,le)|0,d=d+Math.imul(C,he)|0,u=u+Math.imul(C,fe)|0,u=u+Math.imul(K,he)|0,h=h+Math.imul(K,fe)|0;var is=(g+d|0)+((u&8191)<<13)|0;g=(h+(u>>>13)|0)+(is>>>26)|0,is&=67108863,d=Math.imul(V,pt),u=Math.imul(V,Zt),u=u+Math.imul(X,pt)|0,h=Math.imul(X,Zt),d=d+Math.imul(w,Xt)|0,u=u+Math.imul(w,Jt)|0,u=u+Math.imul(B,Xt)|0,h=h+Math.imul(B,Jt)|0,d=d+Math.imul(Wt,Qt)|0,u=u+Math.imul(Wt,te)|0,u=u+Math.imul(k,Qt)|0,h=h+Math.imul(k,te)|0,d=d+Math.imul(Dt,ee)|0,u=u+Math.imul(Dt,re)|0,u=u+Math.imul(Vt,ee)|0,h=h+Math.imul(Vt,re)|0,d=d+Math.imul(Ft,ne)|0,u=u+Math.imul(Ft,ie)|0,u=u+Math.imul(Lt,ne)|0,h=h+Math.imul(Lt,ie)|0,d=d+Math.imul(Ut,se)|0,u=u+Math.imul(Ut,oe)|0,u=u+Math.imul($t,se)|0,h=h+Math.imul($t,oe)|0,d=d+Math.imul(Ct,ae)|0,u=u+Math.imul(Ct,ce)|0,u=u+Math.imul(qt,ae)|0,h=h+Math.imul(qt,ce)|0,d=d+Math.imul(kt,ue)|0,u=u+Math.imul(kt,le)|0,u=u+Math.imul(Nt,ue)|0,h=h+Math.imul(Nt,le)|0,d=d+Math.imul(it,he)|0,u=u+Math.imul(it,fe)|0,u=u+Math.imul(ut,he)|0,h=h+Math.imul(ut,fe)|0;var ss=(g+d|0)+((u&8191)<<13)|0;g=(h+(u>>>13)|0)+(ss>>>26)|0,ss&=67108863,d=Math.imul(V,Xt),u=Math.imul(V,Jt),u=u+Math.imul(X,Xt)|0,h=Math.imul(X,Jt),d=d+Math.imul(w,Qt)|0,u=u+Math.imul(w,te)|0,u=u+Math.imul(B,Qt)|0,h=h+Math.imul(B,te)|0,d=d+Math.imul(Wt,ee)|0,u=u+Math.imul(Wt,re)|0,u=u+Math.imul(k,ee)|0,h=h+Math.imul(k,re)|0,d=d+Math.imul(Dt,ne)|0,u=u+Math.imul(Dt,ie)|0,u=u+Math.imul(Vt,ne)|0,h=h+Math.imul(Vt,ie)|0,d=d+Math.imul(Ft,se)|0,u=u+Math.imul(Ft,oe)|0,u=u+Math.imul(Lt,se)|0,h=h+Math.imul(Lt,oe)|0,d=d+Math.imul(Ut,ae)|0,u=u+Math.imul(Ut,ce)|0,u=u+Math.imul($t,ae)|0,h=h+Math.imul($t,ce)|0,d=d+Math.imul(Ct,ue)|0,u=u+Math.imul(Ct,le)|0,u=u+Math.imul(qt,ue)|0,h=h+Math.imul(qt,le)|0,d=d+Math.imul(kt,he)|0,u=u+Math.imul(kt,fe)|0,u=u+Math.imul(Nt,he)|0,h=h+Math.imul(Nt,fe)|0;var os=(g+d|0)+((u&8191)<<13)|0;g=(h+(u>>>13)|0)+(os>>>26)|0,os&=67108863,d=Math.imul(V,Qt),u=Math.imul(V,te),u=u+Math.imul(X,Qt)|0,h=Math.imul(X,te),d=d+Math.imul(w,ee)|0,u=u+Math.imul(w,re)|0,u=u+Math.imul(B,ee)|0,h=h+Math.imul(B,re)|0,d=d+Math.imul(Wt,ne)|0,u=u+Math.imul(Wt,ie)|0,u=u+Math.imul(k,ne)|0,h=h+Math.imul(k,ie)|0,d=d+Math.imul(Dt,se)|0,u=u+Math.imul(Dt,oe)|0,u=u+Math.imul(Vt,se)|0,h=h+Math.imul(Vt,oe)|0,d=d+Math.imul(Ft,ae)|0,u=u+Math.imul(Ft,ce)|0,u=u+Math.imul(Lt,ae)|0,h=h+Math.imul(Lt,ce)|0,d=d+Math.imul(Ut,ue)|0,u=u+Math.imul(Ut,le)|0,u=u+Math.imul($t,ue)|0,h=h+Math.imul($t,le)|0,d=d+Math.imul(Ct,he)|0,u=u+Math.imul(Ct,fe)|0,u=u+Math.imul(qt,he)|0,h=h+Math.imul(qt,fe)|0;var as=(g+d|0)+((u&8191)<<13)|0;g=(h+(u>>>13)|0)+(as>>>26)|0,as&=67108863,d=Math.imul(V,ee),u=Math.imul(V,re),u=u+Math.imul(X,ee)|0,h=Math.imul(X,re),d=d+Math.imul(w,ne)|0,u=u+Math.imul(w,ie)|0,u=u+Math.imul(B,ne)|0,h=h+Math.imul(B,ie)|0,d=d+Math.imul(Wt,se)|0,u=u+Math.imul(Wt,oe)|0,u=u+Math.imul(k,se)|0,h=h+Math.imul(k,oe)|0,d=d+Math.imul(Dt,ae)|0,u=u+Math.imul(Dt,ce)|0,u=u+Math.imul(Vt,ae)|0,h=h+Math.imul(Vt,ce)|0,d=d+Math.imul(Ft,ue)|0,u=u+Math.imul(Ft,le)|0,u=u+Math.imul(Lt,ue)|0,h=h+Math.imul(Lt,le)|0,d=d+Math.imul(Ut,he)|0,u=u+Math.imul(Ut,fe)|0,u=u+Math.imul($t,he)|0,h=h+Math.imul($t,fe)|0;var cs=(g+d|0)+((u&8191)<<13)|0;g=(h+(u>>>13)|0)+(cs>>>26)|0,cs&=67108863,d=Math.imul(V,ne),u=Math.imul(V,ie),u=u+Math.imul(X,ne)|0,h=Math.imul(X,ie),d=d+Math.imul(w,se)|0,u=u+Math.imul(w,oe)|0,u=u+Math.imul(B,se)|0,h=h+Math.imul(B,oe)|0,d=d+Math.imul(Wt,ae)|0,u=u+Math.imul(Wt,ce)|0,u=u+Math.imul(k,ae)|0,h=h+Math.imul(k,ce)|0,d=d+Math.imul(Dt,ue)|0,u=u+Math.imul(Dt,le)|0,u=u+Math.imul(Vt,ue)|0,h=h+Math.imul(Vt,le)|0,d=d+Math.imul(Ft,he)|0,u=u+Math.imul(Ft,fe)|0,u=u+Math.imul(Lt,he)|0,h=h+Math.imul(Lt,fe)|0;var us=(g+d|0)+((u&8191)<<13)|0;g=(h+(u>>>13)|0)+(us>>>26)|0,us&=67108863,d=Math.imul(V,se),u=Math.imul(V,oe),u=u+Math.imul(X,se)|0,h=Math.imul(X,oe),d=d+Math.imul(w,ae)|0,u=u+Math.imul(w,ce)|0,u=u+Math.imul(B,ae)|0,h=h+Math.imul(B,ce)|0,d=d+Math.imul(Wt,ue)|0,u=u+Math.imul(Wt,le)|0,u=u+Math.imul(k,ue)|0,h=h+Math.imul(k,le)|0,d=d+Math.imul(Dt,he)|0,u=u+Math.imul(Dt,fe)|0,u=u+Math.imul(Vt,he)|0,h=h+Math.imul(Vt,fe)|0;var ls=(g+d|0)+((u&8191)<<13)|0;g=(h+(u>>>13)|0)+(ls>>>26)|0,ls&=67108863,d=Math.imul(V,ae),u=Math.imul(V,ce),u=u+Math.imul(X,ae)|0,h=Math.imul(X,ce),d=d+Math.imul(w,ue)|0,u=u+Math.imul(w,le)|0,u=u+Math.imul(B,ue)|0,h=h+Math.imul(B,le)|0,d=d+Math.imul(Wt,he)|0,u=u+Math.imul(Wt,fe)|0,u=u+Math.imul(k,he)|0,h=h+Math.imul(k,fe)|0;var hs=(g+d|0)+((u&8191)<<13)|0;g=(h+(u>>>13)|0)+(hs>>>26)|0,hs&=67108863,d=Math.imul(V,ue),u=Math.imul(V,le),u=u+Math.imul(X,ue)|0,h=Math.imul(X,le),d=d+Math.imul(w,he)|0,u=u+Math.imul(w,fe)|0,u=u+Math.imul(B,he)|0,h=h+Math.imul(B,fe)|0;var fs=(g+d|0)+((u&8191)<<13)|0;g=(h+(u>>>13)|0)+(fs>>>26)|0,fs&=67108863,d=Math.imul(V,he),u=Math.imul(V,fe),u=u+Math.imul(X,he)|0,h=Math.imul(X,fe);var ds=(g+d|0)+((u&8191)<<13)|0;return g=(h+(u>>>13)|0)+(ds>>>26)|0,ds&=67108863,A[0]=Yi,A[1]=Zi,A[2]=Xi,A[3]=Ji,A[4]=Qi,A[5]=ts,A[6]=es,A[7]=rs,A[8]=ns,A[9]=is,A[10]=ss,A[11]=os,A[12]=as,A[13]=cs,A[14]=us,A[15]=ls,A[16]=hs,A[17]=fs,A[18]=ds,g!==0&&(A[19]=g,E.length++),E};Math.imul||(H=M);function P(b,c,f){f.negative=c.negative^b.negative,f.length=b.length+c.length;for(var E=0,T=0,N=0;N<f.length-1;N++){var A=T;T=0;for(var g=E&67108863,d=Math.min(N,c.length-1),u=Math.max(0,N-b.length+1);u<=d;u++){var h=N-u,v=b.words[h]|0,C=c.words[u]|0,K=v*C,Z=K&67108863;A=A+(K/67108864|0)|0,Z=Z+g|0,g=Z&67108863,A=A+(Z>>>26)|0,T+=A>>>26,A&=67108863}f.words[N]=g,E=A,A=T}return E!==0?f.words[N]=E:f.length--,f._strip()}function q(b,c,f){return P(b,c,f)}i.prototype.mulTo=function(c,f){var E,T=this.length+c.length;return this.length===10&&c.length===10?E=H(this,c,f):T<63?E=M(this,c,f):T<1024?E=P(this,c,f):E=q(this,c,f),E},i.prototype.mul=function(c){var f=new i(null);return f.words=new Array(this.length+c.length),this.mulTo(c,f)},i.prototype.mulf=function(c){var f=new i(null);return f.words=new Array(this.length+c.length),q(this,c,f)},i.prototype.imul=function(c){return this.clone().mulTo(c,this)},i.prototype.imuln=function(c){var f=c<0;f&&(c=-c),r(typeof c=="number"),r(c<67108864);for(var E=0,T=0;T<this.length;T++){var N=(this.words[T]|0)*c,A=(N&67108863)+(E&67108863);E>>=26,E+=N/67108864|0,E+=A>>>26,this.words[T]=A&67108863}return E!==0&&(this.words[T]=E,this.length++),this.length=c===0?1:this.length,f?this.ineg():this},i.prototype.muln=function(c){return this.clone().imuln(c)},i.prototype.sqr=function(){return this.mul(this)},i.prototype.isqr=function(){return this.imul(this.clone())},i.prototype.pow=function(c){var f=x(c);if(f.length===0)return new i(1);for(var E=this,T=0;T<f.length&&f[T]===0;T++,E=E.sqr());if(++T<f.length)for(var N=E.sqr();T<f.length;T++,N=N.sqr())f[T]!==0&&(E=E.mul(N));return E},i.prototype.iushln=function(c){r(typeof c=="number"&&c>=0);var f=c%26,E=(c-f)/26,T=67108863>>>26-f<<26-f,N;if(f!==0){var A=0;for(N=0;N<this.length;N++){var g=this.words[N]&T,d=(this.words[N]|0)-g<<f;this.words[N]=d|A,A=g>>>26-f}A&&(this.words[N]=A,this.length++)}if(E!==0){for(N=this.length-1;N>=0;N--)this.words[N+E]=this.words[N];for(N=0;N<E;N++)this.words[N]=0;this.length+=E}return this._strip()},i.prototype.ishln=function(c){return r(this.negative===0),this.iushln(c)},i.prototype.iushrn=function(c,f,E){r(typeof c=="number"&&c>=0);var T;f?T=(f-f%26)/26:T=0;var N=c%26,A=Math.min((c-N)/26,this.length),g=67108863^67108863>>>N<<N,d=E;if(T-=A,T=Math.max(0,T),d){for(var u=0;u<A;u++)d.words[u]=this.words[u];d.length=A}if(A!==0)if(this.length>A)for(this.length-=A,u=0;u<this.length;u++)this.words[u]=this.words[u+A];else this.words[0]=0,this.length=1;var h=0;for(u=this.length-1;u>=0&&(h!==0||u>=T);u--){var v=this.words[u]|0;this.words[u]=h<<26-N|v>>>N,h=v&g}return d&&h!==0&&(d.words[d.length++]=h),this.length===0&&(this.words[0]=0,this.length=1),this._strip()},i.prototype.ishrn=function(c,f,E){return r(this.negative===0),this.iushrn(c,f,E)},i.prototype.shln=function(c){return this.clone().ishln(c)},i.prototype.ushln=function(c){return this.clone().iushln(c)},i.prototype.shrn=function(c){return this.clone().ishrn(c)},i.prototype.ushrn=function(c){return this.clone().iushrn(c)},i.prototype.testn=function(c){r(typeof c=="number"&&c>=0);var f=c%26,E=(c-f)/26,T=1<<f;if(this.length<=E)return!1;var N=this.words[E];return!!(N&T)},i.prototype.imaskn=function(c){r(typeof c=="number"&&c>=0);var f=c%26,E=(c-f)/26;if(r(this.negative===0,"imaskn works only with positive numbers"),this.length<=E)return this;if(f!==0&&E++,this.length=Math.min(E,this.length),f!==0){var T=67108863^67108863>>>f<<f;this.words[this.length-1]&=T}return this._strip()},i.prototype.maskn=function(c){return this.clone().imaskn(c)},i.prototype.iaddn=function(c){return r(typeof c=="number"),r(c<67108864),c<0?this.isubn(-c):this.negative!==0?this.length===1&&(this.words[0]|0)<=c?(this.words[0]=c-(this.words[0]|0),this.negative=0,this):(this.negative=0,this.isubn(c),this.negative=1,this):this._iaddn(c)},i.prototype._iaddn=function(c){this.words[0]+=c;for(var f=0;f<this.length&&this.words[f]>=67108864;f++)this.words[f]-=67108864,f===this.length-1?this.words[f+1]=1:this.words[f+1]++;return this.length=Math.max(this.length,f+1),this},i.prototype.isubn=function(c){if(r(typeof c=="number"),r(c<67108864),c<0)return this.iaddn(-c);if(this.negative!==0)return this.negative=0,this.iaddn(c),this.negative=1,this;if(this.words[0]-=c,this.length===1&&this.words[0]<0)this.words[0]=-this.words[0],this.negative=1;else for(var f=0;f<this.length&&this.words[f]<0;f++)this.words[f]+=67108864,this.words[f+1]-=1;return this._strip()},i.prototype.addn=function(c){return this.clone().iaddn(c)},i.prototype.subn=function(c){return this.clone().isubn(c)},i.prototype.iabs=function(){return this.negative=0,this},i.prototype.abs=function(){return this.clone().iabs()},i.prototype._ishlnsubmul=function(c,f,E){var T=c.length+E,N;this._expand(T);var A,g=0;for(N=0;N<c.length;N++){A=(this.words[N+E]|0)+g;var d=(c.words[N]|0)*f;A-=d&67108863,g=(A>>26)-(d/67108864|0),this.words[N+E]=A&67108863}for(;N<this.length-E;N++)A=(this.words[N+E]|0)+g,g=A>>26,this.words[N+E]=A&67108863;if(g===0)return this._strip();for(r(g===-1),g=0,N=0;N<this.length;N++)A=-(this.words[N]|0)+g,g=A>>26,this.words[N]=A&67108863;return this.negative=1,this._strip()},i.prototype._wordDiv=function(c,f){var E=this.length-c.length,T=this.clone(),N=c,A=N.words[N.length-1]|0,g=this._countBits(A);E=26-g,E!==0&&(N=N.ushln(E),T.iushln(E),A=N.words[N.length-1]|0);var d=T.length-N.length,u;if(f!=="mod"){u=new i(null),u.length=d+1,u.words=new Array(u.length);for(var h=0;h<u.length;h++)u.words[h]=0}var v=T.clone()._ishlnsubmul(N,1,d);v.negative===0&&(T=v,u&&(u.words[d]=1));for(var C=d-1;C>=0;C--){var K=(T.words[N.length+C]|0)*67108864+(T.words[N.length+C-1]|0);for(K=Math.min(K/A|0,67108863),T._ishlnsubmul(N,K,C);T.negative!==0;)K--,T.negative=0,T._ishlnsubmul(N,1,C),T.isZero()||(T.negative^=1);u&&(u.words[C]=K)}return u&&u._strip(),T._strip(),f!=="div"&&E!==0&&T.iushrn(E),{div:u||null,mod:T}},i.prototype.divmod=function(c,f,E){if(r(!c.isZero()),this.isZero())return{div:new i(0),mod:new i(0)};var T,N,A;return this.negative!==0&&c.negative===0?(A=this.neg().divmod(c,f),f!=="mod"&&(T=A.div.neg()),f!=="div"&&(N=A.mod.neg(),E&&N.negative!==0&&N.iadd(c)),{div:T,mod:N}):this.negative===0&&c.negative!==0?(A=this.divmod(c.neg(),f),f!=="mod"&&(T=A.div.neg()),{div:T,mod:A.mod}):(this.negative&c.negative)!==0?(A=this.neg().divmod(c.neg(),f),f!=="div"&&(N=A.mod.neg(),E&&N.negative!==0&&N.isub(c)),{div:A.div,mod:N}):c.length>this.length||this.cmp(c)<0?{div:new i(0),mod:this}:c.length===1?f==="div"?{div:this.divn(c.words[0]),mod:null}:f==="mod"?{div:null,mod:new i(this.modrn(c.words[0]))}:{div:this.divn(c.words[0]),mod:new i(this.modrn(c.words[0]))}:this._wordDiv(c,f)},i.prototype.div=function(c){return this.divmod(c,"div",!1).div},i.prototype.mod=function(c){return this.divmod(c,"mod",!1).mod},i.prototype.umod=function(c){return this.divmod(c,"mod",!0).mod},i.prototype.divRound=function(c){var f=this.divmod(c);if(f.mod.isZero())return f.div;var E=f.div.negative!==0?f.mod.isub(c):f.mod,T=c.ushrn(1),N=c.andln(1),A=E.cmp(T);return A<0||N===1&&A===0?f.div:f.div.negative!==0?f.div.isubn(1):f.div.iaddn(1)},i.prototype.modrn=function(c){var f=c<0;f&&(c=-c),r(c<=67108863);for(var E=(1<<26)%c,T=0,N=this.length-1;N>=0;N--)T=(E*T+(this.words[N]|0))%c;return f?-T:T},i.prototype.modn=function(c){return this.modrn(c)},i.prototype.idivn=function(c){var f=c<0;f&&(c=-c),r(c<=67108863);for(var E=0,T=this.length-1;T>=0;T--){var N=(this.words[T]|0)+E*67108864;this.words[T]=N/c|0,E=N%c}return this._strip(),f?this.ineg():this},i.prototype.divn=function(c){return this.clone().idivn(c)},i.prototype.egcd=function(c){r(c.negative===0),r(!c.isZero());var f=this,E=c.clone();f.negative!==0?f=f.umod(c):f=f.clone();for(var T=new i(1),N=new i(0),A=new i(0),g=new i(1),d=0;f.isEven()&&E.isEven();)f.iushrn(1),E.iushrn(1),++d;for(var u=E.clone(),h=f.clone();!f.isZero();){for(var v=0,C=1;(f.words[0]&C)===0&&v<26;++v,C<<=1);if(v>0)for(f.iushrn(v);v-- >0;)(T.isOdd()||N.isOdd())&&(T.iadd(u),N.isub(h)),T.iushrn(1),N.iushrn(1);for(var K=0,Z=1;(E.words[0]&Z)===0&&K<26;++K,Z<<=1);if(K>0)for(E.iushrn(K);K-- >0;)(A.isOdd()||g.isOdd())&&(A.iadd(u),g.isub(h)),A.iushrn(1),g.iushrn(1);f.cmp(E)>=0?(f.isub(E),T.isub(A),N.isub(g)):(E.isub(f),A.isub(T),g.isub(N))}return{a:A,b:g,gcd:E.iushln(d)}},i.prototype._invmp=function(c){r(c.negative===0),r(!c.isZero());var f=this,E=c.clone();f.negative!==0?f=f.umod(c):f=f.clone();for(var T=new i(1),N=new i(0),A=E.clone();f.cmpn(1)>0&&E.cmpn(1)>0;){for(var g=0,d=1;(f.words[0]&d)===0&&g<26;++g,d<<=1);if(g>0)for(f.iushrn(g);g-- >0;)T.isOdd()&&T.iadd(A),T.iushrn(1);for(var u=0,h=1;(E.words[0]&h)===0&&u<26;++u,h<<=1);if(u>0)for(E.iushrn(u);u-- >0;)N.isOdd()&&N.iadd(A),N.iushrn(1);f.cmp(E)>=0?(f.isub(E),T.isub(N)):(E.isub(f),N.isub(T))}var v;return f.cmpn(1)===0?v=T:v=N,v.cmpn(0)<0&&v.iadd(c),v},i.prototype.gcd=function(c){if(this.isZero())return c.abs();if(c.isZero())return this.abs();var f=this.clone(),E=c.clone();f.negative=0,E.negative=0;for(var T=0;f.isEven()&&E.isEven();T++)f.iushrn(1),E.iushrn(1);do{for(;f.isEven();)f.iushrn(1);for(;E.isEven();)E.iushrn(1);var N=f.cmp(E);if(N<0){var A=f;f=E,E=A}else if(N===0||E.cmpn(1)===0)break;f.isub(E)}while(!0);return E.iushln(T)},i.prototype.invm=function(c){return this.egcd(c).a.umod(c)},i.prototype.isEven=function(){return(this.words[0]&1)===0},i.prototype.isOdd=function(){return(this.words[0]&1)===1},i.prototype.andln=function(c){return this.words[0]&c},i.prototype.bincn=function(c){r(typeof c=="number");var f=c%26,E=(c-f)/26,T=1<<f;if(this.length<=E)return this._expand(E+1),this.words[E]|=T,this;for(var N=T,A=E;N!==0&&A<this.length;A++){var g=this.words[A]|0;g+=N,N=g>>>26,g&=67108863,this.words[A]=g}return N!==0&&(this.words[A]=N,this.length++),this},i.prototype.isZero=function(){return this.length===1&&this.words[0]===0},i.prototype.cmpn=function(c){var f=c<0;if(this.negative!==0&&!f)return-1;if(this.negative===0&&f)return 1;this._strip();var E;if(this.length>1)E=1;else{f&&(c=-c),r(c<=67108863,"Number is too big");var T=this.words[0]|0;E=T===c?0:T<c?-1:1}return this.negative!==0?-E|0:E},i.prototype.cmp=function(c){if(this.negative!==0&&c.negative===0)return-1;if(this.negative===0&&c.negative!==0)return 1;var f=this.ucmp(c);return this.negative!==0?-f|0:f},i.prototype.ucmp=function(c){if(this.length>c.length)return 1;if(this.length<c.length)return-1;for(var f=0,E=this.length-1;E>=0;E--){var T=this.words[E]|0,N=c.words[E]|0;if(T!==N){T<N?f=-1:T>N&&(f=1);break}}return f},i.prototype.gtn=function(c){return this.cmpn(c)===1},i.prototype.gt=function(c){return this.cmp(c)===1},i.prototype.gten=function(c){return this.cmpn(c)>=0},i.prototype.gte=function(c){return this.cmp(c)>=0},i.prototype.ltn=function(c){return this.cmpn(c)===-1},i.prototype.lt=function(c){return this.cmp(c)===-1},i.prototype.lten=function(c){return this.cmpn(c)<=0},i.prototype.lte=function(c){return this.cmp(c)<=0},i.prototype.eqn=function(c){return this.cmpn(c)===0},i.prototype.eq=function(c){return this.cmp(c)===0},i.red=function(c){return new F(c)},i.prototype.toRed=function(c){return r(!this.red,"Already a number in reduction context"),r(this.negative===0,"red works only with positives"),c.convertTo(this)._forceRed(c)},i.prototype.fromRed=function(){return r(this.red,"fromRed works only with numbers in reduction context"),this.red.convertFrom(this)},i.prototype._forceRed=function(c){return this.red=c,this},i.prototype.forceRed=function(c){return r(!this.red,"Already a number in reduction context"),this._forceRed(c)},i.prototype.redAdd=function(c){return r(this.red,"redAdd works only with red numbers"),this.red.add(this,c)},i.prototype.redIAdd=function(c){return r(this.red,"redIAdd works only with red numbers"),this.red.iadd(this,c)},i.prototype.redSub=function(c){return r(this.red,"redSub works only with red numbers"),this.red.sub(this,c)},i.prototype.redISub=function(c){return r(this.red,"redISub works only with red numbers"),this.red.isub(this,c)},i.prototype.redShl=function(c){return r(this.red,"redShl works only with red numbers"),this.red.shl(this,c)},i.prototype.redMul=function(c){return r(this.red,"redMul works only with red numbers"),this.red._verify2(this,c),this.red.mul(this,c)},i.prototype.redIMul=function(c){return r(this.red,"redMul works only with red numbers"),this.red._verify2(this,c),this.red.imul(this,c)},i.prototype.redSqr=function(){return r(this.red,"redSqr works only with red numbers"),this.red._verify1(this),this.red.sqr(this)},i.prototype.redISqr=function(){return r(this.red,"redISqr works only with red numbers"),this.red._verify1(this),this.red.isqr(this)},i.prototype.redSqrt=function(){return r(this.red,"redSqrt works only with red numbers"),this.red._verify1(this),this.red.sqrt(this)},i.prototype.redInvm=function(){return r(this.red,"redInvm works only with red numbers"),this.red._verify1(this),this.red.invm(this)},i.prototype.redNeg=function(){return r(this.red,"redNeg works only with red numbers"),this.red._verify1(this),this.red.neg(this)},i.prototype.redPow=function(c){return r(this.red&&!c.red,"redPow(normalNum)"),this.red._verify1(this),this.red.pow(this,c)};var G={k256:null,p224:null,p192:null,p25519:null};function J(b,c){this.name=b,this.p=new i(c,16),this.n=this.p.bitLength(),this.k=new i(1).iushln(this.n).isub(this.p),this.tmp=this._tmp()}J.prototype._tmp=function(){var c=new i(null);return c.words=new Array(Math.ceil(this.n/13)),c},J.prototype.ireduce=function(c){var f=c,E;do this.split(f,this.tmp),f=this.imulK(f),f=f.iadd(this.tmp),E=f.bitLength();while(E>this.n);var T=E<this.n?-1:f.ucmp(this.p);return T===0?(f.words[0]=0,f.length=1):T>0?f.isub(this.p):f.strip!==void 0?f.strip():f._strip(),f},J.prototype.split=function(c,f){c.iushrn(this.n,0,f)},J.prototype.imulK=function(c){return c.imul(this.k)};function Q(){J.call(this,"k256","ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f")}s(Q,J),Q.prototype.split=function(c,f){for(var E=4194303,T=Math.min(c.length,9),N=0;N<T;N++)f.words[N]=c.words[N];if(f.length=T,c.length<=9){c.words[0]=0,c.length=1;return}var A=c.words[9];for(f.words[f.length++]=A&E,N=10;N<c.length;N++){var g=c.words[N]|0;c.words[N-10]=(g&E)<<4|A>>>22,A=g}A>>>=22,c.words[N-10]=A,A===0&&c.length>10?c.length-=10:c.length-=9},Q.prototype.imulK=function(c){c.words[c.length]=0,c.words[c.length+1]=0,c.length+=2;for(var f=0,E=0;E<c.length;E++){var T=c.words[E]|0;f+=T*977,c.words[E]=f&67108863,f=T*64+(f/67108864|0)}return c.words[c.length-1]===0&&(c.length--,c.words[c.length-1]===0&&c.length--),c};function tt(){J.call(this,"p224","ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001")}s(tt,J);function L(){J.call(this,"p192","ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff")}s(L,J);function U(){J.call(this,"25519","7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed")}s(U,J),U.prototype.imulK=function(c){for(var f=0,E=0;E<c.length;E++){var T=(c.words[E]|0)*19+f,N=T&67108863;T>>>=26,c.words[E]=N,f=T}return f!==0&&(c.words[c.length++]=f),c},i._prime=function(c){if(G[c])return G[c];var f;if(c==="k256")f=new Q;else if(c==="p224")f=new tt;else if(c==="p192")f=new L;else if(c==="p25519")f=new U;else throw new Error("Unknown prime "+c);return G[c]=f,f};function F(b){if(typeof b=="string"){var c=i._prime(b);this.m=c.p,this.prime=c}else r(b.gtn(1),"modulus must be greater than 1"),this.m=b,this.prime=null}F.prototype._verify1=function(c){r(c.negative===0,"red works only with positives"),r(c.red,"red works only with red numbers")},F.prototype._verify2=function(c,f){r((c.negative|f.negative)===0,"red works only with positives"),r(c.red&&c.red===f.red,"red works only with red numbers")},F.prototype.imod=function(c){return this.prime?this.prime.ireduce(c)._forceRed(this):(m(c,c.umod(this.m)._forceRed(this)),c)},F.prototype.neg=function(c){return c.isZero()?c.clone():this.m.sub(c)._forceRed(this)},F.prototype.add=function(c,f){this._verify2(c,f);var E=c.add(f);return E.cmp(this.m)>=0&&E.isub(this.m),E._forceRed(this)},F.prototype.iadd=function(c,f){this._verify2(c,f);var E=c.iadd(f);return E.cmp(this.m)>=0&&E.isub(this.m),E},F.prototype.sub=function(c,f){this._verify2(c,f);var E=c.sub(f);return E.cmpn(0)<0&&E.iadd(this.m),E._forceRed(this)},F.prototype.isub=function(c,f){this._verify2(c,f);var E=c.isub(f);return E.cmpn(0)<0&&E.iadd(this.m),E},F.prototype.shl=function(c,f){return this._verify1(c),this.imod(c.ushln(f))},F.prototype.imul=function(c,f){return this._verify2(c,f),this.imod(c.imul(f))},F.prototype.mul=function(c,f){return this._verify2(c,f),this.imod(c.mul(f))},F.prototype.isqr=function(c){return this.imul(c,c.clone())},F.prototype.sqr=function(c){return this.mul(c,c)},F.prototype.sqrt=function(c){if(c.isZero())return c.clone();var f=this.m.andln(3);if(r(f%2===1),f===3){var E=this.m.add(new i(1)).iushrn(2);return this.pow(c,E)}for(var T=this.m.subn(1),N=0;!T.isZero()&&T.andln(1)===0;)N++,T.iushrn(1);r(!T.isZero());var A=new i(1).toRed(this),g=A.redNeg(),d=this.m.subn(1).iushrn(1),u=this.m.bitLength();for(u=new i(2*u*u).toRed(this);this.pow(u,d).cmp(g)!==0;)u.redIAdd(g);for(var h=this.pow(u,T),v=this.pow(c,T.addn(1).iushrn(1)),C=this.pow(c,T),K=N;C.cmp(A)!==0;){for(var Z=C,it=0;Z.cmp(A)!==0;it++)Z=Z.redSqr();r(it<K);var ut=this.pow(h,new i(1).iushln(K-it-1));v=v.redMul(ut),h=ut.redSqr(),C=C.redMul(h),K=it}return v},F.prototype.invm=function(c){var f=c._invmp(this.m);return f.negative!==0?(f.negative=0,this.imod(f).redNeg()):this.imod(f)},F.prototype.pow=function(c,f){if(f.isZero())return new i(1).toRed(this);if(f.cmpn(1)===0)return c.clone();var E=4,T=new Array(1<<E);T[0]=new i(1).toRed(this),T[1]=c;for(var N=2;N<T.length;N++)T[N]=this.mul(T[N-1],c);var A=T[0],g=0,d=0,u=f.bitLength()%26;for(u===0&&(u=26),N=f.length-1;N>=0;N--){for(var h=f.words[N],v=u-1;v>=0;v--){var C=h>>v&1;if(A!==T[0]&&(A=this.sqr(A)),C===0&&g===0){d=0;continue}g<<=1,g|=C,d++,!(d!==E&&(N!==0||v!==0))&&(A=this.mul(A,T[g]),d=0,g=0)}u=26}return A},F.prototype.convertTo=function(c){var f=c.umod(this.m);return f===c?f.clone():f},F.prototype.convertFrom=function(c){var f=c.clone();return f.red=null,f},i.mont=function(c){return new z(c)};function z(b){F.call(this,b),this.shift=this.m.bitLength(),this.shift%26!==0&&(this.shift+=26-this.shift%26),this.r=new i(1).iushln(this.shift),this.r2=this.imod(this.r.sqr()),this.rinv=this.r._invmp(this.m),this.minv=this.rinv.mul(this.r).isubn(1).div(this.m),this.minv=this.minv.umod(this.r),this.minv=this.r.sub(this.minv)}s(z,F),z.prototype.convertTo=function(c){return this.imod(c.ushln(this.shift))},z.prototype.convertFrom=function(c){var f=this.imod(c.mul(this.rinv));return f.red=null,f},z.prototype.imul=function(c,f){if(c.isZero()||f.isZero())return c.words[0]=0,c.length=1,c;var E=c.imul(f),T=E.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),N=E.isub(T).iushrn(this.shift),A=N;return N.cmp(this.m)>=0?A=N.isub(this.m):N.cmpn(0)<0&&(A=N.iadd(this.m)),A._forceRed(this)},z.prototype.mul=function(c,f){if(c.isZero()||f.isZero())return new i(0)._forceRed(this);var E=c.mul(f),T=E.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),N=E.isub(T).iushrn(this.shift),A=N;return N.cmp(this.m)>=0?A=N.isub(this.m):N.cmpn(0)<0&&(A=N.iadd(this.m)),A._forceRed(this)},z.prototype.invm=function(c){var f=this.imod(c._invmp(this.m).mul(this.r2));return f._forceRed(this)}})(n,Fd)})(ai)),ai.exports}var zd=xo();const or=Fr(zd);var Zn={exports:{}};/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */var Na;function No(){return Na||(Na=1,(function(n,t){var e=Ro(),r=e.Buffer;function s(o,a){for(var l in o)a[l]=o[l]}r.from&&r.alloc&&r.allocUnsafe&&r.allocUnsafeSlow?n.exports=e:(s(e,t),t.Buffer=i);function i(o,a,l){return r(o,a,l)}i.prototype=Object.create(r.prototype),s(r,i),i.from=function(o,a,l){if(typeof o=="number")throw new TypeError("Argument must not be a number");return r(o,a,l)},i.alloc=function(o,a,l){if(typeof o!="number")throw new TypeError("Argument must be a number");var p=r(o);return a!==void 0?typeof l=="string"?p.fill(a,l):p.fill(a):p.fill(0),p},i.allocUnsafe=function(o){if(typeof o!="number")throw new TypeError("Argument must be a number");return r(o)},i.allocUnsafeSlow=function(o){if(typeof o!="number")throw new TypeError("Argument must be a number");return e.SlowBuffer(o)}})(Zn,Zn.exports)),Zn.exports}var Es,Ca;function Kd(){if(Ca)return Es;Ca=1;var n=No().Buffer;function t(e){if(e.length>=255)throw new TypeError("Alphabet too long");for(var r=new Uint8Array(256),s=0;s<r.length;s++)r[s]=255;for(var i=0;i<e.length;i++){var o=e.charAt(i),a=o.charCodeAt(0);if(r[a]!==255)throw new TypeError(o+" is ambiguous");r[a]=i}var l=e.length,p=e.charAt(0),m=Math.log(l)/Math.log(256),S=Math.log(256)/Math.log(l);function R(O){if((Array.isArray(O)||O instanceof Uint8Array)&&(O=n.from(O)),!n.isBuffer(O))throw new TypeError("Expected Buffer");if(O.length===0)return"";for(var x=0,M=0,H=0,P=O.length;H!==P&&O[H]===0;)H++,x++;for(var q=(P-H)*S+1>>>0,G=new Uint8Array(q);H!==P;){for(var J=O[H],Q=0,tt=q-1;(J!==0||Q<M)&&tt!==-1;tt--,Q++)J+=256*G[tt]>>>0,G[tt]=J%l>>>0,J=J/l>>>0;if(J!==0)throw new Error("Non-zero carry");M=Q,H++}for(var L=q-M;L!==q&&G[L]===0;)L++;for(var U=p.repeat(x);L<q;++L)U+=e.charAt(G[L]);return U}function _(O){if(typeof O!="string")throw new TypeError("Expected String");if(O.length===0)return n.alloc(0);for(var x=0,M=0,H=0;O[x]===p;)M++,x++;for(var P=(O.length-x)*m+1>>>0,q=new Uint8Array(P);x<O.length;){var G=O.charCodeAt(x);if(G>255)return;var J=r[G];if(J===255)return;for(var Q=0,tt=P-1;(J!==0||Q<H)&&tt!==-1;tt--,Q++)J+=l*q[tt]>>>0,q[tt]=J%256>>>0,J=J/256>>>0;if(J!==0)throw new Error("Non-zero carry");H=Q,x++}for(var L=P-H;L!==P&&q[L]===0;)L++;var U=n.allocUnsafe(M+(P-L));U.fill(0,0,M);for(var F=M;L!==P;)U[F++]=q[L++];return U}function I(O){var x=_(O);if(x)return x;throw new Error("Non-base"+l+" character")}return{encode:R,decodeUnsafe:_,decode:I}}return Es=t,Es}var Rs,Ba;function qd(){if(Ba)return Rs;Ba=1;var n=Kd(),t="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";return Rs=n(t),Rs}var $d=qd();const be=Fr($d),yi=cu;var Ot={},vs,Ma;function Vd(){if(Ma)return vs;Ma=1;var n=No().Buffer;function t(e){if(e.length>=255)throw new TypeError("Alphabet too long");for(var r=new Uint8Array(256),s=0;s<r.length;s++)r[s]=255;for(var i=0;i<e.length;i++){var o=e.charAt(i),a=o.charCodeAt(0);if(r[a]!==255)throw new TypeError(o+" is ambiguous");r[a]=i}var l=e.length,p=e.charAt(0),m=Math.log(l)/Math.log(256),S=Math.log(256)/Math.log(l);function R(O){if((Array.isArray(O)||O instanceof Uint8Array)&&(O=n.from(O)),!n.isBuffer(O))throw new TypeError("Expected Buffer");if(O.length===0)return"";for(var x=0,M=0,H=0,P=O.length;H!==P&&O[H]===0;)H++,x++;for(var q=(P-H)*S+1>>>0,G=new Uint8Array(q);H!==P;){for(var J=O[H],Q=0,tt=q-1;(J!==0||Q<M)&&tt!==-1;tt--,Q++)J+=256*G[tt]>>>0,G[tt]=J%l>>>0,J=J/l>>>0;if(J!==0)throw new Error("Non-zero carry");M=Q,H++}for(var L=q-M;L!==q&&G[L]===0;)L++;for(var U=p.repeat(x);L<q;++L)U+=e.charAt(G[L]);return U}function _(O){if(typeof O!="string")throw new TypeError("Expected String");if(O.length===0)return n.alloc(0);for(var x=0,M=0,H=0;O[x]===p;)M++,x++;for(var P=(O.length-x)*m+1>>>0,q=new Uint8Array(P);x<O.length;){var G=O.charCodeAt(x);if(G>255)return;var J=r[G];if(J===255)return;for(var Q=0,tt=P-1;(J!==0||Q<H)&&tt!==-1;tt--,Q++)J+=l*q[tt]>>>0,q[tt]=J%256>>>0,J=J/256>>>0;if(J!==0)throw new Error("Non-zero carry");H=Q,x++}for(var L=P-H;L!==P&&q[L]===0;)L++;var U=n.allocUnsafe(M+(P-L));U.fill(0,0,M);for(var F=M;L!==P;)U[F++]=q[L++];return U}function I(O){var x=_(O);if(x)return x;throw new Error("Non-base"+l+" character")}return{encode:R,decodeUnsafe:_,decode:I}}return vs=t,vs}var As,La;function Wd(){if(La)return As;La=1;var n=Vd(),t="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";return As=n(t),As}function ar(n,t,e){return t<=n&&n<=e}function Ni(n){if(n===void 0)return{};if(n===Object(n))return n;throw TypeError("Could not convert argument to dictionary")}function Gd(n){for(var t=String(n),e=t.length,r=0,s=[];r<e;){var i=t.charCodeAt(r);if(i<55296||i>57343)s.push(i);else if(56320<=i&&i<=57343)s.push(65533);else if(55296<=i&&i<=56319)if(r===e-1)s.push(65533);else{var o=n.charCodeAt(r+1);if(56320<=o&&o<=57343){var a=i&1023,l=o&1023;s.push(65536+(a<<10)+l),r+=1}else s.push(65533)}r+=1}return s}function jd(n){for(var t="",e=0;e<n.length;++e){var r=n[e];r<=65535?t+=String.fromCharCode(r):(r-=65536,t+=String.fromCharCode((r>>10)+55296,(r&1023)+56320))}return t}var gi=-1;function Co(n){this.tokens=[].slice.call(n)}Co.prototype={endOfStream:function(){return!this.tokens.length},read:function(){return this.tokens.length?this.tokens.shift():gi},prepend:function(n){if(Array.isArray(n))for(var t=n;t.length;)this.tokens.unshift(t.pop());else this.tokens.unshift(n)},push:function(n){if(Array.isArray(n))for(var t=n;t.length;)this.tokens.push(t.shift());else this.tokens.push(n)}};var cn=-1;function Is(n,t){if(n)throw TypeError("Decoder error");return t||65533}var mi="utf-8";function wi(n,t){if(!(this instanceof wi))return new wi(n,t);if(n=n!==void 0?String(n).toLowerCase():mi,n!==mi)throw new Error("Encoding not supported. Only utf-8 is supported");t=Ni(t),this._streaming=!1,this._BOMseen=!1,this._decoder=null,this._fatal=!!t.fatal,this._ignoreBOM=!!t.ignoreBOM,Object.defineProperty(this,"encoding",{value:"utf-8"}),Object.defineProperty(this,"fatal",{value:this._fatal}),Object.defineProperty(this,"ignoreBOM",{value:this._ignoreBOM})}wi.prototype={decode:function(t,e){var r;typeof t=="object"&&t instanceof ArrayBuffer?r=new Uint8Array(t):typeof t=="object"&&"buffer"in t&&t.buffer instanceof ArrayBuffer?r=new Uint8Array(t.buffer,t.byteOffset,t.byteLength):r=new Uint8Array(0),e=Ni(e),this._streaming||(this._decoder=new Yd({fatal:this._fatal}),this._BOMseen=!1),this._streaming=!!e.stream;for(var s=new Co(r),i=[],o;!s.endOfStream()&&(o=this._decoder.handler(s,s.read()),o!==cn);)o!==null&&(Array.isArray(o)?i.push.apply(i,o):i.push(o));if(!this._streaming){do{if(o=this._decoder.handler(s,s.read()),o===cn)break;o!==null&&(Array.isArray(o)?i.push.apply(i,o):i.push(o))}while(!s.endOfStream());this._decoder=null}return i.length&&["utf-8"].indexOf(this.encoding)!==-1&&!this._ignoreBOM&&!this._BOMseen&&(i[0]===65279?(this._BOMseen=!0,i.shift()):this._BOMseen=!0),jd(i)}};function _i(n,t){if(!(this instanceof _i))return new _i(n,t);if(n=n!==void 0?String(n).toLowerCase():mi,n!==mi)throw new Error("Encoding not supported. Only utf-8 is supported");t=Ni(t),this._streaming=!1,this._encoder=null,this._options={fatal:!!t.fatal},Object.defineProperty(this,"encoding",{value:"utf-8"})}_i.prototype={encode:function(t,e){t=t?String(t):"",e=Ni(e),this._streaming||(this._encoder=new Zd(this._options)),this._streaming=!!e.stream;for(var r=[],s=new Co(Gd(t)),i;!s.endOfStream()&&(i=this._encoder.handler(s,s.read()),i!==cn);)Array.isArray(i)?r.push.apply(r,i):r.push(i);if(!this._streaming){for(;i=this._encoder.handler(s,s.read()),i!==cn;)Array.isArray(i)?r.push.apply(r,i):r.push(i);this._encoder=null}return new Uint8Array(r)}};function Yd(n){var t=n.fatal,e=0,r=0,s=0,i=128,o=191;this.handler=function(a,l){if(l===gi&&s!==0)return s=0,Is(t);if(l===gi)return cn;if(s===0){if(ar(l,0,127))return l;if(ar(l,194,223))s=1,e=l-192;else if(ar(l,224,239))l===224&&(i=160),l===237&&(o=159),s=2,e=l-224;else if(ar(l,240,244))l===240&&(i=144),l===244&&(o=143),s=3,e=l-240;else return Is(t);return e=e<<6*s,null}if(!ar(l,i,o))return e=s=r=0,i=128,o=191,a.prepend(l),Is(t);if(i=128,o=191,r+=1,e+=l-128<<6*(s-r),r!==s)return null;var p=e;return e=s=r=0,p}}function Zd(n){n.fatal,this.handler=function(t,e){if(e===gi)return cn;if(ar(e,0,127))return e;var r,s;ar(e,128,2047)?(r=1,s=192):ar(e,2048,65535)?(r=2,s=224):ar(e,65536,1114111)&&(r=3,s=240);for(var i=[(e>>6*r)+s];r>0;){var o=e>>6*(r-1);i.push(128|o&63),r-=1}return i}}const Xd=Object.freeze({__proto__:null,TextDecoder:wi,TextEncoder:_i}),Jd=Ti(Xd);var Pa;function Qd(){if(Pa)return Ot;Pa=1;var n=Ot&&Ot.__createBinding||(Object.create?(function(L,U,F,z){z===void 0&&(z=F),Object.defineProperty(L,z,{enumerable:!0,get:function(){return U[F]}})}):(function(L,U,F,z){z===void 0&&(z=F),L[z]=U[F]})),t=Ot&&Ot.__setModuleDefault||(Object.create?(function(L,U){Object.defineProperty(L,"default",{enumerable:!0,value:U})}):function(L,U){L.default=U}),e=Ot&&Ot.__decorate||function(L,U,F,z){var b=arguments.length,c=b<3?U:z===null?z=Object.getOwnPropertyDescriptor(U,F):z,f;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")c=Reflect.decorate(L,U,F,z);else for(var E=L.length-1;E>=0;E--)(f=L[E])&&(c=(b<3?f(c):b>3?f(U,F,c):f(U,F))||c);return b>3&&c&&Object.defineProperty(U,F,c),c},r=Ot&&Ot.__importStar||function(L){if(L&&L.__esModule)return L;var U={};if(L!=null)for(var F in L)F!=="default"&&Object.hasOwnProperty.call(L,F)&&n(U,L,F);return t(U,L),U},s=Ot&&Ot.__importDefault||function(L){return L&&L.__esModule?L:{default:L}};Object.defineProperty(Ot,"__esModule",{value:!0}),Ot.deserializeUnchecked=Ot.deserialize=Ot.serialize=Ot.BinaryReader=Ot.BinaryWriter=Ot.BorshError=Ot.baseDecode=Ot.baseEncode=void 0;const i=s(xo()),o=s(Wd()),a=r(Jd),l=typeof TextDecoder!="function"?a.TextDecoder:TextDecoder,p=new l("utf-8",{fatal:!0});function m(L){return typeof L=="string"&&(L=Buffer.from(L,"utf8")),o.default.encode(Buffer.from(L))}Ot.baseEncode=m;function S(L){return Buffer.from(o.default.decode(L))}Ot.baseDecode=S;const R=1024;class _ extends Error{constructor(U){super(U),this.fieldPath=[],this.originalMessage=U}addToFieldPath(U){this.fieldPath.splice(0,0,U),this.message=this.originalMessage+": "+this.fieldPath.join(".")}}Ot.BorshError=_;class I{constructor(){this.buf=Buffer.alloc(R),this.length=0}maybeResize(){this.buf.length<16+this.length&&(this.buf=Buffer.concat([this.buf,Buffer.alloc(R)]))}writeU8(U){this.maybeResize(),this.buf.writeUInt8(U,this.length),this.length+=1}writeU16(U){this.maybeResize(),this.buf.writeUInt16LE(U,this.length),this.length+=2}writeU32(U){this.maybeResize(),this.buf.writeUInt32LE(U,this.length),this.length+=4}writeU64(U){this.maybeResize(),this.writeBuffer(Buffer.from(new i.default(U).toArray("le",8)))}writeU128(U){this.maybeResize(),this.writeBuffer(Buffer.from(new i.default(U).toArray("le",16)))}writeU256(U){this.maybeResize(),this.writeBuffer(Buffer.from(new i.default(U).toArray("le",32)))}writeU512(U){this.maybeResize(),this.writeBuffer(Buffer.from(new i.default(U).toArray("le",64)))}writeBuffer(U){this.buf=Buffer.concat([Buffer.from(this.buf.subarray(0,this.length)),U,Buffer.alloc(R)]),this.length+=U.length}writeString(U){this.maybeResize();const F=Buffer.from(U,"utf8");this.writeU32(F.length),this.writeBuffer(F)}writeFixedArray(U){this.writeBuffer(Buffer.from(U))}writeArray(U,F){this.maybeResize(),this.writeU32(U.length);for(const z of U)this.maybeResize(),F(z)}toArray(){return this.buf.subarray(0,this.length)}}Ot.BinaryWriter=I;function O(L,U,F){const z=F.value;F.value=function(...b){try{return z.apply(this,b)}catch(c){if(c instanceof RangeError){const f=c.code;if(["ERR_BUFFER_OUT_OF_BOUNDS","ERR_OUT_OF_RANGE"].indexOf(f)>=0)throw new _("Reached the end of buffer when deserializing")}throw c}}}class x{constructor(U){this.buf=U,this.offset=0}readU8(){const U=this.buf.readUInt8(this.offset);return this.offset+=1,U}readU16(){const U=this.buf.readUInt16LE(this.offset);return this.offset+=2,U}readU32(){const U=this.buf.readUInt32LE(this.offset);return this.offset+=4,U}readU64(){const U=this.readBuffer(8);return new i.default(U,"le")}readU128(){const U=this.readBuffer(16);return new i.default(U,"le")}readU256(){const U=this.readBuffer(32);return new i.default(U,"le")}readU512(){const U=this.readBuffer(64);return new i.default(U,"le")}readBuffer(U){if(this.offset+U>this.buf.length)throw new _(`Expected buffer length ${U} isn't within bounds`);const F=this.buf.slice(this.offset,this.offset+U);return this.offset+=U,F}readString(){const U=this.readU32(),F=this.readBuffer(U);try{return p.decode(F)}catch(z){throw new _(`Error decoding UTF-8 string: ${z}`)}}readFixedArray(U){return new Uint8Array(this.readBuffer(U))}readArray(U){const F=this.readU32(),z=Array();for(let b=0;b<F;++b)z.push(U());return z}}e([O],x.prototype,"readU8",null),e([O],x.prototype,"readU16",null),e([O],x.prototype,"readU32",null),e([O],x.prototype,"readU64",null),e([O],x.prototype,"readU128",null),e([O],x.prototype,"readU256",null),e([O],x.prototype,"readU512",null),e([O],x.prototype,"readString",null),e([O],x.prototype,"readFixedArray",null),e([O],x.prototype,"readArray",null),Ot.BinaryReader=x;function M(L){return L.charAt(0).toUpperCase()+L.slice(1)}function H(L,U,F,z,b){try{if(typeof z=="string")b[`write${M(z)}`](F);else if(z instanceof Array)if(typeof z[0]=="number"){if(F.length!==z[0])throw new _(`Expecting byte array of length ${z[0]}, but got ${F.length} bytes`);b.writeFixedArray(F)}else if(z.length===2&&typeof z[1]=="number"){if(F.length!==z[1])throw new _(`Expecting byte array of length ${z[1]}, but got ${F.length} bytes`);for(let c=0;c<z[1];c++)H(L,null,F[c],z[0],b)}else b.writeArray(F,c=>{H(L,U,c,z[0],b)});else if(z.kind!==void 0)switch(z.kind){case"option":{F==null?b.writeU8(0):(b.writeU8(1),H(L,U,F,z.type,b));break}case"map":{b.writeU32(F.size),F.forEach((c,f)=>{H(L,U,f,z.key,b),H(L,U,c,z.value,b)});break}default:throw new _(`FieldType ${z} unrecognized`)}else P(L,F,b)}catch(c){throw c instanceof _&&c.addToFieldPath(U),c}}function P(L,U,F){if(typeof U.borshSerialize=="function"){U.borshSerialize(F);return}const z=L.get(U.constructor);if(!z)throw new _(`Class ${U.constructor.name} is missing in schema`);if(z.kind==="struct")z.fields.map(([b,c])=>{H(L,b,U[b],c,F)});else if(z.kind==="enum"){const b=U[z.field];for(let c=0;c<z.values.length;++c){const[f,E]=z.values[c];if(f===b){F.writeU8(c),H(L,f,U[f],E,F);break}}}else throw new _(`Unexpected schema kind: ${z.kind} for ${U.constructor.name}`)}function q(L,U,F=I){const z=new F;return P(L,U,z),z.toArray()}Ot.serialize=q;function G(L,U,F,z){try{if(typeof F=="string")return z[`read${M(F)}`]();if(F instanceof Array){if(typeof F[0]=="number")return z.readFixedArray(F[0]);if(typeof F[1]=="number"){const b=[];for(let c=0;c<F[1];c++)b.push(G(L,null,F[0],z));return b}else return z.readArray(()=>G(L,U,F[0],z))}if(F.kind==="option")return z.readU8()?G(L,U,F.type,z):void 0;if(F.kind==="map"){let b=new Map;const c=z.readU32();for(let f=0;f<c;f++){const E=G(L,U,F.key,z),T=G(L,U,F.value,z);b.set(E,T)}return b}return J(L,F,z)}catch(b){throw b instanceof _&&b.addToFieldPath(U),b}}function J(L,U,F){if(typeof U.borshDeserialize=="function")return U.borshDeserialize(F);const z=L.get(U);if(!z)throw new _(`Class ${U.name} is missing in schema`);if(z.kind==="struct"){const b={};for(const[c,f]of L.get(U).fields)b[c]=G(L,c,f,F);return new U(b)}if(z.kind==="enum"){const b=F.readU8();if(b>=z.values.length)throw new _(`Enum index: ${b} is out of range`);const[c,f]=z.values[b],E=G(L,c,f,F);return new U({[c]:E})}throw new _(`Unexpected schema kind: ${z.kind} for ${U.constructor.name}`)}function Q(L,U,F,z=x){const b=new z(F),c=J(L,U,b);if(b.offset<F.length)throw new _(`Unexpected ${F.length-b.offset} bytes after deserialized data`);return c}Ot.deserialize=Q;function tt(L,U,F,z=x){const b=new z(F);return J(L,U,b)}return Ot.deserializeUnchecked=tt,Ot}var Ss=Qd(),Y={},Ua;function t0(){if(Ua)return Y;Ua=1,Object.defineProperty(Y,"__esModule",{value:!0}),Y.s16=Y.s8=Y.nu64be=Y.u48be=Y.u40be=Y.u32be=Y.u24be=Y.u16be=Y.nu64=Y.u48=Y.u40=Y.u32=Y.u24=Y.u16=Y.u8=Y.offset=Y.greedy=Y.Constant=Y.UTF8=Y.CString=Y.Blob=Y.Boolean=Y.BitField=Y.BitStructure=Y.VariantLayout=Y.Union=Y.UnionLayoutDiscriminator=Y.UnionDiscriminator=Y.Structure=Y.Sequence=Y.DoubleBE=Y.Double=Y.FloatBE=Y.Float=Y.NearInt64BE=Y.NearInt64=Y.NearUInt64BE=Y.NearUInt64=Y.IntBE=Y.Int=Y.UIntBE=Y.UInt=Y.OffsetLayout=Y.GreedyCount=Y.ExternalLayout=Y.bindConstructorLayout=Y.nameWithProperty=Y.Layout=Y.uint8ArrayToBuffer=Y.checkUint8Array=void 0,Y.constant=Y.utf8=Y.cstr=Y.blob=Y.unionLayoutDiscriminator=Y.union=Y.seq=Y.bits=Y.struct=Y.f64be=Y.f64=Y.f32be=Y.f32=Y.ns64be=Y.s48be=Y.s40be=Y.s32be=Y.s24be=Y.s16be=Y.ns64=Y.s48=Y.s40=Y.s32=Y.s24=void 0;const n=Ro();function t(u){if(!(u instanceof Uint8Array))throw new TypeError("b must be a Uint8Array")}Y.checkUint8Array=t;function e(u){return t(u),n.Buffer.from(u.buffer,u.byteOffset,u.length)}Y.uint8ArrayToBuffer=e;class r{constructor(h,v){if(!Number.isInteger(h))throw new TypeError("span must be an integer");this.span=h,this.property=v}makeDestinationObject(){return{}}getSpan(h,v){if(0>this.span)throw new RangeError("indeterminate span");return this.span}replicate(h){const v=Object.create(this.constructor.prototype);return Object.assign(v,this),v.property=h,v}fromArray(h){}}Y.Layout=r;function s(u,h){return h.property?u+"["+h.property+"]":u}Y.nameWithProperty=s;function i(u,h){if(typeof u!="function")throw new TypeError("Class must be constructor");if(Object.prototype.hasOwnProperty.call(u,"layout_"))throw new Error("Class is already bound to a layout");if(!(h&&h instanceof r))throw new TypeError("layout must be a Layout");if(Object.prototype.hasOwnProperty.call(h,"boundConstructor_"))throw new Error("layout is already bound to a constructor");u.layout_=h,h.boundConstructor_=u,h.makeDestinationObject=(()=>new u),Object.defineProperty(u.prototype,"encode",{value(v,C){return h.encode(this,v,C)},writable:!0}),Object.defineProperty(u,"decode",{value(v,C){return h.decode(v,C)},writable:!0})}Y.bindConstructorLayout=i;class o extends r{isCount(){throw new Error("ExternalLayout is abstract")}}Y.ExternalLayout=o;class a extends o{constructor(h=1,v){if(!Number.isInteger(h)||0>=h)throw new TypeError("elementSpan must be a (positive) integer");super(-1,v),this.elementSpan=h}isCount(){return!0}decode(h,v=0){t(h);const C=h.length-v;return Math.floor(C/this.elementSpan)}encode(h,v,C){return 0}}Y.GreedyCount=a;class l extends o{constructor(h,v=0,C){if(!(h instanceof r))throw new TypeError("layout must be a Layout");if(!Number.isInteger(v))throw new TypeError("offset must be integer or undefined");super(h.span,C||h.property),this.layout=h,this.offset=v}isCount(){return this.layout instanceof p||this.layout instanceof m}decode(h,v=0){return this.layout.decode(h,v+this.offset)}encode(h,v,C=0){return this.layout.encode(h,v,C+this.offset)}}Y.OffsetLayout=l;class p extends r{constructor(h,v){if(super(h,v),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(h,v=0){return e(h).readUIntLE(v,this.span)}encode(h,v,C=0){return e(v).writeUIntLE(h,C,this.span),this.span}}Y.UInt=p;class m extends r{constructor(h,v){if(super(h,v),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(h,v=0){return e(h).readUIntBE(v,this.span)}encode(h,v,C=0){return e(v).writeUIntBE(h,C,this.span),this.span}}Y.UIntBE=m;class S extends r{constructor(h,v){if(super(h,v),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(h,v=0){return e(h).readIntLE(v,this.span)}encode(h,v,C=0){return e(v).writeIntLE(h,C,this.span),this.span}}Y.Int=S;class R extends r{constructor(h,v){if(super(h,v),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(h,v=0){return e(h).readIntBE(v,this.span)}encode(h,v,C=0){return e(v).writeIntBE(h,C,this.span),this.span}}Y.IntBE=R;const _=Math.pow(2,32);function I(u){const h=Math.floor(u/_),v=u-h*_;return{hi32:h,lo32:v}}function O(u,h){return u*_+h}class x extends r{constructor(h){super(8,h)}decode(h,v=0){const C=e(h),K=C.readUInt32LE(v),Z=C.readUInt32LE(v+4);return O(Z,K)}encode(h,v,C=0){const K=I(h),Z=e(v);return Z.writeUInt32LE(K.lo32,C),Z.writeUInt32LE(K.hi32,C+4),8}}Y.NearUInt64=x;class M extends r{constructor(h){super(8,h)}decode(h,v=0){const C=e(h),K=C.readUInt32BE(v),Z=C.readUInt32BE(v+4);return O(K,Z)}encode(h,v,C=0){const K=I(h),Z=e(v);return Z.writeUInt32BE(K.hi32,C),Z.writeUInt32BE(K.lo32,C+4),8}}Y.NearUInt64BE=M;class H extends r{constructor(h){super(8,h)}decode(h,v=0){const C=e(h),K=C.readUInt32LE(v),Z=C.readInt32LE(v+4);return O(Z,K)}encode(h,v,C=0){const K=I(h),Z=e(v);return Z.writeUInt32LE(K.lo32,C),Z.writeInt32LE(K.hi32,C+4),8}}Y.NearInt64=H;class P extends r{constructor(h){super(8,h)}decode(h,v=0){const C=e(h),K=C.readInt32BE(v),Z=C.readUInt32BE(v+4);return O(K,Z)}encode(h,v,C=0){const K=I(h),Z=e(v);return Z.writeInt32BE(K.hi32,C),Z.writeUInt32BE(K.lo32,C+4),8}}Y.NearInt64BE=P;class q extends r{constructor(h){super(4,h)}decode(h,v=0){return e(h).readFloatLE(v)}encode(h,v,C=0){return e(v).writeFloatLE(h,C),4}}Y.Float=q;class G extends r{constructor(h){super(4,h)}decode(h,v=0){return e(h).readFloatBE(v)}encode(h,v,C=0){return e(v).writeFloatBE(h,C),4}}Y.FloatBE=G;class J extends r{constructor(h){super(8,h)}decode(h,v=0){return e(h).readDoubleLE(v)}encode(h,v,C=0){return e(v).writeDoubleLE(h,C),8}}Y.Double=J;class Q extends r{constructor(h){super(8,h)}decode(h,v=0){return e(h).readDoubleBE(v)}encode(h,v,C=0){return e(v).writeDoubleBE(h,C),8}}Y.DoubleBE=Q;class tt extends r{constructor(h,v,C){if(!(h instanceof r))throw new TypeError("elementLayout must be a Layout");if(!(v instanceof o&&v.isCount()||Number.isInteger(v)&&0<=v))throw new TypeError("count must be non-negative integer or an unsigned integer ExternalLayout");let K=-1;!(v instanceof o)&&0<h.span&&(K=v*h.span),super(K,C),this.elementLayout=h,this.count=v}getSpan(h,v=0){if(0<=this.span)return this.span;let C=0,K=this.count;if(K instanceof o&&(K=K.decode(h,v)),0<this.elementLayout.span)C=K*this.elementLayout.span;else{let Z=0;for(;Z<K;)C+=this.elementLayout.getSpan(h,v+C),++Z}return C}decode(h,v=0){const C=[];let K=0,Z=this.count;for(Z instanceof o&&(Z=Z.decode(h,v));K<Z;)C.push(this.elementLayout.decode(h,v)),v+=this.elementLayout.getSpan(h,v),K+=1;return C}encode(h,v,C=0){const K=this.elementLayout,Z=h.reduce((it,ut)=>it+K.encode(ut,v,C+it),0);return this.count instanceof o&&this.count.encode(h.length,v,C),Z}}Y.Sequence=tt;class L extends r{constructor(h,v,C){if(!(Array.isArray(h)&&h.reduce((Z,it)=>Z&&it instanceof r,!0)))throw new TypeError("fields must be array of Layout instances");typeof v=="boolean"&&C===void 0&&(C=v,v=void 0);for(const Z of h)if(0>Z.span&&Z.property===void 0)throw new Error("fields cannot contain unnamed variable-length layout");let K=-1;try{K=h.reduce((Z,it)=>Z+it.getSpan(),0)}catch{}super(K,v),this.fields=h,this.decodePrefixes=!!C}getSpan(h,v=0){if(0<=this.span)return this.span;let C=0;try{C=this.fields.reduce((K,Z)=>{const it=Z.getSpan(h,v);return v+=it,K+it},0)}catch{throw new RangeError("indeterminate span")}return C}decode(h,v=0){t(h);const C=this.makeDestinationObject();for(const K of this.fields)if(K.property!==void 0&&(C[K.property]=K.decode(h,v)),v+=K.getSpan(h,v),this.decodePrefixes&&h.length===v)break;return C}encode(h,v,C=0){const K=C;let Z=0,it=0;for(const ut of this.fields){let St=ut.span;if(it=0<St?St:0,ut.property!==void 0){const kt=h[ut.property];kt!==void 0&&(it=ut.encode(kt,v,C),0>St&&(St=ut.getSpan(v,C)))}Z=C,C+=St}return Z+it-K}fromArray(h){const v=this.makeDestinationObject();for(const C of this.fields)C.property!==void 0&&0<h.length&&(v[C.property]=h.shift());return v}layoutFor(h){if(typeof h!="string")throw new TypeError("property must be string");for(const v of this.fields)if(v.property===h)return v}offsetOf(h){if(typeof h!="string")throw new TypeError("property must be string");let v=0;for(const C of this.fields){if(C.property===h)return v;0>C.span?v=-1:0<=v&&(v+=C.span)}}}Y.Structure=L;class U{constructor(h){this.property=h}decode(h,v){throw new Error("UnionDiscriminator is abstract")}encode(h,v,C){throw new Error("UnionDiscriminator is abstract")}}Y.UnionDiscriminator=U;class F extends U{constructor(h,v){if(!(h instanceof o&&h.isCount()))throw new TypeError("layout must be an unsigned integer ExternalLayout");super(v||h.property||"variant"),this.layout=h}decode(h,v){return this.layout.decode(h,v)}encode(h,v,C){return this.layout.encode(h,v,C)}}Y.UnionLayoutDiscriminator=F;class z extends r{constructor(h,v,C){let K;if(h instanceof p||h instanceof m)K=new F(new l(h));else if(h instanceof o&&h.isCount())K=new F(h);else if(h instanceof U)K=h;else throw new TypeError("discr must be a UnionDiscriminator or an unsigned integer layout");if(v===void 0&&(v=null),!(v===null||v instanceof r))throw new TypeError("defaultLayout must be null or a Layout");if(v!==null){if(0>v.span)throw new Error("defaultLayout must have constant span");v.property===void 0&&(v=v.replicate("content"))}let Z=-1;v&&(Z=v.span,0<=Z&&(h instanceof p||h instanceof m)&&(Z+=K.layout.span)),super(Z,C),this.discriminator=K,this.usesPrefixDiscriminator=h instanceof p||h instanceof m,this.defaultLayout=v,this.registry={};let it=this.defaultGetSourceVariant.bind(this);this.getSourceVariant=function(ut){return it(ut)},this.configGetSourceVariant=function(ut){it=ut.bind(this)}}getSpan(h,v=0){if(0<=this.span)return this.span;const C=this.getVariant(h,v);if(!C)throw new Error("unable to determine span for unrecognized variant");return C.getSpan(h,v)}defaultGetSourceVariant(h){if(Object.prototype.hasOwnProperty.call(h,this.discriminator.property)){if(this.defaultLayout&&this.defaultLayout.property&&Object.prototype.hasOwnProperty.call(h,this.defaultLayout.property))return;const v=this.registry[h[this.discriminator.property]];if(v&&(!v.layout||v.property&&Object.prototype.hasOwnProperty.call(h,v.property)))return v}else for(const v in this.registry){const C=this.registry[v];if(C.property&&Object.prototype.hasOwnProperty.call(h,C.property))return C}throw new Error("unable to infer src variant")}decode(h,v=0){let C;const K=this.discriminator,Z=K.decode(h,v),it=this.registry[Z];if(it===void 0){const ut=this.defaultLayout;let St=0;this.usesPrefixDiscriminator&&(St=K.layout.span),C=this.makeDestinationObject(),C[K.property]=Z,C[ut.property]=ut.decode(h,v+St)}else C=it.decode(h,v);return C}encode(h,v,C=0){const K=this.getSourceVariant(h);if(K===void 0){const Z=this.discriminator,it=this.defaultLayout;let ut=0;return this.usesPrefixDiscriminator&&(ut=Z.layout.span),Z.encode(h[Z.property],v,C),ut+it.encode(h[it.property],v,C+ut)}return K.encode(h,v,C)}addVariant(h,v,C){const K=new b(this,h,v,C);return this.registry[h]=K,K}getVariant(h,v=0){let C;return h instanceof Uint8Array?C=this.discriminator.decode(h,v):C=h,this.registry[C]}}Y.Union=z;class b extends r{constructor(h,v,C,K){if(!(h instanceof z))throw new TypeError("union must be a Union");if(!Number.isInteger(v)||0>v)throw new TypeError("variant must be a (non-negative) integer");if(typeof C=="string"&&K===void 0&&(K=C,C=null),C){if(!(C instanceof r))throw new TypeError("layout must be a Layout");if(h.defaultLayout!==null&&0<=C.span&&C.span>h.defaultLayout.span)throw new Error("variant span exceeds span of containing union");if(typeof K!="string")throw new TypeError("variant must have a String property")}let Z=h.span;0>h.span&&(Z=C?C.span:0,0<=Z&&h.usesPrefixDiscriminator&&(Z+=h.discriminator.layout.span)),super(Z,K),this.union=h,this.variant=v,this.layout=C||null}getSpan(h,v=0){if(0<=this.span)return this.span;let C=0;this.union.usesPrefixDiscriminator&&(C=this.union.discriminator.layout.span);let K=0;return this.layout&&(K=this.layout.getSpan(h,v+C)),C+K}decode(h,v=0){const C=this.makeDestinationObject();if(this!==this.union.getVariant(h,v))throw new Error("variant mismatch");let K=0;return this.union.usesPrefixDiscriminator&&(K=this.union.discriminator.layout.span),this.layout?C[this.property]=this.layout.decode(h,v+K):this.property?C[this.property]=!0:this.union.usesPrefixDiscriminator&&(C[this.union.discriminator.property]=this.variant),C}encode(h,v,C=0){let K=0;if(this.union.usesPrefixDiscriminator&&(K=this.union.discriminator.layout.span),this.layout&&!Object.prototype.hasOwnProperty.call(h,this.property))throw new TypeError("variant lacks property "+this.property);this.union.discriminator.encode(this.variant,v,C);let Z=K;if(this.layout&&(this.layout.encode(h[this.property],v,C+K),Z+=this.layout.getSpan(v,C+K),0<=this.union.span&&Z>this.union.span))throw new Error("encoded variant overruns containing union");return Z}fromArray(h){if(this.layout)return this.layout.fromArray(h)}}Y.VariantLayout=b;function c(u){return 0>u&&(u+=4294967296),u}class f extends r{constructor(h,v,C){if(!(h instanceof p||h instanceof m))throw new TypeError("word must be a UInt or UIntBE layout");if(typeof v=="string"&&C===void 0&&(C=v,v=!1),4<h.span)throw new RangeError("word cannot exceed 32 bits");super(h.span,C),this.word=h,this.msb=!!v,this.fields=[];let K=0;this._packedSetValue=function(Z){return K=c(Z),this},this._packedGetValue=function(){return K}}decode(h,v=0){const C=this.makeDestinationObject(),K=this.word.decode(h,v);this._packedSetValue(K);for(const Z of this.fields)Z.property!==void 0&&(C[Z.property]=Z.decode(h));return C}encode(h,v,C=0){const K=this.word.decode(v,C);this._packedSetValue(K);for(const Z of this.fields)if(Z.property!==void 0){const it=h[Z.property];it!==void 0&&Z.encode(it)}return this.word.encode(this._packedGetValue(),v,C)}addField(h,v){const C=new E(this,h,v);return this.fields.push(C),C}addBoolean(h){const v=new T(this,h);return this.fields.push(v),v}fieldFor(h){if(typeof h!="string")throw new TypeError("property must be string");for(const v of this.fields)if(v.property===h)return v}}Y.BitStructure=f;class E{constructor(h,v,C){if(!(h instanceof f))throw new TypeError("container must be a BitStructure");if(!Number.isInteger(v)||0>=v)throw new TypeError("bits must be positive integer");const K=8*h.span,Z=h.fields.reduce((it,ut)=>it+ut.bits,0);if(v+Z>K)throw new Error("bits too long for span remainder ("+(K-Z)+" of "+K+" remain)");this.container=h,this.bits=v,this.valueMask=(1<<v)-1,v===32&&(this.valueMask=4294967295),this.start=Z,this.container.msb&&(this.start=K-Z-v),this.wordMask=c(this.valueMask<<this.start),this.property=C}decode(h,v){const C=this.container._packedGetValue();return c(C&this.wordMask)>>>this.start}encode(h){if(typeof h!="number"||!Number.isInteger(h)||h!==c(h&this.valueMask))throw new TypeError(s("BitField.encode",this)+" value must be integer not exceeding "+this.valueMask);const v=this.container._packedGetValue(),C=c(h<<this.start);this.container._packedSetValue(c(v&~this.wordMask)|C)}}Y.BitField=E;class T extends E{constructor(h,v){super(h,1,v)}decode(h,v){return!!super.decode(h,v)}encode(h){typeof h=="boolean"&&(h=+h),super.encode(h)}}Y.Boolean=T;class N extends r{constructor(h,v){if(!(h instanceof o&&h.isCount()||Number.isInteger(h)&&0<=h))throw new TypeError("length must be positive integer or an unsigned integer ExternalLayout");let C=-1;h instanceof o||(C=h),super(C,v),this.length=h}getSpan(h,v){let C=this.span;return 0>C&&(C=this.length.decode(h,v)),C}decode(h,v=0){let C=this.span;return 0>C&&(C=this.length.decode(h,v)),e(h).slice(v,v+C)}encode(h,v,C){let K=this.length;if(this.length instanceof o&&(K=h.length),!(h instanceof Uint8Array&&K===h.length))throw new TypeError(s("Blob.encode",this)+" requires (length "+K+") Uint8Array as src");if(C+K>v.length)throw new RangeError("encoding overruns Uint8Array");const Z=e(h);return e(v).write(Z.toString("hex"),C,K,"hex"),this.length instanceof o&&this.length.encode(K,v,C),K}}Y.Blob=N;class A extends r{constructor(h){super(-1,h)}getSpan(h,v=0){t(h);let C=v;for(;C<h.length&&h[C]!==0;)C+=1;return 1+C-v}decode(h,v=0){const C=this.getSpan(h,v);return e(h).slice(v,v+C-1).toString("utf-8")}encode(h,v,C=0){typeof h!="string"&&(h=String(h));const K=n.Buffer.from(h,"utf8"),Z=K.length;if(C+Z>v.length)throw new RangeError("encoding overruns Buffer");const it=e(v);return K.copy(it,C),it[C+Z]=0,Z+1}}Y.CString=A;class g extends r{constructor(h,v){if(typeof h=="string"&&v===void 0&&(v=h,h=void 0),h===void 0)h=-1;else if(!Number.isInteger(h))throw new TypeError("maxSpan must be an integer");super(-1,v),this.maxSpan=h}getSpan(h,v=0){return t(h),h.length-v}decode(h,v=0){const C=this.getSpan(h,v);if(0<=this.maxSpan&&this.maxSpan<C)throw new RangeError("text length exceeds maxSpan");return e(h).slice(v,v+C).toString("utf-8")}encode(h,v,C=0){typeof h!="string"&&(h=String(h));const K=n.Buffer.from(h,"utf8"),Z=K.length;if(0<=this.maxSpan&&this.maxSpan<Z)throw new RangeError("text length exceeds maxSpan");if(C+Z>v.length)throw new RangeError("encoding overruns Buffer");return K.copy(e(v),C),Z}}Y.UTF8=g;class d extends r{constructor(h,v){super(0,v),this.value=h}decode(h,v){return this.value}encode(h,v,C){return 0}}return Y.Constant=d,Y.greedy=((u,h)=>new a(u,h)),Y.offset=((u,h,v)=>new l(u,h,v)),Y.u8=(u=>new p(1,u)),Y.u16=(u=>new p(2,u)),Y.u24=(u=>new p(3,u)),Y.u32=(u=>new p(4,u)),Y.u40=(u=>new p(5,u)),Y.u48=(u=>new p(6,u)),Y.nu64=(u=>new x(u)),Y.u16be=(u=>new m(2,u)),Y.u24be=(u=>new m(3,u)),Y.u32be=(u=>new m(4,u)),Y.u40be=(u=>new m(5,u)),Y.u48be=(u=>new m(6,u)),Y.nu64be=(u=>new M(u)),Y.s8=(u=>new S(1,u)),Y.s16=(u=>new S(2,u)),Y.s24=(u=>new S(3,u)),Y.s32=(u=>new S(4,u)),Y.s40=(u=>new S(5,u)),Y.s48=(u=>new S(6,u)),Y.ns64=(u=>new H(u)),Y.s16be=(u=>new R(2,u)),Y.s24be=(u=>new R(3,u)),Y.s32be=(u=>new R(4,u)),Y.s40be=(u=>new R(5,u)),Y.s48be=(u=>new R(6,u)),Y.ns64be=(u=>new P(u)),Y.f32=(u=>new q(u)),Y.f32be=(u=>new G(u)),Y.f64=(u=>new J(u)),Y.f64be=(u=>new Q(u)),Y.struct=((u,h,v)=>new L(u,h,v)),Y.bits=((u,h,v)=>new f(u,h,v)),Y.seq=((u,h,v)=>new tt(u,h,v)),Y.union=((u,h,v)=>new z(u,h,v)),Y.unionLayoutDiscriminator=((u,h)=>new F(u,h)),Y.blob=((u,h)=>new N(u,h)),Y.cstr=(u=>new A(u)),Y.utf8=((u,h)=>new g(u,h)),Y.constant=((u,h)=>new d(u,h)),Y}var D=t0(),e0=8078e3,r0=8078001,n0=8078004,i0=8078005,s0=8078006,o0=8078011;function Ou(n){return Array.isArray(n)?"%5B"+n.map(Ou).join("%2C%20")+"%5D":typeof n=="bigint"?`${n}n`:encodeURIComponent(String(n!=null&&Object.getPrototypeOf(n)===null?{...n}:n))}function a0([n,t]){return`${n}=${Ou(t)}`}function c0(n){const t=Object.entries(n).map(a0).join("&");return btoa(t)}function u0(n,t={}){{let e=`Solana error #${n}; Decode this error by running \`npx @solana/errors decode -- ${n}`;return Object.keys(t).length&&(e+=` '${c0(t)}'`),`${e}\``}}var tn=class extends Error{constructor(...[t,e]){let r,s;if(e){const{cause:o,...a}=e;o&&(s={cause:o}),Object.keys(a).length>0&&(r=a)}const i=u0(t,r);super(i,s);de(this,"cause",this.cause);de(this,"context");this.context={__code:t,...r},this.name="SolanaError"}};function l0(n,t){return"fixedSize"in t?t.fixedSize:t.getSizeFromValue(n)}function h0(n){return Object.freeze({...n,encode:t=>{const e=new Uint8Array(l0(t,n));return n.write(t,e,0),e}})}function f0(n){return Object.freeze({...n,decode:(t,e=0)=>n.read(t,e)[0]})}function Yr(n){return"fixedSize"in n&&typeof n.fixedSize=="number"}function d0(n,t){if(Yr(n)!==Yr(t))throw new tn(n0);if(Yr(n)&&Yr(t)&&n.fixedSize!==t.fixedSize)throw new tn(i0,{decoderFixedSize:t.fixedSize,encoderFixedSize:n.fixedSize});if(!Yr(n)&&!Yr(t)&&n.maxSize!==t.maxSize)throw new tn(s0,{decoderMaxSize:t.maxSize,encoderMaxSize:n.maxSize});return{...t,...n,decode:t.decode,encode:n.encode,read:t.read,write:n.write}}function p0(n,t,e=0){if(t.length-e<=0)throw new tn(e0,{codecDescription:n})}function y0(n,t,e,r=0){const s=e.length-r;if(s<t)throw new tn(r0,{bytesLength:s,codecDescription:n,expected:t})}function g0(n,t,e,r){if(r<t||r>e)throw new tn(o0,{codecDescription:n,max:e,min:t,value:r})}function xu(n){return n?.endian!==1}function m0(n){return h0({fixedSize:n.size,write(t,e,r){n.range&&g0(n.name,n.range[0],n.range[1],t);const s=new ArrayBuffer(n.size);return n.set(new DataView(s),t,xu(n.config)),e.set(new Uint8Array(s),r),r+n.size}})}function w0(n){return f0({fixedSize:n.size,read(t,e=0){p0(n.name,t,e),y0(n.name,n.size,t,e);const r=new DataView(_0(t,e,n.size));return[n.get(r,xu(n.config)),e+n.size]}})}function _0(n,t,e){const r=n.byteOffset+(t??0),s=e??n.byteLength;return n.buffer.slice(r,r+s)}var Nu=(n={})=>m0({config:n,name:"u64",range:[0n,BigInt("0xffffffffffffffff")],set:(t,e,r)=>t.setBigUint64(0,BigInt(e),r),size:8}),b0=(n={})=>w0({config:n,get:(t,e)=>t.getBigUint64(0,e),name:"u64",size:8}),E0=(n={})=>d0(Nu(n),b0(n));let R0=class extends TypeError{constructor(t,e){let r;const{message:s,explanation:i,...o}=t,{path:a}=t,l=a.length===0?s:`At path: ${a.join(".")} -- ${s}`;super(i??l),i!=null&&(this.cause=l),Object.assign(this,o),this.name=this.constructor.name,this.failures=()=>r??(r=[t,...e()])}};function v0(n){return Ln(n)&&typeof n[Symbol.iterator]=="function"}function Ln(n){return typeof n=="object"&&n!=null}function bi(n){return Ln(n)&&!Array.isArray(n)}function Ke(n){return typeof n=="symbol"?n.toString():typeof n=="string"?JSON.stringify(n):`${n}`}function A0(n){const{done:t,value:e}=n.next();return t?void 0:e}function I0(n,t,e,r){if(n===!0)return;n===!1?n={}:typeof n=="string"&&(n={message:n});const{path:s,branch:i}=t,{type:o}=e,{refinement:a,message:l=`Expected a value of type \`${o}\`${a?` with refinement \`${a}\``:""}, but received: \`${Ke(r)}\``}=n;return{value:r,type:o,refinement:a,key:s[s.length-1],path:s,branch:i,...n,message:l}}function*Da(n,t,e,r){v0(n)||(n=[n]);for(const s of n){const i=I0(s,t,e,r);i&&(yield i)}}function*Bo(n,t,e={}){const{path:r=[],branch:s=[n],coerce:i=!1,mask:o=!1}=e,a={path:r,branch:s,mask:o};i&&(n=t.coercer(n,a));let l="valid";for(const p of t.validator(n,a))p.explanation=e.message,l="not_valid",yield[p,void 0];for(let[p,m,S]of t.entries(n,a)){const R=Bo(m,S,{path:p===void 0?r:[...r,p],branch:p===void 0?s:[...s,m],coerce:i,mask:o,message:e.message});for(const _ of R)_[0]?(l=_[0].refinement!=null?"not_refined":"not_valid",yield[_[0],void 0]):i&&(m=_[1],p===void 0?n=m:n instanceof Map?n.set(p,m):n instanceof Set?n.add(m):Ln(n)&&(m!==void 0||p in n)&&(n[p]=m))}if(l!=="not_valid")for(const p of t.refiner(n,a))p.explanation=e.message,l="not_refined",yield[p,void 0];l==="valid"&&(yield[void 0,n])}let Qe=class{constructor(t){const{type:e,schema:r,validator:s,refiner:i,coercer:o=l=>l,entries:a=function*(){}}=t;this.type=e,this.schema=r,this.entries=a,this.coercer=o,s?this.validator=(l,p)=>{const m=s(l,p);return Da(m,p,this,l)}:this.validator=()=>[],i?this.refiner=(l,p)=>{const m=i(l,p);return Da(m,p,this,l)}:this.refiner=()=>[]}assert(t,e){return Cu(t,this,e)}create(t,e){return st(t,this,e)}is(t){return Bu(t,this)}mask(t,e){return S0(t,this,e)}validate(t,e={}){return Pn(t,this,e)}};function Cu(n,t,e){const r=Pn(n,t,{message:e});if(r[0])throw r[0]}function st(n,t,e){const r=Pn(n,t,{coerce:!0,message:e});if(r[0])throw r[0];return r[1]}function S0(n,t,e){const r=Pn(n,t,{coerce:!0,mask:!0,message:e});if(r[0])throw r[0];return r[1]}function Bu(n,t){return!Pn(n,t)[0]}function Pn(n,t,e={}){const r=Bo(n,t,e),s=A0(r);return s[0]?[new R0(s[0],function*(){for(const o of r)o[0]&&(yield o[0])}),void 0]:[void 0,s[1]]}function Kr(n,t){return new Qe({type:n,schema:null,validator:t})}function k0(){return Kr("any",()=>!0)}function at(n){return new Qe({type:"array",schema:n,*entries(t){if(n&&Array.isArray(t))for(const[e,r]of t.entries())yield[e,r,n]},coercer(t){return Array.isArray(t)?t.slice():t},validator(t){return Array.isArray(t)||`Expected an array value, but received: ${Ke(t)}`}})}function Je(){return Kr("boolean",n=>typeof n=="boolean")}function Mo(n){return Kr("instance",t=>t instanceof n||`Expected a \`${n.name}\` instance, but received: ${Ke(t)}`)}function zt(n){const t=Ke(n),e=typeof n;return new Qe({type:"literal",schema:e==="string"||e==="number"||e==="boolean"?n:null,validator(r){return r===n||`Expected the literal \`${t}\`, but received: ${Ke(r)}`}})}function T0(){return Kr("never",()=>!1)}function ct(n){return new Qe({...n,validator:(t,e)=>t===null||n.validator(t,e),refiner:(t,e)=>t===null||n.refiner(t,e)})}function W(){return Kr("number",n=>typeof n=="number"&&!isNaN(n)||`Expected a number, but received: ${Ke(n)}`)}function dt(n){return new Qe({...n,validator:(t,e)=>t===void 0||n.validator(t,e),refiner:(t,e)=>t===void 0||n.refiner(t,e)})}function Mu(n,t){return new Qe({type:"record",schema:null,*entries(e){if(Ln(e))for(const r in e){const s=e[r];yield[r,r,n],yield[r,s,t]}},validator(e){return bi(e)||`Expected an object, but received: ${Ke(e)}`},coercer(e){return bi(e)?{...e}:e}})}function nt(){return Kr("string",n=>typeof n=="string"||`Expected a string, but received: ${Ke(n)}`)}function Lo(n){const t=T0();return new Qe({type:"tuple",schema:null,*entries(e){if(Array.isArray(e)){const r=Math.max(n.length,e.length);for(let s=0;s<r;s++)yield[s,e[s],n[s]||t]}},validator(e){return Array.isArray(e)||`Expected an array, but received: ${Ke(e)}`},coercer(e){return Array.isArray(e)?e.slice():e}})}function et(n){const t=Object.keys(n);return new Qe({type:"type",schema:n,*entries(e){if(Ln(e))for(const r of t)yield[r,e[r],n[r]]},validator(e){return bi(e)||`Expected an object, but received: ${Ke(e)}`},coercer(e){return bi(e)?{...e}:e}})}function ke(n){const t=n.map(e=>e.type).join(" | ");return new Qe({type:"union",schema:null,coercer(e,r){for(const s of n){const[i,o]=s.validate(e,{coerce:!0,mask:r.mask});if(!i)return o}return e},validator(e,r){const s=[];for(const i of n){const[...o]=Bo(e,i,r),[a]=o;if(a[0])for(const[l]of o)l&&s.push(l);else return[]}return[`Expected the value to satisfy a union of \`${t}\`, but received: ${Ke(e)}`,...s]}})}function fn(){return Kr("unknown",()=>!0)}function Un(n,t,e){return new Qe({...n,coercer:(r,s)=>Bu(r,t)?n.coercer(e(r,s),s):n.coercer(r,s)})}var Xn,O0=new Uint8Array(16);function Lu(){if(!Xn&&(Xn=typeof crypto<"u"&&crypto.getRandomValues&&crypto.getRandomValues.bind(crypto)||typeof msCrypto<"u"&&typeof msCrypto.getRandomValues=="function"&&msCrypto.getRandomValues.bind(msCrypto),!Xn))throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");return Xn(O0)}const x0=/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;function Ci(n){return typeof n=="string"&&x0.test(n)}var _e=[];for(var ks=0;ks<256;++ks)_e.push((ks+256).toString(16).substr(1));function Bi(n){var t=arguments.length>1&&arguments[1]!==void 0?arguments[1]:0,e=(_e[n[t+0]]+_e[n[t+1]]+_e[n[t+2]]+_e[n[t+3]]+"-"+_e[n[t+4]]+_e[n[t+5]]+"-"+_e[n[t+6]]+_e[n[t+7]]+"-"+_e[n[t+8]]+_e[n[t+9]]+"-"+_e[n[t+10]]+_e[n[t+11]]+_e[n[t+12]]+_e[n[t+13]]+_e[n[t+14]]+_e[n[t+15]]).toLowerCase();if(!Ci(e))throw TypeError("Stringified UUID is invalid");return e}var Ha,Ts,Os=0,xs=0;function N0(n,t,e){var r=t&&e||0,s=t||new Array(16);n=n||{};var i=n.node||Ha,o=n.clockseq!==void 0?n.clockseq:Ts;if(i==null||o==null){var a=n.random||(n.rng||Lu)();i==null&&(i=Ha=[a[0]|1,a[1],a[2],a[3],a[4],a[5]]),o==null&&(o=Ts=(a[6]<<8|a[7])&16383)}var l=n.msecs!==void 0?n.msecs:Date.now(),p=n.nsecs!==void 0?n.nsecs:xs+1,m=l-Os+(p-xs)/1e4;if(m<0&&n.clockseq===void 0&&(o=o+1&16383),(m<0||l>Os)&&n.nsecs===void 0&&(p=0),p>=1e4)throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");Os=l,xs=p,Ts=o,l+=122192928e5;var S=((l&268435455)*1e4+p)%4294967296;s[r++]=S>>>24&255,s[r++]=S>>>16&255,s[r++]=S>>>8&255,s[r++]=S&255;var R=l/4294967296*1e4&268435455;s[r++]=R>>>8&255,s[r++]=R&255,s[r++]=R>>>24&15|16,s[r++]=R>>>16&255,s[r++]=o>>>8|128,s[r++]=o&255;for(var _=0;_<6;++_)s[r+_]=i[_];return t||Bi(s)}function Pu(n){if(!Ci(n))throw TypeError("Invalid UUID");var t,e=new Uint8Array(16);return e[0]=(t=parseInt(n.slice(0,8),16))>>>24,e[1]=t>>>16&255,e[2]=t>>>8&255,e[3]=t&255,e[4]=(t=parseInt(n.slice(9,13),16))>>>8,e[5]=t&255,e[6]=(t=parseInt(n.slice(14,18),16))>>>8,e[7]=t&255,e[8]=(t=parseInt(n.slice(19,23),16))>>>8,e[9]=t&255,e[10]=(t=parseInt(n.slice(24,36),16))/1099511627776&255,e[11]=t/4294967296&255,e[12]=t>>>24&255,e[13]=t>>>16&255,e[14]=t>>>8&255,e[15]=t&255,e}function C0(n){n=unescape(encodeURIComponent(n));for(var t=[],e=0;e<n.length;++e)t.push(n.charCodeAt(e));return t}var B0="6ba7b810-9dad-11d1-80b4-00c04fd430c8",M0="6ba7b811-9dad-11d1-80b4-00c04fd430c8";function Uu(n,t,e){function r(s,i,o,a){if(typeof s=="string"&&(s=C0(s)),typeof i=="string"&&(i=Pu(i)),i.length!==16)throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");var l=new Uint8Array(16+s.length);if(l.set(i),l.set(s,i.length),l=e(l),l[6]=l[6]&15|t,l[8]=l[8]&63|128,o){a=a||0;for(var p=0;p<16;++p)o[a+p]=l[p];return o}return Bi(l)}try{r.name=n}catch{}return r.DNS=B0,r.URL=M0,r}function L0(n){if(typeof n=="string"){var t=unescape(encodeURIComponent(n));n=new Uint8Array(t.length);for(var e=0;e<t.length;++e)n[e]=t.charCodeAt(e)}return P0(U0(D0(n),n.length*8))}function P0(n){for(var t=[],e=n.length*32,r="0123456789abcdef",s=0;s<e;s+=8){var i=n[s>>5]>>>s%32&255,o=parseInt(r.charAt(i>>>4&15)+r.charAt(i&15),16);t.push(o)}return t}function Du(n){return(n+64>>>9<<4)+14+1}function U0(n,t){n[t>>5]|=128<<t%32,n[Du(t)-1]=t;for(var e=1732584193,r=-271733879,s=-1732584194,i=271733878,o=0;o<n.length;o+=16){var a=e,l=r,p=s,m=i;e=ve(e,r,s,i,n[o],7,-680876936),i=ve(i,e,r,s,n[o+1],12,-389564586),s=ve(s,i,e,r,n[o+2],17,606105819),r=ve(r,s,i,e,n[o+3],22,-1044525330),e=ve(e,r,s,i,n[o+4],7,-176418897),i=ve(i,e,r,s,n[o+5],12,1200080426),s=ve(s,i,e,r,n[o+6],17,-1473231341),r=ve(r,s,i,e,n[o+7],22,-45705983),e=ve(e,r,s,i,n[o+8],7,1770035416),i=ve(i,e,r,s,n[o+9],12,-1958414417),s=ve(s,i,e,r,n[o+10],17,-42063),r=ve(r,s,i,e,n[o+11],22,-1990404162),e=ve(e,r,s,i,n[o+12],7,1804603682),i=ve(i,e,r,s,n[o+13],12,-40341101),s=ve(s,i,e,r,n[o+14],17,-1502002290),r=ve(r,s,i,e,n[o+15],22,1236535329),e=Ae(e,r,s,i,n[o+1],5,-165796510),i=Ae(i,e,r,s,n[o+6],9,-1069501632),s=Ae(s,i,e,r,n[o+11],14,643717713),r=Ae(r,s,i,e,n[o],20,-373897302),e=Ae(e,r,s,i,n[o+5],5,-701558691),i=Ae(i,e,r,s,n[o+10],9,38016083),s=Ae(s,i,e,r,n[o+15],14,-660478335),r=Ae(r,s,i,e,n[o+4],20,-405537848),e=Ae(e,r,s,i,n[o+9],5,568446438),i=Ae(i,e,r,s,n[o+14],9,-1019803690),s=Ae(s,i,e,r,n[o+3],14,-187363961),r=Ae(r,s,i,e,n[o+8],20,1163531501),e=Ae(e,r,s,i,n[o+13],5,-1444681467),i=Ae(i,e,r,s,n[o+2],9,-51403784),s=Ae(s,i,e,r,n[o+7],14,1735328473),r=Ae(r,s,i,e,n[o+12],20,-1926607734),e=Ie(e,r,s,i,n[o+5],4,-378558),i=Ie(i,e,r,s,n[o+8],11,-2022574463),s=Ie(s,i,e,r,n[o+11],16,1839030562),r=Ie(r,s,i,e,n[o+14],23,-35309556),e=Ie(e,r,s,i,n[o+1],4,-1530992060),i=Ie(i,e,r,s,n[o+4],11,1272893353),s=Ie(s,i,e,r,n[o+7],16,-155497632),r=Ie(r,s,i,e,n[o+10],23,-1094730640),e=Ie(e,r,s,i,n[o+13],4,681279174),i=Ie(i,e,r,s,n[o],11,-358537222),s=Ie(s,i,e,r,n[o+3],16,-722521979),r=Ie(r,s,i,e,n[o+6],23,76029189),e=Ie(e,r,s,i,n[o+9],4,-640364487),i=Ie(i,e,r,s,n[o+12],11,-421815835),s=Ie(s,i,e,r,n[o+15],16,530742520),r=Ie(r,s,i,e,n[o+2],23,-995338651),e=Se(e,r,s,i,n[o],6,-198630844),i=Se(i,e,r,s,n[o+7],10,1126891415),s=Se(s,i,e,r,n[o+14],15,-1416354905),r=Se(r,s,i,e,n[o+5],21,-57434055),e=Se(e,r,s,i,n[o+12],6,1700485571),i=Se(i,e,r,s,n[o+3],10,-1894986606),s=Se(s,i,e,r,n[o+10],15,-1051523),r=Se(r,s,i,e,n[o+1],21,-2054922799),e=Se(e,r,s,i,n[o+8],6,1873313359),i=Se(i,e,r,s,n[o+15],10,-30611744),s=Se(s,i,e,r,n[o+6],15,-1560198380),r=Se(r,s,i,e,n[o+13],21,1309151649),e=Se(e,r,s,i,n[o+4],6,-145523070),i=Se(i,e,r,s,n[o+11],10,-1120210379),s=Se(s,i,e,r,n[o+2],15,718787259),r=Se(r,s,i,e,n[o+9],21,-343485551),e=br(e,a),r=br(r,l),s=br(s,p),i=br(i,m)}return[e,r,s,i]}function D0(n){if(n.length===0)return[];for(var t=n.length*8,e=new Uint32Array(Du(t)),r=0;r<t;r+=8)e[r>>5]|=(n[r/8]&255)<<r%32;return e}function br(n,t){var e=(n&65535)+(t&65535),r=(n>>16)+(t>>16)+(e>>16);return r<<16|e&65535}function H0(n,t){return n<<t|n>>>32-t}function Mi(n,t,e,r,s,i){return br(H0(br(br(t,n),br(r,i)),s),e)}function ve(n,t,e,r,s,i,o){return Mi(t&e|~t&r,n,t,s,i,o)}function Ae(n,t,e,r,s,i,o){return Mi(t&r|e&~r,n,t,s,i,o)}function Ie(n,t,e,r,s,i,o){return Mi(t^e^r,n,t,s,i,o)}function Se(n,t,e,r,s,i,o){return Mi(e^(t|~r),n,t,s,i,o)}var F0=Uu("v3",48,L0);function z0(n,t,e){n=n||{};var r=n.random||(n.rng||Lu)();if(r[6]=r[6]&15|64,r[8]=r[8]&63|128,t){e=e||0;for(var s=0;s<16;++s)t[e+s]=r[s];return t}return Bi(r)}function K0(n,t,e,r){switch(n){case 0:return t&e^~t&r;case 1:return t^e^r;case 2:return t&e^t&r^e&r;case 3:return t^e^r}}function Ns(n,t){return n<<t|n>>>32-t}function q0(n){var t=[1518500249,1859775393,2400959708,3395469782],e=[1732584193,4023233417,2562383102,271733878,3285377520];if(typeof n=="string"){var r=unescape(encodeURIComponent(n));n=[];for(var s=0;s<r.length;++s)n.push(r.charCodeAt(s))}else Array.isArray(n)||(n=Array.prototype.slice.call(n));n.push(128);for(var i=n.length/4+2,o=Math.ceil(i/16),a=new Array(o),l=0;l<o;++l){for(var p=new Uint32Array(16),m=0;m<16;++m)p[m]=n[l*64+m*4]<<24|n[l*64+m*4+1]<<16|n[l*64+m*4+2]<<8|n[l*64+m*4+3];a[l]=p}a[o-1][14]=(n.length-1)*8/Math.pow(2,32),a[o-1][14]=Math.floor(a[o-1][14]),a[o-1][15]=(n.length-1)*8&4294967295;for(var S=0;S<o;++S){for(var R=new Uint32Array(80),_=0;_<16;++_)R[_]=a[S][_];for(var I=16;I<80;++I)R[I]=Ns(R[I-3]^R[I-8]^R[I-14]^R[I-16],1);for(var O=e[0],x=e[1],M=e[2],H=e[3],P=e[4],q=0;q<80;++q){var G=Math.floor(q/20),J=Ns(O,5)+K0(G,x,M,H)+P+t[G]+R[q]>>>0;P=H,H=M,M=Ns(x,30)>>>0,x=O,O=J}e[0]=e[0]+O>>>0,e[1]=e[1]+x>>>0,e[2]=e[2]+M>>>0,e[3]=e[3]+H>>>0,e[4]=e[4]+P>>>0}return[e[0]>>24&255,e[0]>>16&255,e[0]>>8&255,e[0]&255,e[1]>>24&255,e[1]>>16&255,e[1]>>8&255,e[1]&255,e[2]>>24&255,e[2]>>16&255,e[2]>>8&255,e[2]&255,e[3]>>24&255,e[3]>>16&255,e[3]>>8&255,e[3]&255,e[4]>>24&255,e[4]>>16&255,e[4]>>8&255,e[4]&255]}var $0=Uu("v5",80,q0);const V0="00000000-0000-0000-0000-000000000000";function W0(n){if(!Ci(n))throw TypeError("Invalid UUID");return parseInt(n.substr(14,1),16)}const G0=Object.freeze({__proto__:null,NIL:V0,parse:Pu,stringify:Bi,v1:N0,v3:F0,v4:z0,v5:$0,validate:Ci,version:W0}),Hu=Ti(G0);var Cs,Fa;function j0(){if(Fa)return Cs;Fa=1;const n=Hu.v4;return Cs=function(e,r,s,i){if(typeof e!="string")throw new TypeError(e+" must be a string");i=i||{};const o=typeof i.version=="number"?i.version:2;if(o!==1&&o!==2)throw new TypeError(o+" must be 1 or 2");const a={method:e};if(o===2&&(a.jsonrpc="2.0"),r){if(typeof r!="object"&&!Array.isArray(r))throw new TypeError(r+" must be an object, array or omitted");a.params=r}if(typeof s>"u"){const l=typeof i.generator=="function"?i.generator:function(){return n()};a.id=l(a,i)}else o===2&&s===null?i.notificationIdNull&&(a.id=null):a.id=s;return a},Cs}var Bs,za;function Y0(){if(za)return Bs;za=1;const n=Hu.v4,t=j0(),e=function(r,s){if(!(this instanceof e))return new e(r,s);s||(s={}),this.options={reviver:typeof s.reviver<"u"?s.reviver:null,replacer:typeof s.replacer<"u"?s.replacer:null,generator:typeof s.generator<"u"?s.generator:function(){return n()},version:typeof s.version<"u"?s.version:2,notificationIdNull:typeof s.notificationIdNull=="boolean"?s.notificationIdNull:!1},this.callServer=r};return Bs=e,e.prototype.request=function(r,s,i,o){const a=this;let l=null;const p=Array.isArray(r)&&typeof s=="function";if(this.options.version===1&&p)throw new TypeError("JSON-RPC 1.0 does not support batching");if(p||!p&&r&&typeof r=="object"&&typeof s=="function")o=s,l=r;else{typeof i=="function"&&(o=i,i=void 0);const R=typeof o=="function";try{l=t(r,s,i,{generator:this.options.generator,version:this.options.version,notificationIdNull:this.options.notificationIdNull})}catch(_){if(R)return o(_);throw _}if(!R)return l}let S;try{S=JSON.stringify(l,this.options.replacer)}catch(R){return o(R)}return this.callServer(S,function(R,_){a._parseResponse(R,_,o)}),l},e.prototype._parseResponse=function(r,s,i){if(r){i(r);return}if(!s)return i();let o;try{o=JSON.parse(s,this.options.reviver)}catch(a){return i(a)}if(i.length===3)if(Array.isArray(o)){const a=function(p){return typeof p.error<"u"},l=function(p){return!a(p)};return i(null,o.filter(a),o.filter(l))}else return i(null,o.error,o.result);i(null,o)},Bs}var Z0=Y0();const X0=Fr(Z0);var Ms={exports:{}},Ka;function J0(){return Ka||(Ka=1,(function(n){var t=Object.prototype.hasOwnProperty,e="~";function r(){}Object.create&&(r.prototype=Object.create(null),new r().__proto__||(e=!1));function s(l,p,m){this.fn=l,this.context=p,this.once=m||!1}function i(l,p,m,S,R){if(typeof m!="function")throw new TypeError("The listener must be a function");var _=new s(m,S||l,R),I=e?e+p:p;return l._events[I]?l._events[I].fn?l._events[I]=[l._events[I],_]:l._events[I].push(_):(l._events[I]=_,l._eventsCount++),l}function o(l,p){--l._eventsCount===0?l._events=new r:delete l._events[p]}function a(){this._events=new r,this._eventsCount=0}a.prototype.eventNames=function(){var p=[],m,S;if(this._eventsCount===0)return p;for(S in m=this._events)t.call(m,S)&&p.push(e?S.slice(1):S);return Object.getOwnPropertySymbols?p.concat(Object.getOwnPropertySymbols(m)):p},a.prototype.listeners=function(p){var m=e?e+p:p,S=this._events[m];if(!S)return[];if(S.fn)return[S.fn];for(var R=0,_=S.length,I=new Array(_);R<_;R++)I[R]=S[R].fn;return I},a.prototype.listenerCount=function(p){var m=e?e+p:p,S=this._events[m];return S?S.fn?1:S.length:0},a.prototype.emit=function(p,m,S,R,_,I){var O=e?e+p:p;if(!this._events[O])return!1;var x=this._events[O],M=arguments.length,H,P;if(x.fn){switch(x.once&&this.removeListener(p,x.fn,void 0,!0),M){case 1:return x.fn.call(x.context),!0;case 2:return x.fn.call(x.context,m),!0;case 3:return x.fn.call(x.context,m,S),!0;case 4:return x.fn.call(x.context,m,S,R),!0;case 5:return x.fn.call(x.context,m,S,R,_),!0;case 6:return x.fn.call(x.context,m,S,R,_,I),!0}for(P=1,H=new Array(M-1);P<M;P++)H[P-1]=arguments[P];x.fn.apply(x.context,H)}else{var q=x.length,G;for(P=0;P<q;P++)switch(x[P].once&&this.removeListener(p,x[P].fn,void 0,!0),M){case 1:x[P].fn.call(x[P].context);break;case 2:x[P].fn.call(x[P].context,m);break;case 3:x[P].fn.call(x[P].context,m,S);break;case 4:x[P].fn.call(x[P].context,m,S,R);break;default:if(!H)for(G=1,H=new Array(M-1);G<M;G++)H[G-1]=arguments[G];x[P].fn.apply(x[P].context,H)}}return!0},a.prototype.on=function(p,m,S){return i(this,p,m,S,!1)},a.prototype.once=function(p,m,S){return i(this,p,m,S,!0)},a.prototype.removeListener=function(p,m,S,R){var _=e?e+p:p;if(!this._events[_])return this;if(!m)return o(this,_),this;var I=this._events[_];if(I.fn)I.fn===m&&(!R||I.once)&&(!S||I.context===S)&&o(this,_);else{for(var O=0,x=[],M=I.length;O<M;O++)(I[O].fn!==m||R&&!I[O].once||S&&I[O].context!==S)&&x.push(I[O]);x.length?this._events[_]=x.length===1?x[0]:x:o(this,_)}return this},a.prototype.removeAllListeners=function(p){var m;return p?(m=e?e+p:p,this._events[m]&&o(this,m)):(this._events=new r,this._eventsCount=0),this},a.prototype.off=a.prototype.removeListener,a.prototype.addListener=a.prototype.on,a.prefixed=e,a.EventEmitter=a,n.exports=a})(Ms)),Ms.exports}var Q0=J0();const Fu=Fr(Q0);var tp=class extends Fu{constructor(t,e,r){super();de(this,"socket");this.socket=new window.WebSocket(t,r),this.socket.onopen=()=>this.emit("open"),this.socket.onmessage=s=>this.emit("message",s.data),this.socket.onerror=s=>this.emit("error",s),this.socket.onclose=s=>{this.emit("close",s.code,s.reason)}}send(t,e,r){const s=r||e;try{this.socket.send(t),s()}catch(i){s(i)}}close(t,e){this.socket.close(t,e)}addEventListener(t,e,r){this.socket.addEventListener(t,e,r)}};function ep(n,t){return new tp(n,t)}var rp=class{encode(n){return JSON.stringify(n)}decode(n){return JSON.parse(n)}},np=class extends Fu{constructor(t,e="ws://localhost:8080",{autoconnect:r=!0,reconnect:s=!0,reconnect_interval:i=1e3,max_reconnects:o=5,...a}={},l,p){super();de(this,"address");de(this,"rpc_id");de(this,"queue");de(this,"options");de(this,"autoconnect");de(this,"ready");de(this,"reconnect");de(this,"reconnect_timer_id");de(this,"reconnect_interval");de(this,"max_reconnects");de(this,"rest_options");de(this,"current_reconnects");de(this,"generate_request_id");de(this,"socket");de(this,"webSocketFactory");de(this,"dataPack");this.webSocketFactory=t,this.queue={},this.rpc_id=0,this.address=e,this.autoconnect=r,this.ready=!1,this.reconnect=s,this.reconnect_timer_id=void 0,this.reconnect_interval=i,this.max_reconnects=o,this.rest_options=a,this.current_reconnects=0,this.generate_request_id=l||(()=>typeof this.rpc_id=="number"?++this.rpc_id:Number(this.rpc_id)+1),p?this.dataPack=p:this.dataPack=new rp,this.autoconnect&&this._connect(this.address,{autoconnect:this.autoconnect,reconnect:this.reconnect,reconnect_interval:this.reconnect_interval,max_reconnects:this.max_reconnects,...this.rest_options})}connect(){this.socket||this._connect(this.address,{autoconnect:this.autoconnect,reconnect:this.reconnect,reconnect_interval:this.reconnect_interval,max_reconnects:this.max_reconnects,...this.rest_options})}call(t,e,r,s){return!s&&typeof r=="object"&&(s=r,r=null),new Promise((i,o)=>{if(!this.ready)return o(new Error("socket not ready"));const a=this.generate_request_id(t,e),l={jsonrpc:"2.0",method:t,params:e||void 0,id:a};this.socket.send(this.dataPack.encode(l),s,p=>{if(p)return o(p);this.queue[a]={promise:[i,o]},r&&(this.queue[a].timeout=setTimeout(()=>{delete this.queue[a],o(new Error("reply timeout"))},r))})})}async login(t){const e=await this.call("rpc.login",t);if(!e)throw new Error("authentication failed");return e}async listMethods(){return await this.call("__listMethods")}notify(t,e){return new Promise((r,s)=>{if(!this.ready)return s(new Error("socket not ready"));const i={jsonrpc:"2.0",method:t,params:e};this.socket.send(this.dataPack.encode(i),o=>{if(o)return s(o);r()})})}async subscribe(t){typeof t=="string"&&(t=[t]);const e=await this.call("rpc.on",t);if(typeof t=="string"&&e[t]!=="ok")throw new Error("Failed subscribing to an event '"+t+"' with: "+e[t]);return e}async unsubscribe(t){typeof t=="string"&&(t=[t]);const e=await this.call("rpc.off",t);if(typeof t=="string"&&e[t]!=="ok")throw new Error("Failed unsubscribing from an event with: "+e);return e}close(t,e){this.socket&&this.socket.close(t||1e3,e)}setAutoReconnect(t){this.reconnect=t}setReconnectInterval(t){this.reconnect_interval=t}setMaxReconnects(t){this.max_reconnects=t}getCurrentReconnects(){return this.current_reconnects}getMaxReconnects(){return this.max_reconnects}isReconnecting(){return this.reconnect_timer_id!==void 0}willReconnect(){return this.reconnect&&(this.max_reconnects===0||this.current_reconnects<this.max_reconnects)}_connect(t,e){clearTimeout(this.reconnect_timer_id),this.socket=this.webSocketFactory(t,e),this.socket.addEventListener("open",()=>{this.ready=!0,this.emit("open"),this.current_reconnects=0}),this.socket.addEventListener("message",({data:r})=>{r instanceof ArrayBuffer&&(r=ht.Buffer.from(r).toString());try{r=this.dataPack.decode(r)}catch{return}if(r.notification&&this.listeners(r.notification).length){if(!Object.keys(r.params).length)return this.emit(r.notification);const s=[r.notification];if(r.params.constructor===Object)s.push(r.params);else for(let i=0;i<r.params.length;i++)s.push(r.params[i]);return Promise.resolve().then(()=>{this.emit.apply(this,s)})}if(!this.queue[r.id])return r.method?Promise.resolve().then(()=>{this.emit(r.method,r?.params)}):void 0;"error"in r=="result"in r&&this.queue[r.id].promise[1](new Error('Server response malformed. Response must include either "result" or "error", but not both.')),this.queue[r.id].timeout&&clearTimeout(this.queue[r.id].timeout),r.error?this.queue[r.id].promise[1](r.error):this.queue[r.id].promise[0](r.result),delete this.queue[r.id]}),this.socket.addEventListener("error",r=>this.emit("error",r)),this.socket.addEventListener("close",({code:r,reason:s})=>{this.ready&&setTimeout(()=>this.emit("close",r,s),0),this.ready=!1,this.socket=void 0,r!==1e3&&(this.current_reconnects++,this.reconnect&&(this.max_reconnects>this.current_reconnects||this.max_reconnects===0)?this.reconnect_timer_id=setTimeout(()=>this._connect(t,e),this.reconnect_interval):this.reconnect&&this.max_reconnects>0&&this.current_reconnects>=this.max_reconnects&&setTimeout(()=>this.emit("max_reconnects_reached",r,s),1))})}};const ip=BigInt(0),mn=BigInt(1),sp=BigInt(2),op=BigInt(7),ap=BigInt(256),cp=BigInt(113),zu=[],Ku=[],qu=[];for(let n=0,t=mn,e=1,r=0;n<24;n++){[e,r]=[r,(2*e+3*r)%5],zu.push(2*(5*r+e)),Ku.push((n+1)*(n+2)/2%64);let s=ip;for(let i=0;i<7;i++)t=(t<<mn^(t>>op)*cp)%ap,t&sp&&(s^=mn<<(mn<<BigInt(i))-mn);qu.push(s)}const $u=ou(qu,!0),up=$u[0],lp=$u[1],qa=(n,t,e)=>e>32?Gf(n,t,e):Vf(n,t,e),$a=(n,t,e)=>e>32?jf(n,t,e):Wf(n,t,e);function hp(n,t=24){const e=new Uint32Array(10);for(let r=24-t;r<24;r++){for(let o=0;o<10;o++)e[o]=n[o]^n[o+10]^n[o+20]^n[o+30]^n[o+40];for(let o=0;o<10;o+=2){const a=(o+8)%10,l=(o+2)%10,p=e[l],m=e[l+1],S=qa(p,m,1)^e[a],R=$a(p,m,1)^e[a+1];for(let _=0;_<50;_+=10)n[o+_]^=S,n[o+_+1]^=R}let s=n[2],i=n[3];for(let o=0;o<24;o++){const a=Ku[o],l=qa(s,i,a),p=$a(s,i,a),m=zu[o];s=n[m],i=n[m+1],n[m]=l,n[m+1]=p}for(let o=0;o<50;o+=10){for(let a=0;a<10;a++)e[a]=n[o+a];for(let a=0;a<10;a++)n[o+a]^=~e[(a+2)%10]&e[(a+4)%10]}n[0]^=up[r],n[1]^=lp[r]}vr(e)}class Po extends vo{constructor(t,e,r,s=!1,i=24){if(super(),this.pos=0,this.posOut=0,this.finished=!1,this.destroyed=!1,this.enableXOF=!1,this.blockLen=t,this.suffix=e,this.outputLen=r,this.enableXOF=s,this.rounds=i,An(r),!(0<t&&t<200))throw new Error("only keccak-f1600 function is supported");this.state=new Uint8Array(200),this.state32=Lf(this.state)}clone(){return this._cloneInto()}keccak(){ma(this.state32),hp(this.state32,this.rounds),ma(this.state32),this.posOut=0,this.pos=0}update(t){on(this),t=Oi(t),hr(t);const{blockLen:e,state:r}=this,s=t.length;for(let i=0;i<s;){const o=Math.min(e-this.pos,s-i);for(let a=0;a<o;a++)r[this.pos++]^=t[i++];this.pos===e&&this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;const{state:t,suffix:e,pos:r,blockLen:s}=this;t[r]^=e,(e&128)!==0&&r===s-1&&this.keccak(),t[s-1]^=128,this.keccak()}writeInto(t){on(this,!1),hr(t),this.finish();const e=this.state,{blockLen:r}=this;for(let s=0,i=t.length;s<i;){this.posOut>=r&&this.keccak();const o=Math.min(r-this.posOut,i-s);t.set(e.subarray(this.posOut,this.posOut+o),s),this.posOut+=o,s+=o}return t}xofInto(t){if(!this.enableXOF)throw new Error("XOF is not possible for this instance");return this.writeInto(t)}xof(t){return An(t),this.xofInto(new Uint8Array(t))}digestInto(t){if(nu(t,this),this.finished)throw new Error("digest() was already called");return this.writeInto(t),this.destroy(),t}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,vr(this.state)}_cloneInto(t){const{blockLen:e,suffix:r,outputLen:s,rounds:i,enableXOF:o}=this;return t||(t=new Po(e,r,s,o,i)),t.state32.set(this.state32),t.pos=this.pos,t.posOut=this.posOut,t.finished=this.finished,t.rounds=i,t.suffix=r,t.outputLen=s,t.enableXOF=o,t.destroyed=this.destroyed,t}}const fp=(n,t,e)=>Ao(()=>new Po(t,n,e)),Va=fp(1,136,256/8);class Vu extends vo{constructor(t,e){super(),this.finished=!1,this.destroyed=!1,ru(t);const r=Oi(e);if(this.iHash=t.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const s=this.blockLen,i=new Uint8Array(s);i.set(r.length>s?t.create().update(r).digest():r);for(let o=0;o<i.length;o++)i[o]^=54;this.iHash.update(i),this.oHash=t.create();for(let o=0;o<i.length;o++)i[o]^=106;this.oHash.update(i),vr(i)}update(t){return on(this),this.iHash.update(t),this}digestInto(t){on(this),hr(t,this.outputLen),this.finished=!0,this.iHash.digestInto(t),this.oHash.update(t),this.oHash.digestInto(t),this.destroy()}digest(){const t=new Uint8Array(this.oHash.outputLen);return this.digestInto(t),t}_cloneInto(t){t||(t=Object.create(Object.getPrototypeOf(this),{}));const{oHash:e,iHash:r,finished:s,destroyed:i,blockLen:o,outputLen:a}=this;return t=t,t.finished=s,t.destroyed=i,t.blockLen=o,t.outputLen=a,t.oHash=e._cloneInto(t.oHash),t.iHash=r._cloneInto(t.iHash),t}clone(){return this._cloneInto()}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const Wu=(n,t,e)=>new Vu(n,t).update(e).digest();Wu.create=(n,t)=>new Vu(n,t);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Wa=(n,t)=>(n+(n>=0?t:-t)/Gu)/t;function dp(n,t,e){const[[r,s],[i,o]]=t,a=Wa(o*n,e),l=Wa(-s*n,e);let p=n-a*r-l*i,m=-a*s-l*o;const S=p<lr,R=m<lr;S&&(p=-p),R&&(m=-m);const _=Bn(Math.ceil(hu(e)/2))+en;if(p<lr||p>=_||m<lr||m>=_)throw new Error("splitScalar (endomorphism): failed, k="+n);return{k1neg:S,k1:p,k2neg:R,k2:m}}function io(n){if(!["compact","recovered","der"].includes(n))throw new Error('Signature format must be "compact", "recovered", or "der"');return n}function Ls(n,t){const e={};for(let r of Object.keys(t))e[r]=n[r]===void 0?t[r]:n[r];return Pr(e.lowS,"lowS"),Pr(e.prehash,"prehash"),e.format!==void 0&&io(e.format),e}class pp extends Error{constructor(t=""){super(t)}}const ir={Err:pp,_tlv:{encode:(n,t)=>{const{Err:e}=ir;if(n<0||n>256)throw new e("tlv.encode: wrong tag");if(t.length&1)throw new e("tlv.encode: unpadded data");const r=t.length/2,s=Yn(r);if(s.length/2&128)throw new e("tlv.encode: long form length too big");const i=r>127?Yn(s.length/2|128):"";return Yn(n)+i+s+t},decode(n,t){const{Err:e}=ir;let r=0;if(n<0||n>256)throw new e("tlv.encode: wrong tag");if(t.length<2||t[r++]!==n)throw new e("tlv.decode: wrong tlv");const s=t[r++],i=!!(s&128);let o=0;if(!i)o=s;else{const l=s&127;if(!l)throw new e("tlv.decode(long): indefinite length not supported");if(l>4)throw new e("tlv.decode(long): byte length is too big");const p=t.subarray(r,r+l);if(p.length!==l)throw new e("tlv.decode: length bytes not complete");if(p[0]===0)throw new e("tlv.decode(long): zero leftmost byte");for(const m of p)o=o<<8|m;if(r+=l,o<128)throw new e("tlv.decode(long): not minimal encoding")}const a=t.subarray(r,r+o);if(a.length!==o)throw new e("tlv.decode: wrong value length");return{v:a,l:t.subarray(r+o)}}},_int:{encode(n){const{Err:t}=ir;if(n<lr)throw new t("integer: negative integers are not allowed");let e=Yn(n);if(Number.parseInt(e[0],16)&8&&(e="00"+e),e.length&1)throw new t("unexpected DER parsing assertion: unpadded hex");return e},decode(n){const{Err:t}=ir;if(n[0]&128)throw new t("invalid signature integer: negative");if(n[0]===0&&!(n[1]&128))throw new t("invalid signature integer: unnecessary leading zero");return xi(n)}},toSig(n){const{Err:t,_int:e,_tlv:r}=ir,s=jt("signature",n),{v:i,l:o}=r.decode(48,s);if(o.length)throw new t("invalid signature: left bytes after parsing");const{v:a,l}=r.decode(2,i),{v:p,l:m}=r.decode(2,l);if(m.length)throw new t("invalid signature: left bytes after parsing");return{r:e.decode(a),s:e.decode(p)}},hexFromSig(n){const{_tlv:t,_int:e}=ir,r=t.encode(2,e.encode(n.r)),s=t.encode(2,e.encode(n.s)),i=r+s;return t.encode(48,i)}},lr=BigInt(0),en=BigInt(1),Gu=BigInt(2),Jn=BigInt(3),yp=BigInt(4);function Xr(n,t){const{BYTES:e}=n;let r;if(typeof t=="bigint")r=t;else{let s=jt("private key",t);try{r=n.fromBytes(s)}catch{throw new Error(`invalid private key: expected ui8a of size ${e}, got ${typeof t}`)}}if(!n.isValidNot0(r))throw new Error("invalid private key: out of range [1..N-1]");return r}function gp(n,t={}){const e=ku("weierstrass",n,t),{Fp:r,Fn:s}=e;let i=e.CURVE;const{h:o,n:a}=i;Mn(t,{},{allowInfinityPoint:"boolean",clearCofactor:"function",isTorsionFree:"function",fromBytes:"function",toBytes:"function",endo:"object",wrapPrivateKey:"boolean"});const{endo:l}=t;if(l&&(!r.is0(i.a)||typeof l.beta!="bigint"||!Array.isArray(l.basises)))throw new Error('invalid endo: expected "beta": bigint and "basises": array');const p=Yu(r,s);function m(){if(!r.isOdd)throw new Error("compression is not supported: Field does not have .isOdd()")}function S(z,b,c){const{x:f,y:E}=b.toAffine(),T=r.toBytes(f);if(Pr(c,"isCompressed"),c){m();const N=!r.isOdd(E);return Ge(ju(N),T)}else return Ge(Uint8Array.of(4),T,r.toBytes(E))}function R(z){ze(z,void 0,"Point");const{publicKey:b,publicKeyUncompressed:c}=p,f=z.length,E=z[0],T=z.subarray(1);if(f===b&&(E===2||E===3)){const N=r.fromBytes(T);if(!r.isValid(N))throw new Error("bad point: is not on curve, wrong x");const A=O(N);let g;try{g=r.sqrt(A)}catch(h){const v=h instanceof Error?": "+h.message:"";throw new Error("bad point: is not on curve, sqrt error"+v)}m();const d=r.isOdd(g);return(E&1)===1!==d&&(g=r.neg(g)),{x:N,y:g}}else if(f===c&&E===4){const N=r.BYTES,A=r.fromBytes(T.subarray(0,N)),g=r.fromBytes(T.subarray(N,N*2));if(!x(A,g))throw new Error("bad point: is not on curve");return{x:A,y:g}}else throw new Error(`bad point: got length ${f}, expected compressed=${b} or uncompressed=${c}`)}const _=t.toBytes||S,I=t.fromBytes||R;function O(z){const b=r.sqr(z),c=r.mul(b,z);return r.add(r.add(c,r.mul(z,i.a)),i.b)}function x(z,b){const c=r.sqr(b),f=O(z);return r.eql(c,f)}if(!x(i.Gx,i.Gy))throw new Error("bad curve params: generator point");const M=r.mul(r.pow(i.a,Jn),yp),H=r.mul(r.sqr(i.b),BigInt(27));if(r.is0(r.add(M,H)))throw new Error("bad curve params: a or b");function P(z,b,c=!1){if(!r.isValid(b)||c&&r.is0(b))throw new Error(`bad point coordinate ${z}`);return b}function q(z){if(!(z instanceof L))throw new Error("ProjectivePoint expected")}function G(z){if(!l||!l.basises)throw new Error("no endo");return dp(z,l.basises,s.ORDER)}const J=di((z,b)=>{const{X:c,Y:f,Z:E}=z;if(r.eql(E,r.ONE))return{x:c,y:f};const T=z.is0();b==null&&(b=T?r.ONE:r.inv(E));const N=r.mul(c,b),A=r.mul(f,b),g=r.mul(E,b);if(T)return{x:r.ZERO,y:r.ZERO};if(!r.eql(g,r.ONE))throw new Error("invZ was invalid");return{x:N,y:A}}),Q=di(z=>{if(z.is0()){if(t.allowInfinityPoint&&!r.is0(z.Y))return;throw new Error("bad point: ZERO")}const{x:b,y:c}=z.toAffine();if(!r.isValid(b)||!r.isValid(c))throw new Error("bad point: x or y not field elements");if(!x(b,c))throw new Error("bad point: equation left != right");if(!z.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});function tt(z,b,c,f,E){return c=new L(r.mul(c.X,z),c.Y,c.Z),b=pi(f,b),c=pi(E,c),b.add(c)}class L{constructor(b,c,f){this.X=P("x",b),this.Y=P("y",c,!0),this.Z=P("z",f),Object.freeze(this)}static CURVE(){return i}static fromAffine(b){const{x:c,y:f}=b||{};if(!b||!r.isValid(c)||!r.isValid(f))throw new Error("invalid affine point");if(b instanceof L)throw new Error("projective point not allowed");return r.is0(c)&&r.is0(f)?L.ZERO:new L(c,f,r.ONE)}static fromBytes(b){const c=L.fromAffine(I(ze(b,void 0,"point")));return c.assertValidity(),c}static fromHex(b){return L.fromBytes(jt("pointHex",b))}get x(){return this.toAffine().x}get y(){return this.toAffine().y}precompute(b=8,c=!0){return F.createCache(this,b),c||this.multiply(Jn),this}assertValidity(){Q(this)}hasEvenY(){const{y:b}=this.toAffine();if(!r.isOdd)throw new Error("Field doesn't support isOdd");return!r.isOdd(b)}equals(b){q(b);const{X:c,Y:f,Z:E}=this,{X:T,Y:N,Z:A}=b,g=r.eql(r.mul(c,A),r.mul(T,E)),d=r.eql(r.mul(f,A),r.mul(N,E));return g&&d}negate(){return new L(this.X,r.neg(this.Y),this.Z)}double(){const{a:b,b:c}=i,f=r.mul(c,Jn),{X:E,Y:T,Z:N}=this;let A=r.ZERO,g=r.ZERO,d=r.ZERO,u=r.mul(E,E),h=r.mul(T,T),v=r.mul(N,N),C=r.mul(E,T);return C=r.add(C,C),d=r.mul(E,N),d=r.add(d,d),A=r.mul(b,d),g=r.mul(f,v),g=r.add(A,g),A=r.sub(h,g),g=r.add(h,g),g=r.mul(A,g),A=r.mul(C,A),d=r.mul(f,d),v=r.mul(b,v),C=r.sub(u,v),C=r.mul(b,C),C=r.add(C,d),d=r.add(u,u),u=r.add(d,u),u=r.add(u,v),u=r.mul(u,C),g=r.add(g,u),v=r.mul(T,N),v=r.add(v,v),u=r.mul(v,C),A=r.sub(A,u),d=r.mul(v,h),d=r.add(d,d),d=r.add(d,d),new L(A,g,d)}add(b){q(b);const{X:c,Y:f,Z:E}=this,{X:T,Y:N,Z:A}=b;let g=r.ZERO,d=r.ZERO,u=r.ZERO;const h=i.a,v=r.mul(i.b,Jn);let C=r.mul(c,T),K=r.mul(f,N),Z=r.mul(E,A),it=r.add(c,f),ut=r.add(T,N);it=r.mul(it,ut),ut=r.add(C,K),it=r.sub(it,ut),ut=r.add(c,E);let St=r.add(T,A);return ut=r.mul(ut,St),St=r.add(C,Z),ut=r.sub(ut,St),St=r.add(f,E),g=r.add(N,A),St=r.mul(St,g),g=r.add(K,Z),St=r.sub(St,g),u=r.mul(h,ut),g=r.mul(v,Z),u=r.add(g,u),g=r.sub(K,u),u=r.add(K,u),d=r.mul(g,u),K=r.add(C,C),K=r.add(K,C),Z=r.mul(h,Z),ut=r.mul(v,ut),K=r.add(K,Z),Z=r.sub(C,Z),Z=r.mul(h,Z),ut=r.add(ut,Z),C=r.mul(K,ut),d=r.add(d,C),C=r.mul(St,ut),g=r.mul(it,g),g=r.sub(g,C),C=r.mul(it,K),u=r.mul(St,u),u=r.add(u,C),new L(g,d,u)}subtract(b){return this.add(b.negate())}is0(){return this.equals(L.ZERO)}multiply(b){const{endo:c}=t;if(!s.isValidNot0(b))throw new Error("invalid scalar: out of range");let f,E;const T=N=>F.cached(this,N,A=>Nr(L,A));if(c){const{k1neg:N,k1:A,k2neg:g,k2:d}=G(b),{p:u,f:h}=T(A),{p:v,f:C}=T(d);E=h.add(C),f=tt(c.beta,u,v,N,g)}else{const{p:N,f:A}=T(b);f=N,E=A}return Nr(L,[f,E])[0]}multiplyUnsafe(b){const{endo:c}=t,f=this;if(!s.isValid(b))throw new Error("invalid scalar: out of range");if(b===lr||f.is0())return L.ZERO;if(b===en)return f;if(F.hasCache(this))return this.multiply(b);if(c){const{k1neg:E,k1:T,k2neg:N,k2:A}=G(b),{p1:g,p2:d}=Ed(L,f,T,A);return tt(c.beta,g,d,E,N)}else return F.unsafe(f,b)}multiplyAndAddUnsafe(b,c,f){const E=this.multiplyUnsafe(c).add(b.multiplyUnsafe(f));return E.is0()?void 0:E}toAffine(b){return J(this,b)}isTorsionFree(){const{isTorsionFree:b}=t;return o===en?!0:b?b(L,this):F.unsafe(this,a).is0()}clearCofactor(){const{clearCofactor:b}=t;return o===en?this:b?b(L,this):this.multiplyUnsafe(o)}isSmallOrder(){return this.multiplyUnsafe(o).is0()}toBytes(b=!0){return Pr(b,"isCompressed"),this.assertValidity(),_(L,this,b)}toHex(b=!0){return Lr(this.toBytes(b))}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}get px(){return this.X}get py(){return this.X}get pz(){return this.Z}toRawBytes(b=!0){return this.toBytes(b)}_setWindowSize(b){this.precompute(b)}static normalizeZ(b){return Nr(L,b)}static msm(b,c){return Su(L,s,b,c)}static fromPrivateKey(b){return L.BASE.multiply(Xr(s,b))}}L.BASE=new L(i.Gx,i.Gy,r.ONE),L.ZERO=new L(r.ZERO,r.ONE,r.ZERO),L.Fp=r,L.Fn=s;const U=s.BITS,F=new Iu(L,t.endo?Math.ceil(U/2):U);return L.BASE.precompute(8),L}function ju(n){return Uint8Array.of(n?2:3)}function Yu(n,t){return{secretKey:t.BYTES,publicKey:1+n.BYTES,publicKeyUncompressed:1+2*n.BYTES,publicKeyHasPrefix:!0,signature:2*t.BYTES}}function mp(n,t={}){const{Fn:e}=n,r=t.randomBytes||Io,s=Object.assign(Yu(n.Fp,e),{seed:Ru(e.ORDER)});function i(_){try{return!!Xr(e,_)}catch{return!1}}function o(_,I){const{publicKey:O,publicKeyUncompressed:x}=s;try{const M=_.length;return I===!0&&M!==O||I===!1&&M!==x?!1:!!n.fromBytes(_)}catch{return!1}}function a(_=r(s.seed)){return wd(ze(_,s.seed,"seed"),e.ORDER)}function l(_,I=!0){return n.BASE.multiply(Xr(e,_)).toBytes(I)}function p(_){const I=a(_);return{secretKey:I,publicKey:l(I)}}function m(_){if(typeof _=="bigint")return!1;if(_ instanceof n)return!0;const{secretKey:I,publicKey:O,publicKeyUncompressed:x}=s;if(e.allowedLengths||I===O)return;const M=jt("key",_).length;return M===O||M===x}function S(_,I,O=!0){if(m(_)===!0)throw new Error("first arg must be private key");if(m(I)===!1)throw new Error("second arg must be public key");const x=Xr(e,_);return n.fromHex(I).multiply(x).toBytes(O)}return Object.freeze({getPublicKey:l,getSharedSecret:S,keygen:p,Point:n,utils:{isValidSecretKey:i,isValidPublicKey:o,randomSecretKey:a,isValidPrivateKey:i,randomPrivateKey:a,normPrivateKeyToScalar:_=>Xr(e,_),precompute(_=8,I=n.BASE){return I.precompute(_,!1)}},lengths:s})}function wp(n,t,e={}){ru(t),Mn(e,{},{hmac:"function",lowS:"boolean",randomBytes:"function",bits2int:"function",bits2int_modN:"function"});const r=e.randomBytes||Io,s=e.hmac||((c,...f)=>Wu(t,c,Ge(...f))),{Fp:i,Fn:o}=n,{ORDER:a,BITS:l}=o,{keygen:p,getPublicKey:m,getSharedSecret:S,utils:R,lengths:_}=mp(n,e),I={prehash:!1,lowS:typeof e.lowS=="boolean"?e.lowS:!1,format:void 0,extraEntropy:!1},O="compact";function x(c){const f=a>>en;return c>f}function M(c,f){if(!o.isValidNot0(f))throw new Error(`invalid signature ${c}: out of range 1..Point.Fn.ORDER`);return f}function H(c,f){io(f);const E=_.signature,T=f==="compact"?E:f==="recovered"?E+1:void 0;return ze(c,T,`${f} signature`)}class P{constructor(f,E,T){this.r=M("r",f),this.s=M("s",E),T!=null&&(this.recovery=T),Object.freeze(this)}static fromBytes(f,E=O){H(f,E);let T;if(E==="der"){const{r:d,s:u}=ir.toSig(ze(f));return new P(d,u)}E==="recovered"&&(T=f[0],E="compact",f=f.subarray(1));const N=o.BYTES,A=f.subarray(0,N),g=f.subarray(N,N*2);return new P(o.fromBytes(A),o.fromBytes(g),T)}static fromHex(f,E){return this.fromBytes(fi(f),E)}addRecoveryBit(f){return new P(this.r,this.s,f)}recoverPublicKey(f){const E=i.ORDER,{r:T,s:N,recovery:A}=this;if(A==null||![0,1,2,3].includes(A))throw new Error("recovery id invalid");if(a*Gu<E&&A>1)throw new Error("recovery id is ambiguous for h>1 curve");const d=A===2||A===3?T+a:T;if(!i.isValid(d))throw new Error("recovery id 2 or 3 invalid");const u=i.toBytes(d),h=n.fromBytes(Ge(ju((A&1)===0),u)),v=o.inv(d),C=G(jt("msgHash",f)),K=o.create(-C*v),Z=o.create(N*v),it=n.BASE.multiplyUnsafe(K).add(h.multiplyUnsafe(Z));if(it.is0())throw new Error("point at infinify");return it.assertValidity(),it}hasHighS(){return x(this.s)}toBytes(f=O){if(io(f),f==="der")return fi(ir.hexFromSig(this));const E=o.toBytes(this.r),T=o.toBytes(this.s);if(f==="recovered"){if(this.recovery==null)throw new Error("recovery bit must be present");return Ge(Uint8Array.of(this.recovery),E,T)}return Ge(E,T)}toHex(f){return Lr(this.toBytes(f))}assertValidity(){}static fromCompact(f){return P.fromBytes(jt("sig",f),"compact")}static fromDER(f){return P.fromBytes(jt("sig",f),"der")}normalizeS(){return this.hasHighS()?new P(this.r,o.neg(this.s),this.recovery):this}toDERRawBytes(){return this.toBytes("der")}toDERHex(){return Lr(this.toBytes("der"))}toCompactRawBytes(){return this.toBytes("compact")}toCompactHex(){return Lr(this.toBytes("compact"))}}const q=e.bits2int||function(f){if(f.length>8192)throw new Error("input is too large");const E=xi(f),T=f.length*8-l;return T>0?E>>BigInt(T):E},G=e.bits2int_modN||function(f){return o.create(q(f))},J=Bn(l);function Q(c){return no("num < 2^"+l,c,lr,J),o.toBytes(c)}function tt(c,f){return ze(c,void 0,"message"),f?ze(t(c),void 0,"prehashed message"):c}function L(c,f,E){if(["recovered","canonical"].some(K=>K in E))throw new Error("sign() legacy options not supported");const{lowS:T,prehash:N,extraEntropy:A}=Ls(E,I);c=tt(c,N);const g=G(c),d=Xr(o,f),u=[Q(d),Q(g)];if(A!=null&&A!==!1){const K=A===!0?r(_.secretKey):A;u.push(jt("extraEntropy",K))}const h=Ge(...u),v=g;function C(K){const Z=q(K);if(!o.isValidNot0(Z))return;const it=o.inv(Z),ut=n.BASE.multiply(Z).toAffine(),St=o.create(ut.x);if(St===lr)return;const kt=o.create(it*o.create(v+St*d));if(kt===lr)return;let Nt=(ut.x===St?0:2)|Number(ut.y&en),Pe=kt;return T&&x(kt)&&(Pe=o.neg(kt),Nt^=1),new P(St,Pe,Nt)}return{seed:h,k2sig:C}}function U(c,f,E={}){c=jt("message",c);const{seed:T,k2sig:N}=L(c,f,E);return cd(t.outputLen,o.BYTES,s)(T,N)}function F(c){let f;const E=typeof c=="string"||Cn(c),T=!E&&c!==null&&typeof c=="object"&&typeof c.r=="bigint"&&typeof c.s=="bigint";if(!E&&!T)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");if(T)f=new P(c.r,c.s);else if(E){try{f=P.fromBytes(jt("sig",c),"der")}catch(N){if(!(N instanceof ir.Err))throw N}if(!f)try{f=P.fromBytes(jt("sig",c),"compact")}catch{return!1}}return f||!1}function z(c,f,E,T={}){const{lowS:N,prehash:A,format:g}=Ls(T,I);if(E=jt("publicKey",E),f=tt(jt("message",f),A),"strict"in T)throw new Error("options.strict was renamed to lowS");const d=g===void 0?F(c):P.fromBytes(jt("sig",c),g);if(d===!1)return!1;try{const u=n.fromBytes(E);if(N&&d.hasHighS())return!1;const{r:h,s:v}=d,C=G(f),K=o.inv(v),Z=o.create(C*K),it=o.create(h*K),ut=n.BASE.multiplyUnsafe(Z).add(u.multiplyUnsafe(it));return ut.is0()?!1:o.create(ut.x)===h}catch{return!1}}function b(c,f,E={}){const{prehash:T}=Ls(E,I);return f=tt(f,T),P.fromBytes(c,"recovered").recoverPublicKey(f).toBytes()}return Object.freeze({keygen:p,getPublicKey:m,getSharedSecret:S,utils:R,lengths:_,Point:n,sign:U,verify:z,recoverPublicKey:b,Signature:P,hash:t})}function _p(n){const t={a:n.a,b:n.b,p:n.Fp.ORDER,n:n.n,h:n.h,Gx:n.Gx,Gy:n.Gy},e=n.Fp;let r=n.allowedPrivateKeyLengths?Array.from(new Set(n.allowedPrivateKeyLengths.map(o=>Math.ceil(o/2)))):void 0;const s=zr(t.n,{BITS:n.nBitLength,allowedLengths:r,modFromBytes:n.wrapPrivateKey}),i={Fp:e,Fn:s,allowInfinityPoint:n.allowInfinityPoint,endo:n.endo,isTorsionFree:n.isTorsionFree,clearCofactor:n.clearCofactor,fromBytes:n.fromBytes,toBytes:n.toBytes};return{CURVE:t,curveOpts:i}}function bp(n){const{CURVE:t,curveOpts:e}=_p(n),r={hmac:n.hmac,randomBytes:n.randomBytes,lowS:n.lowS,bits2int:n.bits2int,bits2int_modN:n.bits2int_modN};return{CURVE:t,curveOpts:e,hash:n.hash,ecdsaOpts:r}}function Ep(n,t){const e=t.Point;return Object.assign({},t,{ProjectivePoint:e,CURVE:Object.assign({},n,bu(e.Fn.ORDER,e.Fn.BITS))})}function Rp(n){const{CURVE:t,curveOpts:e,hash:r,ecdsaOpts:s}=bp(n),i=gp(t,e),o=wp(i,r,s);return Ep(n,o)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function vp(n,t){const e=r=>Rp({...n,hash:r});return{...e(t),create:e}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Uo={p:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),n:BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),h:BigInt(1),a:BigInt(0),b:BigInt(7),Gx:BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),Gy:BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")},Ap={beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),basises:[[BigInt("0x3086d221a7d46bcde86c90e49284eb15"),-BigInt("0xe4437ed6010e88286f547fa90abfe4c3")],[BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),BigInt("0x3086d221a7d46bcde86c90e49284eb15")]]},Ga=BigInt(2);function Ip(n){const t=Uo.p,e=BigInt(3),r=BigInt(6),s=BigInt(11),i=BigInt(22),o=BigInt(23),a=BigInt(44),l=BigInt(88),p=n*n*n%t,m=p*p*n%t,S=Gt(m,e,t)*m%t,R=Gt(S,e,t)*m%t,_=Gt(R,Ga,t)*p%t,I=Gt(_,s,t)*_%t,O=Gt(I,i,t)*I%t,x=Gt(O,a,t)*O%t,M=Gt(x,l,t)*x%t,H=Gt(M,a,t)*O%t,P=Gt(H,e,t)*m%t,q=Gt(P,o,t)*I%t,G=Gt(q,r,t)*p%t,J=Gt(G,Ga,t);if(!so.eql(so.sqr(J),n))throw new Error("Cannot find square root");return J}const so=zr(Uo.p,{sqrt:Ip}),Do=vp({...Uo,Fp:so,lowS:!0,endo:Ap},cu),Sp=hn.utils.randomPrivateKey,ja=()=>{const n=hn.utils.randomPrivateKey(),t=Ei(n),e=new Uint8Array(64);return e.set(n),e.set(t,32),{publicKey:t,secretKey:e}},Ei=hn.getPublicKey;function Ya(n){try{return hn.ExtendedPoint.fromHex(n),!0}catch{return!1}}const Ho=(n,t)=>hn.sign(n,t.slice(0,32)),kp=hn.verify,bt=n=>ht.Buffer.isBuffer(n)?n:n instanceof Uint8Array?ht.Buffer.from(n.buffer,n.byteOffset,n.byteLength):ht.Buffer.from(n);let Fo=class{constructor(t){Object.assign(this,t)}encode(){return ht.Buffer.from(Ss.serialize(En,this))}static decode(t){return Ss.deserialize(En,this,t)}static decodeUnchecked(t){return Ss.deserializeUnchecked(En,this,t)}};class Tp extends Fo{constructor(t){if(super(t),this.enum="",Object.keys(t).length!==1)throw new Error("Enum can only take single value");Object.keys(t).map(e=>{this.enum=e})}}const En=new Map;var Zu;const Xu=32,Xe=32;function Op(n){return n._bn!==void 0}let Za=1;class rt extends Fo{constructor(t){if(super({}),this._bn=void 0,Op(t))this._bn=t._bn;else{if(typeof t=="string"){const e=be.decode(t);if(e.length!=Xe)throw new Error("Invalid public key input");this._bn=new or(e)}else this._bn=new or(t);if(this._bn.byteLength()>Xe)throw new Error("Invalid public key input")}}static unique(){const t=new rt(Za);return Za+=1,new rt(t.toBuffer())}equals(t){return this._bn.eq(t._bn)}toBase58(){return be.encode(this.toBytes())}toJSON(){return this.toBase58()}toBytes(){const t=this.toBuffer();return new Uint8Array(t.buffer,t.byteOffset,t.byteLength)}toBuffer(){const t=this._bn.toArrayLike(ht.Buffer);if(t.length===Xe)return t;const e=ht.Buffer.alloc(32);return t.copy(e,32-t.length),e}get[Symbol.toStringTag](){return`PublicKey(${this.toString()})`}toString(){return this.toBase58()}static async createWithSeed(t,e,r){const s=ht.Buffer.concat([t.toBuffer(),ht.Buffer.from(e),r.toBuffer()]),i=yi(s);return new rt(i)}static createProgramAddressSync(t,e){let r=ht.Buffer.alloc(0);t.forEach(function(i){if(i.length>Xu)throw new TypeError("Max seed length exceeded");r=ht.Buffer.concat([r,bt(i)])}),r=ht.Buffer.concat([r,e.toBuffer(),ht.Buffer.from("ProgramDerivedAddress")]);const s=yi(r);if(Ya(s))throw new Error("Invalid seeds, address must fall off the curve");return new rt(s)}static async createProgramAddress(t,e){return this.createProgramAddressSync(t,e)}static findProgramAddressSync(t,e){let r=255,s;for(;r!=0;){try{const i=t.concat(ht.Buffer.from([r]));s=this.createProgramAddressSync(i,e)}catch(i){if(i instanceof TypeError)throw i;r--;continue}return[s,r]}throw new Error("Unable to find a viable program address nonce")}static async findProgramAddress(t,e){return this.findProgramAddressSync(t,e)}static isOnCurve(t){const e=new rt(t);return Ya(e.toBytes())}}Zu=rt;rt.default=new Zu("11111111111111111111111111111111");En.set(rt,{kind:"struct",fields:[["_bn","u256"]]});class xp{constructor(t){if(this._publicKey=void 0,this._secretKey=void 0,t){const e=bt(t);if(t.length!==64)throw new Error("bad secret key size");this._publicKey=e.slice(32,64),this._secretKey=e.slice(0,32)}else this._secretKey=bt(Sp()),this._publicKey=bt(Ei(this._secretKey))}get publicKey(){return new rt(this._publicKey)}get secretKey(){return ht.Buffer.concat([this._secretKey,this._publicKey],64)}}const Np=new rt("BPFLoader1111111111111111111111111111111111"),Er=1232,Li=127,Sn=64;class zo extends Error{constructor(t){super(`Signature ${t} has expired: block height exceeded.`),this.signature=void 0,this.signature=t}}Object.defineProperty(zo.prototype,"name",{value:"TransactionExpiredBlockheightExceededError"});class Ko extends Error{constructor(t,e){super(`Transaction was not confirmed in ${e.toFixed(2)} seconds. It is unknown if it succeeded or failed. Check signature ${t} using the Solana Explorer or CLI tools.`),this.signature=void 0,this.signature=t}}Object.defineProperty(Ko.prototype,"name",{value:"TransactionExpiredTimeoutError"});class Jr extends Error{constructor(t){super(`Signature ${t} has expired: the nonce is no longer valid.`),this.signature=void 0,this.signature=t}}Object.defineProperty(Jr.prototype,"name",{value:"TransactionExpiredNonceInvalidError"});class kn{constructor(t,e){this.staticAccountKeys=void 0,this.accountKeysFromLookups=void 0,this.staticAccountKeys=t,this.accountKeysFromLookups=e}keySegments(){const t=[this.staticAccountKeys];return this.accountKeysFromLookups&&(t.push(this.accountKeysFromLookups.writable),t.push(this.accountKeysFromLookups.readonly)),t}get(t){for(const e of this.keySegments()){if(t<e.length)return e[t];t-=e.length}}get length(){return this.keySegments().flat().length}compileInstructions(t){if(this.length>256)throw new Error("Account index overflow encountered during compilation");const r=new Map;this.keySegments().flat().forEach((i,o)=>{r.set(i.toBase58(),o)});const s=i=>{const o=r.get(i.toBase58());if(o===void 0)throw new Error("Encountered an unknown instruction account key during compilation");return o};return t.map(i=>({programIdIndex:s(i.programId),accountKeyIndexes:i.keys.map(o=>s(o.pubkey)),data:i.data}))}}const Et=(n="publicKey")=>D.blob(32,n),Cp=(n="signature")=>D.blob(64,n),Cr=(n="string")=>{const t=D.struct([D.u32("length"),D.u32("lengthPadding"),D.blob(D.offset(D.u32(),-8),"chars")],n),e=t.decode.bind(t),r=t.encode.bind(t),s=t;return s.decode=(i,o)=>e(i,o).chars.toString(),s.encode=(i,o,a)=>{const l={chars:ht.Buffer.from(i,"utf8")};return r(l,o,a)},s.alloc=i=>D.u32().span+D.u32().span+ht.Buffer.from(i,"utf8").length,s},Bp=(n="authorized")=>D.struct([Et("staker"),Et("withdrawer")],n),Mp=(n="lockup")=>D.struct([D.ns64("unixTimestamp"),D.ns64("epoch"),Et("custodian")],n),Lp=(n="voteInit")=>D.struct([Et("nodePubkey"),Et("authorizedVoter"),Et("authorizedWithdrawer"),D.u8("commission")],n),Pp=(n="voteAuthorizeWithSeedArgs")=>D.struct([D.u32("voteAuthorizationType"),Et("currentAuthorityDerivedKeyOwnerPubkey"),Cr("currentAuthorityDerivedKeySeed"),Et("newAuthorized")],n);function Ju(n,t){const e=s=>{if(s.span>=0)return s.span;if(typeof s.alloc=="function")return s.alloc(t[s.property]);if("count"in s&&"elementLayout"in s){const i=t[s.property];if(Array.isArray(i))return i.length*e(s.elementLayout)}else if("fields"in s)return Ju({layout:s},t[s.property]);return 0};let r=0;return n.layout.fields.forEach(s=>{r+=e(s)}),r}function Te(n){let t=0,e=0;for(;;){let r=n.shift();if(t|=(r&127)<<e*7,e+=1,(r&128)===0)break}return t}function Me(n,t){let e=t;for(;;){let r=e&127;if(e>>=7,e==0){n.push(r);break}else r|=128,n.push(r)}}function It(n,t){if(!n)throw new Error(t||"Assertion failed")}class Pi{constructor(t,e){this.payer=void 0,this.keyMetaMap=void 0,this.payer=t,this.keyMetaMap=e}static compile(t,e){const r=new Map,s=o=>{const a=o.toBase58();let l=r.get(a);return l===void 0&&(l={isSigner:!1,isWritable:!1,isInvoked:!1},r.set(a,l)),l},i=s(e);i.isSigner=!0,i.isWritable=!0;for(const o of t){s(o.programId).isInvoked=!0;for(const a of o.keys){const l=s(a.pubkey);l.isSigner||(l.isSigner=a.isSigner),l.isWritable||(l.isWritable=a.isWritable)}}return new Pi(e,r)}getMessageComponents(){const t=[...this.keyMetaMap.entries()];It(t.length<=256,"Max static account keys length exceeded");const e=t.filter(([,l])=>l.isSigner&&l.isWritable),r=t.filter(([,l])=>l.isSigner&&!l.isWritable),s=t.filter(([,l])=>!l.isSigner&&l.isWritable),i=t.filter(([,l])=>!l.isSigner&&!l.isWritable),o={numRequiredSignatures:e.length+r.length,numReadonlySignedAccounts:r.length,numReadonlyUnsignedAccounts:i.length};{It(e.length>0,"Expected at least one writable signer key");const[l]=e[0];It(l===this.payer.toBase58(),"Expected first writable signer key to be the fee payer")}const a=[...e.map(([l])=>new rt(l)),...r.map(([l])=>new rt(l)),...s.map(([l])=>new rt(l)),...i.map(([l])=>new rt(l))];return[o,a]}extractTableLookup(t){const[e,r]=this.drainKeysFoundInLookupTable(t.state.addresses,o=>!o.isSigner&&!o.isInvoked&&o.isWritable),[s,i]=this.drainKeysFoundInLookupTable(t.state.addresses,o=>!o.isSigner&&!o.isInvoked&&!o.isWritable);if(!(e.length===0&&s.length===0))return[{accountKey:t.key,writableIndexes:e,readonlyIndexes:s},{writable:r,readonly:i}]}drainKeysFoundInLookupTable(t,e){const r=new Array,s=new Array;for(const[i,o]of this.keyMetaMap.entries())if(e(o)){const a=new rt(i),l=t.findIndex(p=>p.equals(a));l>=0&&(It(l<256,"Max lookup table index exceeded"),r.push(l),s.push(a),this.keyMetaMap.delete(i))}return[r,s]}}const Qu="Reached end of buffer unexpectedly";function je(n){if(n.length===0)throw new Error(Qu);return n.shift()}function Oe(n,...t){const[e]=t;if(t.length===2?e+(t[1]??0)>n.length:e>=n.length)throw new Error(Qu);return n.splice(...t)}class qe{constructor(t){this.header=void 0,this.accountKeys=void 0,this.recentBlockhash=void 0,this.instructions=void 0,this.indexToProgramIds=new Map,this.header=t.header,this.accountKeys=t.accountKeys.map(e=>new rt(e)),this.recentBlockhash=t.recentBlockhash,this.instructions=t.instructions,this.instructions.forEach(e=>this.indexToProgramIds.set(e.programIdIndex,this.accountKeys[e.programIdIndex]))}get version(){return"legacy"}get staticAccountKeys(){return this.accountKeys}get compiledInstructions(){return this.instructions.map(t=>({programIdIndex:t.programIdIndex,accountKeyIndexes:t.accounts,data:be.decode(t.data)}))}get addressTableLookups(){return[]}getAccountKeys(){return new kn(this.staticAccountKeys)}static compile(t){const e=Pi.compile(t.instructions,t.payerKey),[r,s]=e.getMessageComponents(),o=new kn(s).compileInstructions(t.instructions).map(a=>({programIdIndex:a.programIdIndex,accounts:a.accountKeyIndexes,data:be.encode(a.data)}));return new qe({header:r,accountKeys:s,recentBlockhash:t.recentBlockhash,instructions:o})}isAccountSigner(t){return t<this.header.numRequiredSignatures}isAccountWritable(t){const e=this.header.numRequiredSignatures;if(t>=this.header.numRequiredSignatures){const r=t-e,i=this.accountKeys.length-e-this.header.numReadonlyUnsignedAccounts;return r<i}else{const r=e-this.header.numReadonlySignedAccounts;return t<r}}isProgramId(t){return this.indexToProgramIds.has(t)}programIds(){return[...this.indexToProgramIds.values()]}nonProgramIds(){return this.accountKeys.filter((t,e)=>!this.isProgramId(e))}serialize(){const t=this.accountKeys.length;let e=[];Me(e,t);const r=this.instructions.map(S=>{const{accounts:R,programIdIndex:_}=S,I=Array.from(be.decode(S.data));let O=[];Me(O,R.length);let x=[];return Me(x,I.length),{programIdIndex:_,keyIndicesCount:ht.Buffer.from(O),keyIndices:R,dataLength:ht.Buffer.from(x),data:I}});let s=[];Me(s,r.length);let i=ht.Buffer.alloc(Er);ht.Buffer.from(s).copy(i);let o=s.length;r.forEach(S=>{const _=D.struct([D.u8("programIdIndex"),D.blob(S.keyIndicesCount.length,"keyIndicesCount"),D.seq(D.u8("keyIndex"),S.keyIndices.length,"keyIndices"),D.blob(S.dataLength.length,"dataLength"),D.seq(D.u8("userdatum"),S.data.length,"data")]).encode(S,i,o);o+=_}),i=i.slice(0,o);const a=D.struct([D.blob(1,"numRequiredSignatures"),D.blob(1,"numReadonlySignedAccounts"),D.blob(1,"numReadonlyUnsignedAccounts"),D.blob(e.length,"keyCount"),D.seq(Et("key"),t,"keys"),Et("recentBlockhash")]),l={numRequiredSignatures:ht.Buffer.from([this.header.numRequiredSignatures]),numReadonlySignedAccounts:ht.Buffer.from([this.header.numReadonlySignedAccounts]),numReadonlyUnsignedAccounts:ht.Buffer.from([this.header.numReadonlyUnsignedAccounts]),keyCount:ht.Buffer.from(e),keys:this.accountKeys.map(S=>bt(S.toBytes())),recentBlockhash:be.decode(this.recentBlockhash)};let p=ht.Buffer.alloc(2048);const m=a.encode(l,p);return i.copy(p,m),p.slice(0,m+i.length)}static from(t){let e=[...t];const r=je(e);if(r!==(r&Li))throw new Error("Versioned messages must be deserialized with VersionedMessage.deserialize()");const s=je(e),i=je(e),o=Te(e);let a=[];for(let R=0;R<o;R++){const _=Oe(e,0,Xe);a.push(new rt(ht.Buffer.from(_)))}const l=Oe(e,0,Xe),p=Te(e);let m=[];for(let R=0;R<p;R++){const _=je(e),I=Te(e),O=Oe(e,0,I),x=Te(e),M=Oe(e,0,x),H=be.encode(ht.Buffer.from(M));m.push({programIdIndex:_,accounts:O,data:H})}const S={header:{numRequiredSignatures:r,numReadonlySignedAccounts:s,numReadonlyUnsignedAccounts:i},recentBlockhash:be.encode(ht.Buffer.from(l)),accountKeys:a,instructions:m};return new qe(S)}}class Ur{constructor(t){this.header=void 0,this.staticAccountKeys=void 0,this.recentBlockhash=void 0,this.compiledInstructions=void 0,this.addressTableLookups=void 0,this.header=t.header,this.staticAccountKeys=t.staticAccountKeys,this.recentBlockhash=t.recentBlockhash,this.compiledInstructions=t.compiledInstructions,this.addressTableLookups=t.addressTableLookups}get version(){return 0}get numAccountKeysFromLookups(){let t=0;for(const e of this.addressTableLookups)t+=e.readonlyIndexes.length+e.writableIndexes.length;return t}getAccountKeys(t){let e;if(t&&"accountKeysFromLookups"in t&&t.accountKeysFromLookups){if(this.numAccountKeysFromLookups!=t.accountKeysFromLookups.writable.length+t.accountKeysFromLookups.readonly.length)throw new Error("Failed to get account keys because of a mismatch in the number of account keys from lookups");e=t.accountKeysFromLookups}else if(t&&"addressLookupTableAccounts"in t&&t.addressLookupTableAccounts)e=this.resolveAddressTableLookups(t.addressLookupTableAccounts);else if(this.addressTableLookups.length>0)throw new Error("Failed to get account keys because address table lookups were not resolved");return new kn(this.staticAccountKeys,e)}isAccountSigner(t){return t<this.header.numRequiredSignatures}isAccountWritable(t){const e=this.header.numRequiredSignatures,r=this.staticAccountKeys.length;if(t>=r){const s=t-r,i=this.addressTableLookups.reduce((o,a)=>o+a.writableIndexes.length,0);return s<i}else if(t>=this.header.numRequiredSignatures){const s=t-e,o=r-e-this.header.numReadonlyUnsignedAccounts;return s<o}else{const s=e-this.header.numReadonlySignedAccounts;return t<s}}resolveAddressTableLookups(t){const e={writable:[],readonly:[]};for(const r of this.addressTableLookups){const s=t.find(i=>i.key.equals(r.accountKey));if(!s)throw new Error(`Failed to find address lookup table account for table key ${r.accountKey.toBase58()}`);for(const i of r.writableIndexes)if(i<s.state.addresses.length)e.writable.push(s.state.addresses[i]);else throw new Error(`Failed to find address for index ${i} in address lookup table ${r.accountKey.toBase58()}`);for(const i of r.readonlyIndexes)if(i<s.state.addresses.length)e.readonly.push(s.state.addresses[i]);else throw new Error(`Failed to find address for index ${i} in address lookup table ${r.accountKey.toBase58()}`)}return e}static compile(t){const e=Pi.compile(t.instructions,t.payerKey),r=new Array,s={writable:new Array,readonly:new Array},i=t.addressLookupTableAccounts||[];for(const m of i){const S=e.extractTableLookup(m);if(S!==void 0){const[R,{writable:_,readonly:I}]=S;r.push(R),s.writable.push(..._),s.readonly.push(...I)}}const[o,a]=e.getMessageComponents(),p=new kn(a,s).compileInstructions(t.instructions);return new Ur({header:o,staticAccountKeys:a,recentBlockhash:t.recentBlockhash,compiledInstructions:p,addressTableLookups:r})}serialize(){const t=Array();Me(t,this.staticAccountKeys.length);const e=this.serializeInstructions(),r=Array();Me(r,this.compiledInstructions.length);const s=this.serializeAddressTableLookups(),i=Array();Me(i,this.addressTableLookups.length);const o=D.struct([D.u8("prefix"),D.struct([D.u8("numRequiredSignatures"),D.u8("numReadonlySignedAccounts"),D.u8("numReadonlyUnsignedAccounts")],"header"),D.blob(t.length,"staticAccountKeysLength"),D.seq(Et(),this.staticAccountKeys.length,"staticAccountKeys"),Et("recentBlockhash"),D.blob(r.length,"instructionsLength"),D.blob(e.length,"serializedInstructions"),D.blob(i.length,"addressTableLookupsLength"),D.blob(s.length,"serializedAddressTableLookups")]),a=new Uint8Array(Er),p=o.encode({prefix:128,header:this.header,staticAccountKeysLength:new Uint8Array(t),staticAccountKeys:this.staticAccountKeys.map(m=>m.toBytes()),recentBlockhash:be.decode(this.recentBlockhash),instructionsLength:new Uint8Array(r),serializedInstructions:e,addressTableLookupsLength:new Uint8Array(i),serializedAddressTableLookups:s},a);return a.slice(0,p)}serializeInstructions(){let t=0;const e=new Uint8Array(Er);for(const r of this.compiledInstructions){const s=Array();Me(s,r.accountKeyIndexes.length);const i=Array();Me(i,r.data.length);const o=D.struct([D.u8("programIdIndex"),D.blob(s.length,"encodedAccountKeyIndexesLength"),D.seq(D.u8(),r.accountKeyIndexes.length,"accountKeyIndexes"),D.blob(i.length,"encodedDataLength"),D.blob(r.data.length,"data")]);t+=o.encode({programIdIndex:r.programIdIndex,encodedAccountKeyIndexesLength:new Uint8Array(s),accountKeyIndexes:r.accountKeyIndexes,encodedDataLength:new Uint8Array(i),data:r.data},e,t)}return e.slice(0,t)}serializeAddressTableLookups(){let t=0;const e=new Uint8Array(Er);for(const r of this.addressTableLookups){const s=Array();Me(s,r.writableIndexes.length);const i=Array();Me(i,r.readonlyIndexes.length);const o=D.struct([Et("accountKey"),D.blob(s.length,"encodedWritableIndexesLength"),D.seq(D.u8(),r.writableIndexes.length,"writableIndexes"),D.blob(i.length,"encodedReadonlyIndexesLength"),D.seq(D.u8(),r.readonlyIndexes.length,"readonlyIndexes")]);t+=o.encode({accountKey:r.accountKey.toBytes(),encodedWritableIndexesLength:new Uint8Array(s),writableIndexes:r.writableIndexes,encodedReadonlyIndexesLength:new Uint8Array(i),readonlyIndexes:r.readonlyIndexes},e,t)}return e.slice(0,t)}static deserialize(t){let e=[...t];const r=je(e),s=r&Li;It(r!==s,"Expected versioned message but received legacy message");const i=s;It(i===0,`Expected versioned message with version 0 but found version ${i}`);const o={numRequiredSignatures:je(e),numReadonlySignedAccounts:je(e),numReadonlyUnsignedAccounts:je(e)},a=[],l=Te(e);for(let I=0;I<l;I++)a.push(new rt(Oe(e,0,Xe)));const p=be.encode(Oe(e,0,Xe)),m=Te(e),S=[];for(let I=0;I<m;I++){const O=je(e),x=Te(e),M=Oe(e,0,x),H=Te(e),P=new Uint8Array(Oe(e,0,H));S.push({programIdIndex:O,accountKeyIndexes:M,data:P})}const R=Te(e),_=[];for(let I=0;I<R;I++){const O=new rt(Oe(e,0,Xe)),x=Te(e),M=Oe(e,0,x),H=Te(e),P=Oe(e,0,H);_.push({accountKey:O,writableIndexes:M,readonlyIndexes:P})}return new Ur({header:o,staticAccountKeys:a,recentBlockhash:p,compiledInstructions:S,addressTableLookups:_})}}const qo={deserializeMessageVersion(n){const t=n[0],e=t&Li;return e===t?"legacy":e},deserialize:n=>{const t=qo.deserializeMessageVersion(n);if(t==="legacy")return qe.from(n);if(t===0)return Ur.deserialize(n);throw new Error(`Transaction message version ${t} deserialization is not supported`)}};let nr=(function(n){return n[n.BLOCKHEIGHT_EXCEEDED=0]="BLOCKHEIGHT_EXCEEDED",n[n.PROCESSED=1]="PROCESSED",n[n.TIMED_OUT=2]="TIMED_OUT",n[n.NONCE_INVALID=3]="NONCE_INVALID",n})({});const Up=ht.Buffer.alloc(Sn).fill(0);class xt{constructor(t){this.keys=void 0,this.programId=void 0,this.data=ht.Buffer.alloc(0),this.programId=t.programId,this.keys=t.keys,t.data&&(this.data=t.data)}toJSON(){return{keys:this.keys.map(({pubkey:t,isSigner:e,isWritable:r})=>({pubkey:t.toJSON(),isSigner:e,isWritable:r})),programId:this.programId.toJSON(),data:[...this.data]}}}class At{get signature(){return this.signatures.length>0?this.signatures[0].signature:null}constructor(t){if(this.signatures=[],this.feePayer=void 0,this.instructions=[],this.recentBlockhash=void 0,this.lastValidBlockHeight=void 0,this.nonceInfo=void 0,this.minNonceContextSlot=void 0,this._message=void 0,this._json=void 0,!!t)if(t.feePayer&&(this.feePayer=t.feePayer),t.signatures&&(this.signatures=t.signatures),Object.prototype.hasOwnProperty.call(t,"nonceInfo")){const{minContextSlot:e,nonceInfo:r}=t;this.minNonceContextSlot=e,this.nonceInfo=r}else if(Object.prototype.hasOwnProperty.call(t,"lastValidBlockHeight")){const{blockhash:e,lastValidBlockHeight:r}=t;this.recentBlockhash=e,this.lastValidBlockHeight=r}else{const{recentBlockhash:e,nonceInfo:r}=t;r&&(this.nonceInfo=r),this.recentBlockhash=e}}toJSON(){return{recentBlockhash:this.recentBlockhash||null,feePayer:this.feePayer?this.feePayer.toJSON():null,nonceInfo:this.nonceInfo?{nonce:this.nonceInfo.nonce,nonceInstruction:this.nonceInfo.nonceInstruction.toJSON()}:null,instructions:this.instructions.map(t=>t.toJSON()),signers:this.signatures.map(({publicKey:t})=>t.toJSON())}}add(...t){if(t.length===0)throw new Error("No instructions");return t.forEach(e=>{"instructions"in e?this.instructions=this.instructions.concat(e.instructions):"data"in e&&"programId"in e&&"keys"in e?this.instructions.push(e):this.instructions.push(new xt(e))}),this}compileMessage(){if(this._message&&JSON.stringify(this.toJSON())===JSON.stringify(this._json))return this._message;let t,e;if(this.nonceInfo?(t=this.nonceInfo.nonce,this.instructions[0]!=this.nonceInfo.nonceInstruction?e=[this.nonceInfo.nonceInstruction,...this.instructions]:e=this.instructions):(t=this.recentBlockhash,e=this.instructions),!t)throw new Error("Transaction recentBlockhash required");e.length<1&&console.warn("No instructions provided");let r;if(this.feePayer)r=this.feePayer;else if(this.signatures.length>0&&this.signatures[0].publicKey)r=this.signatures[0].publicKey;else throw new Error("Transaction fee payer required");for(let O=0;O<e.length;O++)if(e[O].programId===void 0)throw new Error(`Transaction instruction index ${O} has undefined program id`);const s=[],i=[];e.forEach(O=>{O.keys.forEach(M=>{i.push({...M})});const x=O.programId.toString();s.includes(x)||s.push(x)}),s.forEach(O=>{i.push({pubkey:new rt(O),isSigner:!1,isWritable:!1})});const o=[];i.forEach(O=>{const x=O.pubkey.toString(),M=o.findIndex(H=>H.pubkey.toString()===x);M>-1?(o[M].isWritable=o[M].isWritable||O.isWritable,o[M].isSigner=o[M].isSigner||O.isSigner):o.push(O)}),o.sort(function(O,x){if(O.isSigner!==x.isSigner)return O.isSigner?-1:1;if(O.isWritable!==x.isWritable)return O.isWritable?-1:1;const M={localeMatcher:"best fit",usage:"sort",sensitivity:"variant",ignorePunctuation:!1,numeric:!1,caseFirst:"lower"};return O.pubkey.toBase58().localeCompare(x.pubkey.toBase58(),"en",M)});const a=o.findIndex(O=>O.pubkey.equals(r));if(a>-1){const[O]=o.splice(a,1);O.isSigner=!0,O.isWritable=!0,o.unshift(O)}else o.unshift({pubkey:r,isSigner:!0,isWritable:!0});for(const O of this.signatures){const x=o.findIndex(M=>M.pubkey.equals(O.publicKey));if(x>-1)o[x].isSigner||(o[x].isSigner=!0,console.warn("Transaction references a signature that is unnecessary, only the fee payer and instruction signer accounts should sign a transaction. This behavior is deprecated and will throw an error in the next major version release."));else throw new Error(`unknown signer: ${O.publicKey.toString()}`)}let l=0,p=0,m=0;const S=[],R=[];o.forEach(({pubkey:O,isSigner:x,isWritable:M})=>{x?(S.push(O.toString()),l+=1,M||(p+=1)):(R.push(O.toString()),M||(m+=1))});const _=S.concat(R),I=e.map(O=>{const{data:x,programId:M}=O;return{programIdIndex:_.indexOf(M.toString()),accounts:O.keys.map(H=>_.indexOf(H.pubkey.toString())),data:be.encode(x)}});return I.forEach(O=>{It(O.programIdIndex>=0),O.accounts.forEach(x=>It(x>=0))}),new qe({header:{numRequiredSignatures:l,numReadonlySignedAccounts:p,numReadonlyUnsignedAccounts:m},accountKeys:_,recentBlockhash:t,instructions:I})}_compile(){const t=this.compileMessage(),e=t.accountKeys.slice(0,t.header.numRequiredSignatures);return this.signatures.length===e.length&&this.signatures.every((s,i)=>e[i].equals(s.publicKey))||(this.signatures=e.map(r=>({signature:null,publicKey:r}))),t}serializeMessage(){return this._compile().serialize()}async getEstimatedFee(t){return(await t.getFeeForMessage(this.compileMessage())).value}setSigners(...t){if(t.length===0)throw new Error("No signers");const e=new Set;this.signatures=t.filter(r=>{const s=r.toString();return e.has(s)?!1:(e.add(s),!0)}).map(r=>({signature:null,publicKey:r}))}sign(...t){if(t.length===0)throw new Error("No signers");const e=new Set,r=[];for(const i of t){const o=i.publicKey.toString();e.has(o)||(e.add(o),r.push(i))}this.signatures=r.map(i=>({signature:null,publicKey:i.publicKey}));const s=this._compile();this._partialSign(s,...r)}partialSign(...t){if(t.length===0)throw new Error("No signers");const e=new Set,r=[];for(const i of t){const o=i.publicKey.toString();e.has(o)||(e.add(o),r.push(i))}const s=this._compile();this._partialSign(s,...r)}_partialSign(t,...e){const r=t.serialize();e.forEach(s=>{const i=Ho(r,s.secretKey);this._addSignature(s.publicKey,bt(i))})}addSignature(t,e){this._compile(),this._addSignature(t,e)}_addSignature(t,e){It(e.length===64);const r=this.signatures.findIndex(s=>t.equals(s.publicKey));if(r<0)throw new Error(`unknown signer: ${t.toString()}`);this.signatures[r].signature=ht.Buffer.from(e)}verifySignatures(t=!0){return!this._getMessageSignednessErrors(this.serializeMessage(),t)}_getMessageSignednessErrors(t,e){const r={};for(const{signature:s,publicKey:i}of this.signatures)s===null?e&&(r.missing||(r.missing=[])).push(i):kp(s,t,i.toBytes())||(r.invalid||(r.invalid=[])).push(i);return r.invalid||r.missing?r:void 0}serialize(t){const{requireAllSignatures:e,verifySignatures:r}=Object.assign({requireAllSignatures:!0,verifySignatures:!0},t),s=this.serializeMessage();if(r){const i=this._getMessageSignednessErrors(s,e);if(i){let o="Signature verification failed.";throw i.invalid&&(o+=`
Invalid signature for public key${i.invalid.length===1?"":"(s)"} [\`${i.invalid.map(a=>a.toBase58()).join("`, `")}\`].`),i.missing&&(o+=`
Missing signature for public key${i.missing.length===1?"":"(s)"} [\`${i.missing.map(a=>a.toBase58()).join("`, `")}\`].`),new Error(o)}}return this._serialize(s)}_serialize(t){const{signatures:e}=this,r=[];Me(r,e.length);const s=r.length+e.length*64+t.length,i=ht.Buffer.alloc(s);return It(e.length<256),ht.Buffer.from(r).copy(i,0),e.forEach(({signature:o},a)=>{o!==null&&(It(o.length===64,"signature has invalid length"),ht.Buffer.from(o).copy(i,r.length+a*64))}),t.copy(i,r.length+e.length*64),It(i.length<=Er,`Transaction too large: ${i.length} > ${Er}`),i}get keys(){return It(this.instructions.length===1),this.instructions[0].keys.map(t=>t.pubkey)}get programId(){return It(this.instructions.length===1),this.instructions[0].programId}get data(){return It(this.instructions.length===1),this.instructions[0].data}static from(t){let e=[...t];const r=Te(e);let s=[];for(let i=0;i<r;i++){const o=Oe(e,0,Sn);s.push(be.encode(ht.Buffer.from(o)))}return At.populate(qe.from(e),s)}static populate(t,e=[]){const r=new At;return r.recentBlockhash=t.recentBlockhash,t.header.numRequiredSignatures>0&&(r.feePayer=t.accountKeys[0]),e.forEach((s,i)=>{const o={signature:s==be.encode(Up)?null:be.decode(s),publicKey:t.accountKeys[i]};r.signatures.push(o)}),t.instructions.forEach(s=>{const i=s.accounts.map(o=>{const a=t.accountKeys[o];return{pubkey:a,isSigner:r.signatures.some(l=>l.publicKey.toString()===a.toString())||t.isAccountSigner(o),isWritable:t.isAccountWritable(o)}});r.instructions.push(new xt({keys:i,programId:t.accountKeys[s.programIdIndex],data:be.decode(s.data)}))}),r._message=t,r._json=r.toJSON(),r}}class $o{constructor(t){this.payerKey=void 0,this.instructions=void 0,this.recentBlockhash=void 0,this.payerKey=t.payerKey,this.instructions=t.instructions,this.recentBlockhash=t.recentBlockhash}static decompile(t,e){const{header:r,compiledInstructions:s,recentBlockhash:i}=t,{numRequiredSignatures:o,numReadonlySignedAccounts:a,numReadonlyUnsignedAccounts:l}=r,p=o-a;It(p>0,"Message header is invalid");const m=t.staticAccountKeys.length-o-l;It(m>=0,"Message header is invalid");const S=t.getAccountKeys(e),R=S.get(0);if(R===void 0)throw new Error("Failed to decompile message because no account keys were found");const _=[];for(const I of s){const O=[];for(const M of I.accountKeyIndexes){const H=S.get(M);if(H===void 0)throw new Error(`Failed to find key for account key index ${M}`);const P=M<o;let q;P?q=M<p:M<S.staticAccountKeys.length?q=M-o<m:q=M-S.staticAccountKeys.length<S.accountKeysFromLookups.writable.length,O.push({pubkey:H,isSigner:M<r.numRequiredSignatures,isWritable:q})}const x=S.get(I.programIdIndex);if(x===void 0)throw new Error(`Failed to find program id for program id index ${I.programIdIndex}`);_.push(new xt({programId:x,data:bt(I.data),keys:O}))}return new $o({payerKey:R,instructions:_,recentBlockhash:i})}compileToLegacyMessage(){return qe.compile({payerKey:this.payerKey,recentBlockhash:this.recentBlockhash,instructions:this.instructions})}compileToV0Message(t){return Ur.compile({payerKey:this.payerKey,recentBlockhash:this.recentBlockhash,instructions:this.instructions,addressLookupTableAccounts:t})}}class Vo{get version(){return this.message.version}constructor(t,e){if(this.signatures=void 0,this.message=void 0,e!==void 0)It(e.length===t.header.numRequiredSignatures,"Expected signatures length to be equal to the number of required signatures"),this.signatures=e;else{const r=[];for(let s=0;s<t.header.numRequiredSignatures;s++)r.push(new Uint8Array(Sn));this.signatures=r}this.message=t}serialize(){const t=this.message.serialize(),e=Array();Me(e,this.signatures.length);const r=D.struct([D.blob(e.length,"encodedSignaturesLength"),D.seq(Cp(),this.signatures.length,"signatures"),D.blob(t.length,"serializedMessage")]),s=new Uint8Array(2048),i=r.encode({encodedSignaturesLength:new Uint8Array(e),signatures:this.signatures,serializedMessage:t},s);return s.slice(0,i)}static deserialize(t){let e=[...t];const r=[],s=Te(e);for(let o=0;o<s;o++)r.push(new Uint8Array(Oe(e,0,Sn)));const i=qo.deserialize(new Uint8Array(e));return new Vo(i,r)}sign(t){const e=this.message.serialize(),r=this.message.staticAccountKeys.slice(0,this.message.header.numRequiredSignatures);for(const s of t){const i=r.findIndex(o=>o.equals(s.publicKey));It(i>=0,`Cannot sign with non signer key ${s.publicKey.toBase58()}`),this.signatures[i]=Ho(e,s.secretKey)}}addSignature(t,e){It(e.byteLength===64,"Signature must be 64 bytes long");const s=this.message.staticAccountKeys.slice(0,this.message.header.numRequiredSignatures).findIndex(i=>i.equals(t));It(s>=0,`Can not add signature; \`${t.toBase58()}\` is not required to sign this transaction`),this.signatures[s]=e}}const Dp=160,Hp=64,Fp=Dp/Hp,tl=1e3/Fp,We=new rt("SysvarC1ock11111111111111111111111111111111"),zp=new rt("SysvarEpochSchedu1e111111111111111111111111"),Kp=new rt("Sysvar1nstructions1111111111111111111111111"),ci=new rt("SysvarRecentB1ockHashes11111111111111111111"),un=new rt("SysvarRent111111111111111111111111111111111"),qp=new rt("SysvarRewards111111111111111111111111111111"),$p=new rt("SysvarS1otHashes111111111111111111111111111"),Vp=new rt("SysvarS1otHistory11111111111111111111111111"),ui=new rt("SysvarStakeHistory1111111111111111111111111");class Ar extends Error{constructor({action:t,signature:e,transactionMessage:r,logs:s}){const i=s?`Logs: 
${JSON.stringify(s.slice(-10),null,2)}. `:"",o="\nCatch the `SendTransactionError` and call `getLogs()` on it for full details.";let a;switch(t){case"send":a=`Transaction ${e} resulted in an error. 
${r}. `+i+o;break;case"simulate":a=`Simulation failed. 
Message: ${r}. 
`+i+o;break;default:a=`Unknown action '${(l=>l)(t)}'`}super(a),this.signature=void 0,this.transactionMessage=void 0,this.transactionLogs=void 0,this.signature=e,this.transactionMessage=r,this.transactionLogs=s||void 0}get transactionError(){return{message:this.transactionMessage,logs:Array.isArray(this.transactionLogs)?this.transactionLogs:void 0}}get logs(){const t=this.transactionLogs;if(!(t!=null&&typeof t=="object"&&"then"in t))return t}async getLogs(t){return Array.isArray(this.transactionLogs)||(this.transactionLogs=new Promise((e,r)=>{t.getTransaction(this.signature).then(s=>{if(s&&s.meta&&s.meta.logMessages){const i=s.meta.logMessages;this.transactionLogs=i,e(i)}else r(new Error("Log messages not found"))}).catch(r)})),await this.transactionLogs}}const Wp={JSON_RPC_SERVER_ERROR_BLOCK_CLEANED_UP:-32001,JSON_RPC_SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE:-32002,JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE:-32003,JSON_RPC_SERVER_ERROR_BLOCK_NOT_AVAILABLE:-32004,JSON_RPC_SERVER_ERROR_NODE_UNHEALTHY:-32005,JSON_RPC_SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE:-32006,JSON_RPC_SERVER_ERROR_SLOT_SKIPPED:-32007,JSON_RPC_SERVER_ERROR_NO_SNAPSHOT:-32008,JSON_RPC_SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED:-32009,JSON_RPC_SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX:-32010,JSON_RPC_SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE:-32011,JSON_RPC_SCAN_ERROR:-32012,JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH:-32013,JSON_RPC_SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET:-32014,JSON_RPC_SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION:-32015,JSON_RPC_SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED:-32016};class ft extends Error{constructor({code:t,message:e,data:r},s){super(s!=null?`${s}: ${e}`:e),this.code=void 0,this.data=void 0,this.code=t,this.data=r,this.name="SolanaJSONRPCError"}}async function oo(n,t,e,r){const s=r&&{skipPreflight:r.skipPreflight,preflightCommitment:r.preflightCommitment||r.commitment,maxRetries:r.maxRetries,minContextSlot:r.minContextSlot},i=await n.sendTransaction(t,e,s);let o;if(t.recentBlockhash!=null&&t.lastValidBlockHeight!=null)o=(await n.confirmTransaction({abortSignal:r?.abortSignal,signature:i,blockhash:t.recentBlockhash,lastValidBlockHeight:t.lastValidBlockHeight},r&&r.commitment)).value;else if(t.minNonceContextSlot!=null&&t.nonceInfo!=null){const{nonceInstruction:a}=t.nonceInfo,l=a.keys[0].pubkey;o=(await n.confirmTransaction({abortSignal:r?.abortSignal,minContextSlot:t.minNonceContextSlot,nonceAccountPubkey:l,nonceValue:t.nonceInfo.nonce,signature:i},r&&r.commitment)).value}else r?.abortSignal!=null&&console.warn("sendAndConfirmTransaction(): A transaction with a deprecated confirmation strategy was supplied along with an `abortSignal`. Only transactions having `lastValidBlockHeight` or a combination of `nonceInfo` and `minNonceContextSlot` are abortable."),o=(await n.confirmTransaction(i,r&&r.commitment)).value;if(o.err)throw i!=null?new Ar({action:"send",signature:i,transactionMessage:`Status: (${JSON.stringify(o)})`}):new Error(`Transaction ${i} failed (${JSON.stringify(o)})`);return i}function Tr(n){return new Promise(t=>setTimeout(t,n))}function vt(n,t){const e=n.layout.span>=0?n.layout.span:Ju(n,t),r=ht.Buffer.alloc(e),s=Object.assign({instruction:n.index},t);return n.layout.encode(s,r),r}function Tt(n,t){let e;try{e=n.layout.decode(t)}catch(r){throw new Error("invalid instruction; "+r)}if(e.instruction!==n.index)throw new Error(`invalid instruction; instruction index mismatch ${e.instruction} != ${n.index}`);return e}const el=D.nu64("lamportsPerSignature"),rl=D.struct([D.u32("version"),D.u32("state"),Et("authorizedPubkey"),Et("nonce"),D.struct([el],"feeCalculator")]),ao=rl.span;class Ui{constructor(t){this.authorizedPubkey=void 0,this.nonce=void 0,this.feeCalculator=void 0,this.authorizedPubkey=t.authorizedPubkey,this.nonce=t.nonce,this.feeCalculator=t.feeCalculator}static fromAccountData(t){const e=rl.decode(bt(t),0);return new Ui({authorizedPubkey:new rt(e.authorizedPubkey),nonce:new rt(e.nonce).toString(),feeCalculator:e.feeCalculator})}}function ln(n){const t=D.blob(8,n),e=t.decode.bind(t),r=t.encode.bind(t),s=t,i=E0();return s.decode=(o,a)=>{const l=e(o,a);return i.decode(l)},s.encode=(o,a,l)=>{const p=i.encode(o);return r(p,a,l)},s}class Gp{constructor(){}static decodeInstructionType(t){this.checkProgramId(t.programId);const r=D.u32("instruction").decode(t.data);let s;for(const[i,o]of Object.entries(Mt))if(o.index==r){s=i;break}if(!s)throw new Error("Instruction type incorrect; not a SystemInstruction");return s}static decodeCreateAccount(t){this.checkProgramId(t.programId),this.checkKeyLength(t.keys,2);const{lamports:e,space:r,programId:s}=Tt(Mt.Create,t.data);return{fromPubkey:t.keys[0].pubkey,newAccountPubkey:t.keys[1].pubkey,lamports:e,space:r,programId:new rt(s)}}static decodeTransfer(t){this.checkProgramId(t.programId),this.checkKeyLength(t.keys,2);const{lamports:e}=Tt(Mt.Transfer,t.data);return{fromPubkey:t.keys[0].pubkey,toPubkey:t.keys[1].pubkey,lamports:e}}static decodeTransferWithSeed(t){this.checkProgramId(t.programId),this.checkKeyLength(t.keys,3);const{lamports:e,seed:r,programId:s}=Tt(Mt.TransferWithSeed,t.data);return{fromPubkey:t.keys[0].pubkey,basePubkey:t.keys[1].pubkey,toPubkey:t.keys[2].pubkey,lamports:e,seed:r,programId:new rt(s)}}static decodeAllocate(t){this.checkProgramId(t.programId),this.checkKeyLength(t.keys,1);const{space:e}=Tt(Mt.Allocate,t.data);return{accountPubkey:t.keys[0].pubkey,space:e}}static decodeAllocateWithSeed(t){this.checkProgramId(t.programId),this.checkKeyLength(t.keys,1);const{base:e,seed:r,space:s,programId:i}=Tt(Mt.AllocateWithSeed,t.data);return{accountPubkey:t.keys[0].pubkey,basePubkey:new rt(e),seed:r,space:s,programId:new rt(i)}}static decodeAssign(t){this.checkProgramId(t.programId),this.checkKeyLength(t.keys,1);const{programId:e}=Tt(Mt.Assign,t.data);return{accountPubkey:t.keys[0].pubkey,programId:new rt(e)}}static decodeAssignWithSeed(t){this.checkProgramId(t.programId),this.checkKeyLength(t.keys,1);const{base:e,seed:r,programId:s}=Tt(Mt.AssignWithSeed,t.data);return{accountPubkey:t.keys[0].pubkey,basePubkey:new rt(e),seed:r,programId:new rt(s)}}static decodeCreateWithSeed(t){this.checkProgramId(t.programId),this.checkKeyLength(t.keys,2);const{base:e,seed:r,lamports:s,space:i,programId:o}=Tt(Mt.CreateWithSeed,t.data);return{fromPubkey:t.keys[0].pubkey,newAccountPubkey:t.keys[1].pubkey,basePubkey:new rt(e),seed:r,lamports:s,space:i,programId:new rt(o)}}static decodeNonceInitialize(t){this.checkProgramId(t.programId),this.checkKeyLength(t.keys,3);const{authorized:e}=Tt(Mt.InitializeNonceAccount,t.data);return{noncePubkey:t.keys[0].pubkey,authorizedPubkey:new rt(e)}}static decodeNonceAdvance(t){return this.checkProgramId(t.programId),this.checkKeyLength(t.keys,3),Tt(Mt.AdvanceNonceAccount,t.data),{noncePubkey:t.keys[0].pubkey,authorizedPubkey:t.keys[2].pubkey}}static decodeNonceWithdraw(t){this.checkProgramId(t.programId),this.checkKeyLength(t.keys,5);const{lamports:e}=Tt(Mt.WithdrawNonceAccount,t.data);return{noncePubkey:t.keys[0].pubkey,toPubkey:t.keys[1].pubkey,authorizedPubkey:t.keys[4].pubkey,lamports:e}}static decodeNonceAuthorize(t){this.checkProgramId(t.programId),this.checkKeyLength(t.keys,2);const{authorized:e}=Tt(Mt.AuthorizeNonceAccount,t.data);return{noncePubkey:t.keys[0].pubkey,authorizedPubkey:t.keys[1].pubkey,newAuthorizedPubkey:new rt(e)}}static checkProgramId(t){if(!t.equals(ye.programId))throw new Error("invalid instruction; programId is not SystemProgram")}static checkKeyLength(t,e){if(t.length<e)throw new Error(`invalid instruction; found ${t.length} keys, expected at least ${e}`)}}const Mt=Object.freeze({Create:{index:0,layout:D.struct([D.u32("instruction"),D.ns64("lamports"),D.ns64("space"),Et("programId")])},Assign:{index:1,layout:D.struct([D.u32("instruction"),Et("programId")])},Transfer:{index:2,layout:D.struct([D.u32("instruction"),ln("lamports")])},CreateWithSeed:{index:3,layout:D.struct([D.u32("instruction"),Et("base"),Cr("seed"),D.ns64("lamports"),D.ns64("space"),Et("programId")])},AdvanceNonceAccount:{index:4,layout:D.struct([D.u32("instruction")])},WithdrawNonceAccount:{index:5,layout:D.struct([D.u32("instruction"),D.ns64("lamports")])},InitializeNonceAccount:{index:6,layout:D.struct([D.u32("instruction"),Et("authorized")])},AuthorizeNonceAccount:{index:7,layout:D.struct([D.u32("instruction"),Et("authorized")])},Allocate:{index:8,layout:D.struct([D.u32("instruction"),D.ns64("space")])},AllocateWithSeed:{index:9,layout:D.struct([D.u32("instruction"),Et("base"),Cr("seed"),D.ns64("space"),Et("programId")])},AssignWithSeed:{index:10,layout:D.struct([D.u32("instruction"),Et("base"),Cr("seed"),Et("programId")])},TransferWithSeed:{index:11,layout:D.struct([D.u32("instruction"),ln("lamports"),Cr("seed"),Et("programId")])},UpgradeNonceAccount:{index:12,layout:D.struct([D.u32("instruction")])}});class ye{constructor(){}static createAccount(t){const e=Mt.Create,r=vt(e,{lamports:t.lamports,space:t.space,programId:bt(t.programId.toBuffer())});return new xt({keys:[{pubkey:t.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:t.newAccountPubkey,isSigner:!0,isWritable:!0}],programId:this.programId,data:r})}static transfer(t){let e,r;if("basePubkey"in t){const s=Mt.TransferWithSeed;e=vt(s,{lamports:BigInt(t.lamports),seed:t.seed,programId:bt(t.programId.toBuffer())}),r=[{pubkey:t.fromPubkey,isSigner:!1,isWritable:!0},{pubkey:t.basePubkey,isSigner:!0,isWritable:!1},{pubkey:t.toPubkey,isSigner:!1,isWritable:!0}]}else{const s=Mt.Transfer;e=vt(s,{lamports:BigInt(t.lamports)}),r=[{pubkey:t.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:t.toPubkey,isSigner:!1,isWritable:!0}]}return new xt({keys:r,programId:this.programId,data:e})}static assign(t){let e,r;if("basePubkey"in t){const s=Mt.AssignWithSeed;e=vt(s,{base:bt(t.basePubkey.toBuffer()),seed:t.seed,programId:bt(t.programId.toBuffer())}),r=[{pubkey:t.accountPubkey,isSigner:!1,isWritable:!0},{pubkey:t.basePubkey,isSigner:!0,isWritable:!1}]}else{const s=Mt.Assign;e=vt(s,{programId:bt(t.programId.toBuffer())}),r=[{pubkey:t.accountPubkey,isSigner:!0,isWritable:!0}]}return new xt({keys:r,programId:this.programId,data:e})}static createAccountWithSeed(t){const e=Mt.CreateWithSeed,r=vt(e,{base:bt(t.basePubkey.toBuffer()),seed:t.seed,lamports:t.lamports,space:t.space,programId:bt(t.programId.toBuffer())});let s=[{pubkey:t.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:t.newAccountPubkey,isSigner:!1,isWritable:!0}];return t.basePubkey.equals(t.fromPubkey)||s.push({pubkey:t.basePubkey,isSigner:!0,isWritable:!1}),new xt({keys:s,programId:this.programId,data:r})}static createNonceAccount(t){const e=new At;"basePubkey"in t&&"seed"in t?e.add(ye.createAccountWithSeed({fromPubkey:t.fromPubkey,newAccountPubkey:t.noncePubkey,basePubkey:t.basePubkey,seed:t.seed,lamports:t.lamports,space:ao,programId:this.programId})):e.add(ye.createAccount({fromPubkey:t.fromPubkey,newAccountPubkey:t.noncePubkey,lamports:t.lamports,space:ao,programId:this.programId}));const r={noncePubkey:t.noncePubkey,authorizedPubkey:t.authorizedPubkey};return e.add(this.nonceInitialize(r)),e}static nonceInitialize(t){const e=Mt.InitializeNonceAccount,r=vt(e,{authorized:bt(t.authorizedPubkey.toBuffer())}),s={keys:[{pubkey:t.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:ci,isSigner:!1,isWritable:!1},{pubkey:un,isSigner:!1,isWritable:!1}],programId:this.programId,data:r};return new xt(s)}static nonceAdvance(t){const e=Mt.AdvanceNonceAccount,r=vt(e),s={keys:[{pubkey:t.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:ci,isSigner:!1,isWritable:!1},{pubkey:t.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:r};return new xt(s)}static nonceWithdraw(t){const e=Mt.WithdrawNonceAccount,r=vt(e,{lamports:t.lamports});return new xt({keys:[{pubkey:t.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:t.toPubkey,isSigner:!1,isWritable:!0},{pubkey:ci,isSigner:!1,isWritable:!1},{pubkey:un,isSigner:!1,isWritable:!1},{pubkey:t.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:r})}static nonceAuthorize(t){const e=Mt.AuthorizeNonceAccount,r=vt(e,{authorized:bt(t.newAuthorizedPubkey.toBuffer())});return new xt({keys:[{pubkey:t.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:t.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:r})}static allocate(t){let e,r;if("basePubkey"in t){const s=Mt.AllocateWithSeed;e=vt(s,{base:bt(t.basePubkey.toBuffer()),seed:t.seed,space:t.space,programId:bt(t.programId.toBuffer())}),r=[{pubkey:t.accountPubkey,isSigner:!1,isWritable:!0},{pubkey:t.basePubkey,isSigner:!0,isWritable:!1}]}else{const s=Mt.Allocate;e=vt(s,{space:t.space}),r=[{pubkey:t.accountPubkey,isSigner:!0,isWritable:!0}]}return new xt({keys:r,programId:this.programId,data:e})}}ye.programId=new rt("11111111111111111111111111111111");const jp=Er-300;class Dr{constructor(){}static getMinNumSignatures(t){return 2*(Math.ceil(t/Dr.chunkSize)+1+1)}static async load(t,e,r,s,i){{const S=await t.getMinimumBalanceForRentExemption(i.length),R=await t.getAccountInfo(r.publicKey,"confirmed");let _=null;if(R!==null){if(R.executable)return console.error("Program load failed, account is already executable"),!1;R.data.length!==i.length&&(_=_||new At,_.add(ye.allocate({accountPubkey:r.publicKey,space:i.length}))),R.owner.equals(s)||(_=_||new At,_.add(ye.assign({accountPubkey:r.publicKey,programId:s}))),R.lamports<S&&(_=_||new At,_.add(ye.transfer({fromPubkey:e.publicKey,toPubkey:r.publicKey,lamports:S-R.lamports})))}else _=new At().add(ye.createAccount({fromPubkey:e.publicKey,newAccountPubkey:r.publicKey,lamports:S>0?S:1,space:i.length,programId:s}));_!==null&&await oo(t,_,[e,r],{commitment:"confirmed"})}const o=D.struct([D.u32("instruction"),D.u32("offset"),D.u32("bytesLength"),D.u32("bytesLengthPadding"),D.seq(D.u8("byte"),D.offset(D.u32(),-8),"bytes")]),a=Dr.chunkSize;let l=0,p=i,m=[];for(;p.length>0;){const S=p.slice(0,a),R=ht.Buffer.alloc(a+16);o.encode({instruction:0,offset:l,bytes:S,bytesLength:0,bytesLengthPadding:0},R);const _=new At().add({keys:[{pubkey:r.publicKey,isSigner:!0,isWritable:!0}],programId:s,data:R});m.push(oo(t,_,[e,r],{commitment:"confirmed"})),t._rpcEndpoint.includes("solana.com")&&await Tr(1e3/4),l+=a,p=p.slice(a)}await Promise.all(m);{const S=D.struct([D.u32("instruction")]),R=ht.Buffer.alloc(S.span);S.encode({instruction:1},R);const _=new At().add({keys:[{pubkey:r.publicKey,isSigner:!0,isWritable:!0},{pubkey:un,isSigner:!1,isWritable:!1}],programId:s,data:R}),I="processed",O=await t.sendTransaction(_,[e,r],{preflightCommitment:I}),{context:x,value:M}=await t.confirmTransaction({signature:O,lastValidBlockHeight:_.lastValidBlockHeight,blockhash:_.recentBlockhash},I);if(M.err)throw new Error(`Transaction ${O} failed (${JSON.stringify(M)})`);for(;;){try{if(await t.getSlot({commitment:I})>x.slot)break}catch{}await new Promise(H=>setTimeout(H,Math.round(tl/2)))}}return!0}}Dr.chunkSize=jp;const Yp=new rt("BPFLoader2111111111111111111111111111111111");class Zp{static getMinNumSignatures(t){return Dr.getMinNumSignatures(t)}static load(t,e,r,s,i){return Dr.load(t,e,r,i,s)}}function Xp(n){return n&&n.__esModule&&Object.prototype.hasOwnProperty.call(n,"default")?n.default:n}var Ps,Xa;function Jp(){if(Xa)return Ps;Xa=1;var n=Object.prototype.toString,t=Object.keys||function(r){var s=[];for(var i in r)s.push(i);return s};function e(r,s){var i,o,a,l,p,m,S;if(r===!0)return"true";if(r===!1)return"false";switch(typeof r){case"object":if(r===null)return null;if(r.toJSON&&typeof r.toJSON=="function")return e(r.toJSON(),s);if(S=n.call(r),S==="[object Array]"){for(a="[",o=r.length-1,i=0;i<o;i++)a+=e(r[i],!0)+",";return o>-1&&(a+=e(r[i],!0)),a+"]"}else if(S==="[object Object]"){for(l=t(r).sort(),o=l.length,a="",i=0;i<o;)p=l[i],m=e(r[p],!1),m!==void 0&&(a&&(a+=","),a+=JSON.stringify(p)+":"+m),i++;return"{"+a+"}"}else return JSON.stringify(r);case"function":case"undefined":return s?null:void 0;case"string":return JSON.stringify(r);default:return isFinite(r)?r:null}}return Ps=function(r){var s=e(r,!1);if(s!==void 0)return""+s},Ps}var Qp=Jp(),Ja=Xp(Qp);const wn=32;function Us(n){let t=0;for(;n>1;)n/=2,t++;return t}function ty(n){return n===0?1:(n--,n|=n>>1,n|=n>>2,n|=n>>4,n|=n>>8,n|=n>>16,n|=n>>32,n+1)}class nl{constructor(t,e,r,s,i){this.slotsPerEpoch=void 0,this.leaderScheduleSlotOffset=void 0,this.warmup=void 0,this.firstNormalEpoch=void 0,this.firstNormalSlot=void 0,this.slotsPerEpoch=t,this.leaderScheduleSlotOffset=e,this.warmup=r,this.firstNormalEpoch=s,this.firstNormalSlot=i}getEpoch(t){return this.getEpochAndSlotIndex(t)[0]}getEpochAndSlotIndex(t){if(t<this.firstNormalSlot){const e=Us(ty(t+wn+1))-Us(wn)-1,r=this.getSlotsInEpoch(e),s=t-(r-wn);return[e,s]}else{const e=t-this.firstNormalSlot,r=Math.floor(e/this.slotsPerEpoch),s=this.firstNormalEpoch+r,i=e%this.slotsPerEpoch;return[s,i]}}getFirstSlotInEpoch(t){return t<=this.firstNormalEpoch?(Math.pow(2,t)-1)*wn:(t-this.firstNormalEpoch)*this.slotsPerEpoch+this.firstNormalSlot}getLastSlotInEpoch(t){return this.getFirstSlotInEpoch(t)+this.getSlotsInEpoch(t)-1}getSlotsInEpoch(t){return t<this.firstNormalEpoch?Math.pow(2,t+Us(wn)):this.slotsPerEpoch}}var ey=globalThis.fetch;class ry extends np{constructor(t,e,r){const s=i=>{const o=ep(i,{autoconnect:!0,max_reconnects:5,reconnect:!0,reconnect_interval:1e3,...e});return"socket"in o?this.underlyingSocket=o.socket:this.underlyingSocket=o,o};super(s,t,e,r),this.underlyingSocket=void 0}call(...t){const e=this.underlyingSocket?.readyState;return e===1?super.call(...t):Promise.reject(new Error("Tried to call a JSON-RPC method `"+t[0]+"` but the socket was not `CONNECTING` or `OPEN` (`readyState` was "+e+")"))}notify(...t){const e=this.underlyingSocket?.readyState;return e===1?super.notify(...t):Promise.reject(new Error("Tried to send a JSON-RPC notification `"+t[0]+"` but the socket was not `CONNECTING` or `OPEN` (`readyState` was "+e+")"))}}function ny(n,t){let e;try{e=n.layout.decode(t)}catch(r){throw new Error("invalid instruction; "+r)}if(e.typeIndex!==n.index)throw new Error(`invalid account data; account type mismatch ${e.typeIndex} != ${n.index}`);return e}const Qa=56;class co{constructor(t){this.key=void 0,this.state=void 0,this.key=t.key,this.state=t.state}isActive(){const t=BigInt("0xffffffffffffffff");return this.state.deactivationSlot===t}static deserialize(t){const e=ny(iy,t),r=t.length-Qa;It(r>=0,"lookup table is invalid"),It(r%32===0,"lookup table is invalid");const s=r/32,{addresses:i}=D.struct([D.seq(Et(),s,"addresses")]).decode(t.slice(Qa));return{deactivationSlot:e.deactivationSlot,lastExtendedSlot:e.lastExtendedSlot,lastExtendedSlotStartIndex:e.lastExtendedStartIndex,authority:e.authority.length!==0?new rt(e.authority[0]):void 0,addresses:i.map(o=>new rt(o))}}}const iy={index:1,layout:D.struct([D.u32("typeIndex"),ln("deactivationSlot"),D.nu64("lastExtendedSlot"),D.u8("lastExtendedStartIndex"),D.u8(),D.seq(Et(),D.offset(D.u8(),-1),"authority")])},sy=/^[^:]+:\/\/([^:[]+|\[[^\]]+\])(:\d+)?(.*)/i;function oy(n){const t=n.match(sy);if(t==null)throw TypeError(`Failed to validate endpoint URL \`${n}\``);const[e,r,s,i]=t,o=n.startsWith("https:")?"wss:":"ws:",a=s==null?null:parseInt(s.slice(1),10),l=a==null?"":`:${a+1}`;return`${o}//${r}${l}${i}`}const Kt=Un(Mo(rt),nt(),n=>new rt(n)),il=Lo([nt(),zt("base64")]),Wo=Un(Mo(ht.Buffer),il,n=>ht.Buffer.from(n[0],"base64")),sl=30*1e3;function ay(n){if(/^https?:/.test(n)===!1)throw new TypeError("Endpoint URL must start with `http:` or `https:`.");return n}function Bt(n){let t,e;if(typeof n=="string")t=n;else if(n){const{commitment:r,...s}=n;t=r,e=s}return{commitment:t,config:e}}function tc(n){return n.map(t=>"memcmp"in t?{...t,memcmp:{...t.memcmp,encoding:t.memcmp.encoding??"base58"}}:t)}function ol(n){return ke([et({jsonrpc:zt("2.0"),id:nt(),result:n}),et({jsonrpc:zt("2.0"),id:nt(),error:et({code:fn(),message:nt(),data:dt(k0())})})])}const cy=ol(fn());function _t(n){return Un(ol(n),cy,t=>"error"in t?t:{...t,result:st(t.result,n)})}function Yt(n){return _t(et({context:et({slot:W()}),value:n}))}function Di(n){return et({context:et({slot:W()}),value:n})}function Ds(n,t){return n===0?new Ur({header:t.header,staticAccountKeys:t.accountKeys.map(e=>new rt(e)),recentBlockhash:t.recentBlockhash,compiledInstructions:t.instructions.map(e=>({programIdIndex:e.programIdIndex,accountKeyIndexes:e.accounts,data:be.decode(e.data)})),addressTableLookups:t.addressTableLookups}):new qe(t)}const uy=et({foundation:W(),foundationTerm:W(),initial:W(),taper:W(),terminal:W()}),ly=_t(at(ct(et({epoch:W(),effectiveSlot:W(),amount:W(),postBalance:W(),commission:dt(ct(W()))})))),hy=at(et({slot:W(),prioritizationFee:W()})),fy=et({total:W(),validator:W(),foundation:W(),epoch:W()}),dy=et({epoch:W(),slotIndex:W(),slotsInEpoch:W(),absoluteSlot:W(),blockHeight:dt(W()),transactionCount:dt(W())}),py=et({slotsPerEpoch:W(),leaderScheduleSlotOffset:W(),warmup:Je(),firstNormalEpoch:W(),firstNormalSlot:W()}),yy=Mu(nt(),at(W())),qr=ct(ke([et({}),nt()])),gy=et({err:qr}),my=zt("receivedSignature"),wy=et({"solana-core":nt(),"feature-set":dt(W())}),_y=et({program:nt(),programId:Kt,parsed:fn()}),by=et({programId:Kt,accounts:at(Kt),data:nt()}),ec=Yt(et({err:ct(ke([et({}),nt()])),logs:ct(at(nt())),accounts:dt(ct(at(ct(et({executable:Je(),owner:nt(),lamports:W(),data:at(nt()),rentEpoch:dt(W())}))))),unitsConsumed:dt(W()),returnData:dt(ct(et({programId:nt(),data:Lo([nt(),zt("base64")])}))),innerInstructions:dt(ct(at(et({index:W(),instructions:at(ke([_y,by]))}))))})),Ey=Yt(et({byIdentity:Mu(nt(),at(W())),range:et({firstSlot:W(),lastSlot:W()})}));function Ry(n,t,e,r,s,i){const o=e||ey;let a;i!=null&&console.warn("You have supplied an `httpAgent` when creating a `Connection` in a browser environment.It has been ignored; `httpAgent` is only used in Node environments.");let l;return r&&(l=async(m,S)=>{const R=await new Promise((_,I)=>{try{r(m,S,(O,x)=>_([O,x]))}catch(O){I(O)}});return await o(...R)}),new X0(async(m,S)=>{const R={method:"POST",body:m,agent:a,headers:Object.assign({"Content-Type":"application/json"},t||{},Rg)};try{let _=5,I,O=500;for(;l?I=await l(n,R):I=await o(n,R),!(I.status!==429||s===!0||(_-=1,_===0));)console.error(`Server responded with ${I.status} ${I.statusText}.  Retrying after ${O}ms delay...`),await Tr(O),O*=2;const x=await I.text();I.ok?S(null,x):S(new Error(`${I.status} ${I.statusText}: ${x}`))}catch(_){_ instanceof Error&&S(_)}},{})}function vy(n){return(t,e)=>new Promise((r,s)=>{n.request(t,e,(i,o)=>{if(i){s(i);return}r(o)})})}function Ay(n){return t=>new Promise((e,r)=>{t.length===0&&e([]);const s=t.map(i=>n.request(i.methodName,i.args));n.request(s,(i,o)=>{if(i){r(i);return}e(o)})})}const Iy=_t(uy),Sy=_t(fy),ky=_t(hy),Ty=_t(dy),Oy=_t(py),xy=_t(yy),Ny=_t(W()),Cy=Yt(et({total:W(),circulating:W(),nonCirculating:W(),nonCirculatingAccounts:at(Kt)})),uo=et({amount:nt(),uiAmount:ct(W()),decimals:W(),uiAmountString:dt(nt())}),By=Yt(at(et({address:Kt,amount:nt(),uiAmount:ct(W()),decimals:W(),uiAmountString:dt(nt())}))),My=Yt(at(et({pubkey:Kt,account:et({executable:Je(),owner:Kt,lamports:W(),data:Wo,rentEpoch:W()})}))),lo=et({program:nt(),parsed:fn(),space:W()}),Ly=Yt(at(et({pubkey:Kt,account:et({executable:Je(),owner:Kt,lamports:W(),data:lo,rentEpoch:W()})}))),Py=Yt(at(et({lamports:W(),address:Kt}))),Tn=et({executable:Je(),owner:Kt,lamports:W(),data:Wo,rentEpoch:W()}),Uy=et({pubkey:Kt,account:Tn}),Dy=Un(ke([Mo(ht.Buffer),lo]),ke([il,lo]),n=>Array.isArray(n)?st(n,Wo):n),ho=et({executable:Je(),owner:Kt,lamports:W(),data:Dy,rentEpoch:W()}),Hy=et({pubkey:Kt,account:ho}),Fy=et({state:ke([zt("active"),zt("inactive"),zt("activating"),zt("deactivating")]),active:W(),inactive:W()}),zy=_t(at(et({signature:nt(),slot:W(),err:qr,memo:ct(nt()),blockTime:dt(ct(W()))}))),Ky=_t(at(et({signature:nt(),slot:W(),err:qr,memo:ct(nt()),blockTime:dt(ct(W()))}))),qy=et({subscription:W(),result:Di(Tn)}),$y=et({pubkey:Kt,account:Tn}),Vy=et({subscription:W(),result:Di($y)}),Wy=et({parent:W(),slot:W(),root:W()}),Gy=et({subscription:W(),result:Wy}),jy=ke([et({type:ke([zt("firstShredReceived"),zt("completed"),zt("optimisticConfirmation"),zt("root")]),slot:W(),timestamp:W()}),et({type:zt("createdBank"),parent:W(),slot:W(),timestamp:W()}),et({type:zt("frozen"),slot:W(),timestamp:W(),stats:et({numTransactionEntries:W(),numSuccessfulTransactions:W(),numFailedTransactions:W(),maxTransactionsPerEntry:W()})}),et({type:zt("dead"),slot:W(),timestamp:W(),err:nt()})]),Yy=et({subscription:W(),result:jy}),Zy=et({subscription:W(),result:Di(ke([gy,my]))}),Xy=et({subscription:W(),result:W()}),Jy=et({pubkey:nt(),gossip:ct(nt()),tpu:ct(nt()),rpc:ct(nt()),version:ct(nt())}),rc=et({votePubkey:nt(),nodePubkey:nt(),activatedStake:W(),epochVoteAccount:Je(),epochCredits:at(Lo([W(),W(),W()])),commission:W(),lastVote:W(),rootSlot:ct(W())}),Qy=_t(et({current:at(rc),delinquent:at(rc)})),tg=ke([zt("processed"),zt("confirmed"),zt("finalized")]),eg=et({slot:W(),confirmations:ct(W()),err:qr,confirmationStatus:dt(tg)}),rg=Yt(at(ct(eg))),ng=_t(W()),al=et({accountKey:Kt,writableIndexes:at(W()),readonlyIndexes:at(W())}),Go=et({signatures:at(nt()),message:et({accountKeys:at(nt()),header:et({numRequiredSignatures:W(),numReadonlySignedAccounts:W(),numReadonlyUnsignedAccounts:W()}),instructions:at(et({accounts:at(W()),data:nt(),programIdIndex:W()})),recentBlockhash:nt(),addressTableLookups:dt(at(al))})}),cl=et({pubkey:Kt,signer:Je(),writable:Je(),source:dt(ke([zt("transaction"),zt("lookupTable")]))}),ul=et({accountKeys:at(cl),signatures:at(nt())}),ll=et({parsed:fn(),program:nt(),programId:Kt}),hl=et({accounts:at(Kt),data:nt(),programId:Kt}),ig=ke([hl,ll]),sg=ke([et({parsed:fn(),program:nt(),programId:nt()}),et({accounts:at(nt()),data:nt(),programId:nt()})]),fl=Un(ig,sg,n=>"accounts"in n?st(n,hl):st(n,ll)),dl=et({signatures:at(nt()),message:et({accountKeys:at(cl),instructions:at(fl),recentBlockhash:nt(),addressTableLookups:dt(ct(at(al)))})}),Ri=et({accountIndex:W(),mint:nt(),owner:dt(nt()),programId:dt(nt()),uiTokenAmount:uo}),pl=et({writable:at(Kt),readonly:at(Kt)}),Hi=et({err:qr,fee:W(),innerInstructions:dt(ct(at(et({index:W(),instructions:at(et({accounts:at(W()),data:nt(),programIdIndex:W()}))})))),preBalances:at(W()),postBalances:at(W()),logMessages:dt(ct(at(nt()))),preTokenBalances:dt(ct(at(Ri))),postTokenBalances:dt(ct(at(Ri))),loadedAddresses:dt(pl),computeUnitsConsumed:dt(W()),costUnits:dt(W())}),jo=et({err:qr,fee:W(),innerInstructions:dt(ct(at(et({index:W(),instructions:at(fl)})))),preBalances:at(W()),postBalances:at(W()),logMessages:dt(ct(at(nt()))),preTokenBalances:dt(ct(at(Ri))),postTokenBalances:dt(ct(at(Ri))),loadedAddresses:dt(pl),computeUnitsConsumed:dt(W()),costUnits:dt(W())}),dn=ke([zt(0),zt("legacy")]),$r=et({pubkey:nt(),lamports:W(),postBalance:ct(W()),rewardType:ct(nt()),commission:dt(ct(W()))}),og=_t(ct(et({blockhash:nt(),previousBlockhash:nt(),parentSlot:W(),transactions:at(et({transaction:Go,meta:ct(Hi),version:dt(dn)})),rewards:dt(at($r)),blockTime:ct(W()),blockHeight:ct(W())}))),ag=_t(ct(et({blockhash:nt(),previousBlockhash:nt(),parentSlot:W(),rewards:dt(at($r)),blockTime:ct(W()),blockHeight:ct(W())}))),cg=_t(ct(et({blockhash:nt(),previousBlockhash:nt(),parentSlot:W(),transactions:at(et({transaction:ul,meta:ct(Hi),version:dt(dn)})),rewards:dt(at($r)),blockTime:ct(W()),blockHeight:ct(W())}))),ug=_t(ct(et({blockhash:nt(),previousBlockhash:nt(),parentSlot:W(),transactions:at(et({transaction:dl,meta:ct(jo),version:dt(dn)})),rewards:dt(at($r)),blockTime:ct(W()),blockHeight:ct(W())}))),lg=_t(ct(et({blockhash:nt(),previousBlockhash:nt(),parentSlot:W(),transactions:at(et({transaction:ul,meta:ct(jo),version:dt(dn)})),rewards:dt(at($r)),blockTime:ct(W()),blockHeight:ct(W())}))),hg=_t(ct(et({blockhash:nt(),previousBlockhash:nt(),parentSlot:W(),rewards:dt(at($r)),blockTime:ct(W()),blockHeight:ct(W())}))),fg=_t(ct(et({blockhash:nt(),previousBlockhash:nt(),parentSlot:W(),transactions:at(et({transaction:Go,meta:ct(Hi)})),rewards:dt(at($r)),blockTime:ct(W())}))),nc=_t(ct(et({blockhash:nt(),previousBlockhash:nt(),parentSlot:W(),signatures:at(nt()),blockTime:ct(W())}))),Hs=_t(ct(et({slot:W(),meta:ct(Hi),blockTime:dt(ct(W())),transaction:Go,version:dt(dn)}))),Qn=_t(ct(et({slot:W(),transaction:dl,meta:ct(jo),blockTime:dt(ct(W())),version:dt(dn)}))),dg=Yt(et({blockhash:nt(),lastValidBlockHeight:W()})),pg=Yt(Je()),yg=et({slot:W(),numTransactions:W(),numSlots:W(),samplePeriodSecs:W()}),gg=_t(at(yg)),mg=Yt(ct(et({feeCalculator:et({lamportsPerSignature:W()})}))),wg=_t(nt()),_g=_t(nt()),bg=et({err:qr,logs:at(nt()),signature:nt()}),Eg=et({result:Di(bg),subscription:W()}),Rg={"solana-client":"js/1.0.0-maintenance"};class vg{constructor(t,e){this._commitment=void 0,this._confirmTransactionInitialTimeout=void 0,this._rpcEndpoint=void 0,this._rpcWsEndpoint=void 0,this._rpcClient=void 0,this._rpcRequest=void 0,this._rpcBatchRequest=void 0,this._rpcWebSocket=void 0,this._rpcWebSocketConnected=!1,this._rpcWebSocketHeartbeat=null,this._rpcWebSocketIdleTimeout=null,this._rpcWebSocketGeneration=0,this._disableBlockhashCaching=!1,this._pollingBlockhash=!1,this._blockhashInfo={latestBlockhash:null,lastFetch:0,transactionSignatures:[],simulatedSignatures:[]},this._nextClientSubscriptionId=0,this._subscriptionDisposeFunctionsByClientSubscriptionId={},this._subscriptionHashByClientSubscriptionId={},this._subscriptionStateChangeCallbacksByHash={},this._subscriptionCallbacksByServerSubscriptionId={},this._subscriptionsByHash={},this._subscriptionsAutoDisposedByRpc=new Set,this.getBlockHeight=(()=>{const p={};return async m=>{const{commitment:S,config:R}=Bt(m),_=this._buildArgs([],S,void 0,R),I=Ja(_);return p[I]=p[I]??(async()=>{try{const O=await this._rpcRequest("getBlockHeight",_),x=st(O,_t(W()));if("error"in x)throw new ft(x.error,"failed to get block height information");return x.result}finally{delete p[I]}})(),await p[I]}})();let r,s,i,o,a,l;e&&typeof e=="string"?this._commitment=e:e&&(this._commitment=e.commitment,this._confirmTransactionInitialTimeout=e.confirmTransactionInitialTimeout,r=e.wsEndpoint,s=e.httpHeaders,i=e.fetch,o=e.fetchMiddleware,a=e.disableRetryOnRateLimit,l=e.httpAgent),this._rpcEndpoint=ay(t),this._rpcWsEndpoint=r||oy(t),this._rpcClient=Ry(t,s,i,o,a,l),this._rpcRequest=vy(this._rpcClient),this._rpcBatchRequest=Ay(this._rpcClient),this._rpcWebSocket=new ry(this._rpcWsEndpoint,{autoconnect:!1,max_reconnects:1/0}),this._rpcWebSocket.on("open",this._wsOnOpen.bind(this)),this._rpcWebSocket.on("error",this._wsOnError.bind(this)),this._rpcWebSocket.on("close",this._wsOnClose.bind(this)),this._rpcWebSocket.on("accountNotification",this._wsOnAccountNotification.bind(this)),this._rpcWebSocket.on("programNotification",this._wsOnProgramAccountNotification.bind(this)),this._rpcWebSocket.on("slotNotification",this._wsOnSlotNotification.bind(this)),this._rpcWebSocket.on("slotsUpdatesNotification",this._wsOnSlotUpdatesNotification.bind(this)),this._rpcWebSocket.on("signatureNotification",this._wsOnSignatureNotification.bind(this)),this._rpcWebSocket.on("rootNotification",this._wsOnRootNotification.bind(this)),this._rpcWebSocket.on("logsNotification",this._wsOnLogsNotification.bind(this))}get commitment(){return this._commitment}get rpcEndpoint(){return this._rpcEndpoint}async getBalanceAndContext(t,e){const{commitment:r,config:s}=Bt(e),i=this._buildArgs([t.toBase58()],r,void 0,s),o=await this._rpcRequest("getBalance",i),a=st(o,Yt(W()));if("error"in a)throw new ft(a.error,`failed to get balance for ${t.toBase58()}`);return a.result}async getBalance(t,e){return await this.getBalanceAndContext(t,e).then(r=>r.value).catch(r=>{throw new Error("failed to get balance of account "+t.toBase58()+": "+r)})}async getBlockTime(t){const e=await this._rpcRequest("getBlockTime",[t]),r=st(e,_t(ct(W())));if("error"in r)throw new ft(r.error,`failed to get block time for slot ${t}`);return r.result}async getMinimumLedgerSlot(){const t=await this._rpcRequest("minimumLedgerSlot",[]),e=st(t,_t(W()));if("error"in e)throw new ft(e.error,"failed to get minimum ledger slot");return e.result}async getFirstAvailableBlock(){const t=await this._rpcRequest("getFirstAvailableBlock",[]),e=st(t,Ny);if("error"in e)throw new ft(e.error,"failed to get first available block");return e.result}async getSupply(t){let e={};typeof t=="string"?e={commitment:t}:t?e={...t,commitment:t&&t.commitment||this.commitment}:e={commitment:this.commitment};const r=await this._rpcRequest("getSupply",[e]),s=st(r,Cy);if("error"in s)throw new ft(s.error,"failed to get supply");return s.result}async getTokenSupply(t,e){const r=this._buildArgs([t.toBase58()],e),s=await this._rpcRequest("getTokenSupply",r),i=st(s,Yt(uo));if("error"in i)throw new ft(i.error,"failed to get token supply");return i.result}async getTokenAccountBalance(t,e){const r=this._buildArgs([t.toBase58()],e),s=await this._rpcRequest("getTokenAccountBalance",r),i=st(s,Yt(uo));if("error"in i)throw new ft(i.error,"failed to get token account balance");return i.result}async getTokenAccountsByOwner(t,e,r){const{commitment:s,config:i}=Bt(r);let o=[t.toBase58()];"mint"in e?o.push({mint:e.mint.toBase58()}):o.push({programId:e.programId.toBase58()});const a=this._buildArgs(o,s,"base64",i),l=await this._rpcRequest("getTokenAccountsByOwner",a),p=st(l,My);if("error"in p)throw new ft(p.error,`failed to get token accounts owned by account ${t.toBase58()}`);return p.result}async getParsedTokenAccountsByOwner(t,e,r){let s=[t.toBase58()];"mint"in e?s.push({mint:e.mint.toBase58()}):s.push({programId:e.programId.toBase58()});const i=this._buildArgs(s,r,"jsonParsed"),o=await this._rpcRequest("getTokenAccountsByOwner",i),a=st(o,Ly);if("error"in a)throw new ft(a.error,`failed to get token accounts owned by account ${t.toBase58()}`);return a.result}async getLargestAccounts(t){const e={...t,commitment:t&&t.commitment||this.commitment},r=e.filter||e.commitment?[e]:[],s=await this._rpcRequest("getLargestAccounts",r),i=st(s,Py);if("error"in i)throw new ft(i.error,"failed to get largest accounts");return i.result}async getTokenLargestAccounts(t,e){const r=this._buildArgs([t.toBase58()],e),s=await this._rpcRequest("getTokenLargestAccounts",r),i=st(s,By);if("error"in i)throw new ft(i.error,"failed to get token largest accounts");return i.result}async getAccountInfoAndContext(t,e){const{commitment:r,config:s}=Bt(e),i=this._buildArgs([t.toBase58()],r,"base64",s),o=await this._rpcRequest("getAccountInfo",i),a=st(o,Yt(ct(Tn)));if("error"in a)throw new ft(a.error,`failed to get info about account ${t.toBase58()}`);return a.result}async getParsedAccountInfo(t,e){const{commitment:r,config:s}=Bt(e),i=this._buildArgs([t.toBase58()],r,"jsonParsed",s),o=await this._rpcRequest("getAccountInfo",i),a=st(o,Yt(ct(ho)));if("error"in a)throw new ft(a.error,`failed to get info about account ${t.toBase58()}`);return a.result}async getAccountInfo(t,e){try{return(await this.getAccountInfoAndContext(t,e)).value}catch(r){throw new Error("failed to get info about account "+t.toBase58()+": "+r)}}async getMultipleParsedAccounts(t,e){const{commitment:r,config:s}=Bt(e),i=t.map(p=>p.toBase58()),o=this._buildArgs([i],r,"jsonParsed",s),a=await this._rpcRequest("getMultipleAccounts",o),l=st(a,Yt(at(ct(ho))));if("error"in l)throw new ft(l.error,`failed to get info for accounts ${i}`);return l.result}async getMultipleAccountsInfoAndContext(t,e){const{commitment:r,config:s}=Bt(e),i=t.map(p=>p.toBase58()),o=this._buildArgs([i],r,"base64",s),a=await this._rpcRequest("getMultipleAccounts",o),l=st(a,Yt(at(ct(Tn))));if("error"in l)throw new ft(l.error,`failed to get info for accounts ${i}`);return l.result}async getMultipleAccountsInfo(t,e){return(await this.getMultipleAccountsInfoAndContext(t,e)).value}async getStakeActivation(t,e,r){const{commitment:s,config:i}=Bt(e),o=this._buildArgs([t.toBase58()],s,void 0,{...i,epoch:r??i?.epoch}),a=await this._rpcRequest("getStakeActivation",o),l=st(a,_t(Fy));if("error"in l)throw new ft(l.error,`failed to get Stake Activation ${t.toBase58()}`);return l.result}async getProgramAccounts(t,e){const{commitment:r,config:s}=Bt(e),{encoding:i,...o}=s||{},a=this._buildArgs([t.toBase58()],r,i||"base64",{...o,...o.filters?{filters:tc(o.filters)}:null}),l=await this._rpcRequest("getProgramAccounts",a),p=at(Uy),m=o.withContext===!0?st(l,Yt(p)):st(l,_t(p));if("error"in m)throw new ft(m.error,`failed to get accounts owned by program ${t.toBase58()}`);return m.result}async getParsedProgramAccounts(t,e){const{commitment:r,config:s}=Bt(e),i=this._buildArgs([t.toBase58()],r,"jsonParsed",s),o=await this._rpcRequest("getProgramAccounts",i),a=st(o,_t(at(Hy)));if("error"in a)throw new ft(a.error,`failed to get accounts owned by program ${t.toBase58()}`);return a.result}async confirmTransaction(t,e){let r;if(typeof t=="string")r=t;else{const i=t;if(i.abortSignal?.aborted)return Promise.reject(i.abortSignal.reason);r=i.signature}let s;try{s=be.decode(r)}catch{throw new Error("signature must be base58 encoded: "+r)}return It(s.length===64,"signature has invalid length"),typeof t=="string"?await this.confirmTransactionUsingLegacyTimeoutStrategy({commitment:e||this.commitment,signature:r}):"lastValidBlockHeight"in t?await this.confirmTransactionUsingBlockHeightExceedanceStrategy({commitment:e||this.commitment,strategy:t}):await this.confirmTransactionUsingDurableNonceStrategy({commitment:e||this.commitment,strategy:t})}getCancellationPromise(t){return new Promise((e,r)=>{t!=null&&(t.aborted?r(t.reason):t.addEventListener("abort",()=>{r(t.reason)}))})}getTransactionConfirmationPromise({commitment:t,signature:e}){let r,s,i=!1;const o=new Promise((l,p)=>{try{r=this.onSignature(e,(S,R)=>{r=void 0;const _={context:R,value:S};l({__type:nr.PROCESSED,response:_})},t);const m=new Promise(S=>{r==null?S():s=this._onSubscriptionStateChange(r,R=>{R==="subscribed"&&S()})});(async()=>{if(await m,i)return;const S=await this.getSignatureStatus(e);if(i||S==null)return;const{context:R,value:_}=S;if(_!=null)if(_?.err)p(_.err);else{switch(t){case"confirmed":case"single":case"singleGossip":{if(_.confirmationStatus==="processed")return;break}case"finalized":case"max":case"root":{if(_.confirmationStatus==="processed"||_.confirmationStatus==="confirmed")return;break}case"processed":case"recent":}i=!0,l({__type:nr.PROCESSED,response:{context:R,value:_}})}})()}catch(m){p(m)}});return{abortConfirmation:()=>{s&&(s(),s=void 0),r!=null&&(this.removeSignatureListener(r),r=void 0)},confirmationPromise:o}}async confirmTransactionUsingBlockHeightExceedanceStrategy({commitment:t,strategy:{abortSignal:e,lastValidBlockHeight:r,signature:s}}){let i=!1;const o=new Promise(S=>{const R=async()=>{try{return await this.getBlockHeight(t)}catch{return-1}};(async()=>{let _=await R();if(!i){for(;_<=r;)if(await Tr(1e3),i||(_=await R(),i))return;S({__type:nr.BLOCKHEIGHT_EXCEEDED})}})()}),{abortConfirmation:a,confirmationPromise:l}=this.getTransactionConfirmationPromise({commitment:t,signature:s}),p=this.getCancellationPromise(e);let m;try{const S=await Promise.race([p,l,o]);if(S.__type===nr.PROCESSED)m=S.response;else throw new zo(s)}finally{i=!0,a()}return m}async confirmTransactionUsingDurableNonceStrategy({commitment:t,strategy:{abortSignal:e,minContextSlot:r,nonceAccountPubkey:s,nonceValue:i,signature:o}}){let a=!1;const l=new Promise(_=>{let I=i,O=null;const x=async()=>{try{const{context:M,value:H}=await this.getNonceAndContext(s,{commitment:t,minContextSlot:r});return O=M.slot,H?.nonce}catch{return I}};(async()=>{if(I=await x(),!a)for(;;){if(i!==I){_({__type:nr.NONCE_INVALID,slotInWhichNonceDidAdvance:O});return}if(await Tr(2e3),a||(I=await x(),a))return}})()}),{abortConfirmation:p,confirmationPromise:m}=this.getTransactionConfirmationPromise({commitment:t,signature:o}),S=this.getCancellationPromise(e);let R;try{const _=await Promise.race([S,m,l]);if(_.__type===nr.PROCESSED)R=_.response;else{let I;for(;;){const O=await this.getSignatureStatus(o);if(O==null)break;if(O.context.slot<(_.slotInWhichNonceDidAdvance??r)){await Tr(400);continue}I=O;break}if(I?.value){const O=t||"finalized",{confirmationStatus:x}=I.value;switch(O){case"processed":case"recent":if(x!=="processed"&&x!=="confirmed"&&x!=="finalized")throw new Jr(o);break;case"confirmed":case"single":case"singleGossip":if(x!=="confirmed"&&x!=="finalized")throw new Jr(o);break;case"finalized":case"max":case"root":if(x!=="finalized")throw new Jr(o);break;default:}R={context:I.context,value:{err:I.value.err}}}else throw new Jr(o)}}finally{a=!0,p()}return R}async confirmTransactionUsingLegacyTimeoutStrategy({commitment:t,signature:e}){let r;const s=new Promise(l=>{let p=this._confirmTransactionInitialTimeout||6e4;switch(t){case"processed":case"recent":case"single":case"confirmed":case"singleGossip":{p=this._confirmTransactionInitialTimeout||3e4;break}}r=setTimeout(()=>l({__type:nr.TIMED_OUT,timeoutMs:p}),p)}),{abortConfirmation:i,confirmationPromise:o}=this.getTransactionConfirmationPromise({commitment:t,signature:e});let a;try{const l=await Promise.race([o,s]);if(l.__type===nr.PROCESSED)a=l.response;else throw new Ko(e,l.timeoutMs/1e3)}finally{clearTimeout(r),i()}return a}async getClusterNodes(){const t=await this._rpcRequest("getClusterNodes",[]),e=st(t,_t(at(Jy)));if("error"in e)throw new ft(e.error,"failed to get cluster nodes");return e.result}async getVoteAccounts(t){const e=this._buildArgs([],t),r=await this._rpcRequest("getVoteAccounts",e),s=st(r,Qy);if("error"in s)throw new ft(s.error,"failed to get vote accounts");return s.result}async getSlot(t){const{commitment:e,config:r}=Bt(t),s=this._buildArgs([],e,void 0,r),i=await this._rpcRequest("getSlot",s),o=st(i,_t(W()));if("error"in o)throw new ft(o.error,"failed to get slot");return o.result}async getSlotLeader(t){const{commitment:e,config:r}=Bt(t),s=this._buildArgs([],e,void 0,r),i=await this._rpcRequest("getSlotLeader",s),o=st(i,_t(nt()));if("error"in o)throw new ft(o.error,"failed to get slot leader");return o.result}async getSlotLeaders(t,e){const r=[t,e],s=await this._rpcRequest("getSlotLeaders",r),i=st(s,_t(at(Kt)));if("error"in i)throw new ft(i.error,"failed to get slot leaders");return i.result}async getSignatureStatus(t,e){const{context:r,value:s}=await this.getSignatureStatuses([t],e);It(s.length===1);const i=s[0];return{context:r,value:i}}async getSignatureStatuses(t,e){const r=[t];e&&r.push(e);const s=await this._rpcRequest("getSignatureStatuses",r),i=st(s,rg);if("error"in i)throw new ft(i.error,"failed to get signature status");return i.result}async getTransactionCount(t){const{commitment:e,config:r}=Bt(t),s=this._buildArgs([],e,void 0,r),i=await this._rpcRequest("getTransactionCount",s),o=st(i,_t(W()));if("error"in o)throw new ft(o.error,"failed to get transaction count");return o.result}async getTotalSupply(t){return(await this.getSupply({commitment:t,excludeNonCirculatingAccountsList:!0})).value.total}async getInflationGovernor(t){const e=this._buildArgs([],t),r=await this._rpcRequest("getInflationGovernor",e),s=st(r,Iy);if("error"in s)throw new ft(s.error,"failed to get inflation");return s.result}async getInflationReward(t,e,r){const{commitment:s,config:i}=Bt(r),o=this._buildArgs([t.map(p=>p.toBase58())],s,void 0,{...i,epoch:e??i?.epoch}),a=await this._rpcRequest("getInflationReward",o),l=st(a,ly);if("error"in l)throw new ft(l.error,"failed to get inflation reward");return l.result}async getInflationRate(){const t=await this._rpcRequest("getInflationRate",[]),e=st(t,Sy);if("error"in e)throw new ft(e.error,"failed to get inflation rate");return e.result}async getEpochInfo(t){const{commitment:e,config:r}=Bt(t),s=this._buildArgs([],e,void 0,r),i=await this._rpcRequest("getEpochInfo",s),o=st(i,Ty);if("error"in o)throw new ft(o.error,"failed to get epoch info");return o.result}async getEpochSchedule(){const t=await this._rpcRequest("getEpochSchedule",[]),e=st(t,Oy);if("error"in e)throw new ft(e.error,"failed to get epoch schedule");const r=e.result;return new nl(r.slotsPerEpoch,r.leaderScheduleSlotOffset,r.warmup,r.firstNormalEpoch,r.firstNormalSlot)}async getLeaderSchedule(){const t=await this._rpcRequest("getLeaderSchedule",[]),e=st(t,xy);if("error"in e)throw new ft(e.error,"failed to get leader schedule");return e.result}async getMinimumBalanceForRentExemption(t,e){const r=this._buildArgs([t],e),s=await this._rpcRequest("getMinimumBalanceForRentExemption",r),i=st(s,ng);return"error"in i?(console.warn("Unable to fetch minimum balance for rent exemption"),0):i.result}async getRecentBlockhashAndContext(t){const{context:e,value:{blockhash:r}}=await this.getLatestBlockhashAndContext(t);return{context:e,value:{blockhash:r,feeCalculator:{get lamportsPerSignature(){throw new Error("The capability to fetch `lamportsPerSignature` using the `getRecentBlockhash` API is no longer offered by the network. Use the `getFeeForMessage` API to obtain the fee for a given message.")},toJSON(){return{}}}}}}async getRecentPerformanceSamples(t){const e=await this._rpcRequest("getRecentPerformanceSamples",t?[t]:[]),r=st(e,gg);if("error"in r)throw new ft(r.error,"failed to get recent performance samples");return r.result}async getFeeCalculatorForBlockhash(t,e){const r=this._buildArgs([t],e),s=await this._rpcRequest("getFeeCalculatorForBlockhash",r),i=st(s,mg);if("error"in i)throw new ft(i.error,"failed to get fee calculator");const{context:o,value:a}=i.result;return{context:o,value:a!==null?a.feeCalculator:null}}async getFeeForMessage(t,e){const r=bt(t.serialize()).toString("base64"),s=this._buildArgs([r],e),i=await this._rpcRequest("getFeeForMessage",s),o=st(i,Yt(ct(W())));if("error"in o)throw new ft(o.error,"failed to get fee for message");if(o.result===null)throw new Error("invalid blockhash");return o.result}async getRecentPrioritizationFees(t){const e=t?.lockedWritableAccounts?.map(o=>o.toBase58()),r=e?.length?[e]:[],s=await this._rpcRequest("getRecentPrioritizationFees",r),i=st(s,ky);if("error"in i)throw new ft(i.error,"failed to get recent prioritization fees");return i.result}async getRecentBlockhash(t){try{return(await this.getRecentBlockhashAndContext(t)).value}catch(e){throw new Error("failed to get recent blockhash: "+e)}}async getLatestBlockhash(t){try{return(await this.getLatestBlockhashAndContext(t)).value}catch(e){throw new Error("failed to get recent blockhash: "+e)}}async getLatestBlockhashAndContext(t){const{commitment:e,config:r}=Bt(t),s=this._buildArgs([],e,void 0,r),i=await this._rpcRequest("getLatestBlockhash",s),o=st(i,dg);if("error"in o)throw new ft(o.error,"failed to get latest blockhash");return o.result}async isBlockhashValid(t,e){const{commitment:r,config:s}=Bt(e),i=this._buildArgs([t],r,void 0,s),o=await this._rpcRequest("isBlockhashValid",i),a=st(o,pg);if("error"in a)throw new ft(a.error,"failed to determine if the blockhash `"+t+"`is valid");return a.result}async getVersion(){const t=await this._rpcRequest("getVersion",[]),e=st(t,_t(wy));if("error"in e)throw new ft(e.error,"failed to get version");return e.result}async getGenesisHash(){const t=await this._rpcRequest("getGenesisHash",[]),e=st(t,_t(nt()));if("error"in e)throw new ft(e.error,"failed to get genesis hash");return e.result}async getBlock(t,e){const{commitment:r,config:s}=Bt(e),i=this._buildArgsAtLeastConfirmed([t],r,void 0,s),o=await this._rpcRequest("getBlock",i);try{switch(s?.transactionDetails){case"accounts":{const a=st(o,cg);if("error"in a)throw a.error;return a.result}case"none":{const a=st(o,ag);if("error"in a)throw a.error;return a.result}default:{const a=st(o,og);if("error"in a)throw a.error;const{result:l}=a;return l?{...l,transactions:l.transactions.map(({transaction:p,meta:m,version:S})=>({meta:m,transaction:{...p,message:Ds(S,p.message)},version:S}))}:null}}}catch(a){throw new ft(a,"failed to get confirmed block")}}async getParsedBlock(t,e){const{commitment:r,config:s}=Bt(e),i=this._buildArgsAtLeastConfirmed([t],r,"jsonParsed",s),o=await this._rpcRequest("getBlock",i);try{switch(s?.transactionDetails){case"accounts":{const a=st(o,lg);if("error"in a)throw a.error;return a.result}case"none":{const a=st(o,hg);if("error"in a)throw a.error;return a.result}default:{const a=st(o,ug);if("error"in a)throw a.error;return a.result}}}catch(a){throw new ft(a,"failed to get block")}}async getBlockProduction(t){let e,r;if(typeof t=="string")r=t;else if(t){const{commitment:a,...l}=t;r=a,e=l}const s=this._buildArgs([],r,"base64",e),i=await this._rpcRequest("getBlockProduction",s),o=st(i,Ey);if("error"in o)throw new ft(o.error,"failed to get block production information");return o.result}async getTransaction(t,e){const{commitment:r,config:s}=Bt(e),i=this._buildArgsAtLeastConfirmed([t],r,void 0,s),o=await this._rpcRequest("getTransaction",i),a=st(o,Hs);if("error"in a)throw new ft(a.error,"failed to get transaction");const l=a.result;return l&&{...l,transaction:{...l.transaction,message:Ds(l.version,l.transaction.message)}}}async getParsedTransaction(t,e){const{commitment:r,config:s}=Bt(e),i=this._buildArgsAtLeastConfirmed([t],r,"jsonParsed",s),o=await this._rpcRequest("getTransaction",i),a=st(o,Qn);if("error"in a)throw new ft(a.error,"failed to get transaction");return a.result}async getParsedTransactions(t,e){const{commitment:r,config:s}=Bt(e),i=t.map(l=>({methodName:"getTransaction",args:this._buildArgsAtLeastConfirmed([l],r,"jsonParsed",s)}));return(await this._rpcBatchRequest(i)).map(l=>{const p=st(l,Qn);if("error"in p)throw new ft(p.error,"failed to get transactions");return p.result})}async getTransactions(t,e){const{commitment:r,config:s}=Bt(e),i=t.map(l=>({methodName:"getTransaction",args:this._buildArgsAtLeastConfirmed([l],r,void 0,s)}));return(await this._rpcBatchRequest(i)).map(l=>{const p=st(l,Hs);if("error"in p)throw new ft(p.error,"failed to get transactions");const m=p.result;return m&&{...m,transaction:{...m.transaction,message:Ds(m.version,m.transaction.message)}}})}async getConfirmedBlock(t,e){const r=this._buildArgsAtLeastConfirmed([t],e),s=await this._rpcRequest("getBlock",r),i=st(s,fg);if("error"in i)throw new ft(i.error,"failed to get confirmed block");const o=i.result;if(!o)throw new Error("Confirmed block "+t+" not found");const a={...o,transactions:o.transactions.map(({transaction:l,meta:p})=>{const m=new qe(l.message);return{meta:p,transaction:{...l,message:m}}})};return{...a,transactions:a.transactions.map(({transaction:l,meta:p})=>({meta:p,transaction:At.populate(l.message,l.signatures)}))}}async getBlocks(t,e,r){const s=this._buildArgsAtLeastConfirmed(e!==void 0?[t,e]:[t],r),i=await this._rpcRequest("getBlocks",s),o=st(i,_t(at(W())));if("error"in o)throw new ft(o.error,"failed to get blocks");return o.result}async getBlockSignatures(t,e){const r=this._buildArgsAtLeastConfirmed([t],e,void 0,{transactionDetails:"signatures",rewards:!1}),s=await this._rpcRequest("getBlock",r),i=st(s,nc);if("error"in i)throw new ft(i.error,"failed to get block");const o=i.result;if(!o)throw new Error("Block "+t+" not found");return o}async getConfirmedBlockSignatures(t,e){const r=this._buildArgsAtLeastConfirmed([t],e,void 0,{transactionDetails:"signatures",rewards:!1}),s=await this._rpcRequest("getBlock",r),i=st(s,nc);if("error"in i)throw new ft(i.error,"failed to get confirmed block");const o=i.result;if(!o)throw new Error("Confirmed block "+t+" not found");return o}async getConfirmedTransaction(t,e){const r=this._buildArgsAtLeastConfirmed([t],e),s=await this._rpcRequest("getTransaction",r),i=st(s,Hs);if("error"in i)throw new ft(i.error,"failed to get transaction");const o=i.result;if(!o)return o;const a=new qe(o.transaction.message),l=o.transaction.signatures;return{...o,transaction:At.populate(a,l)}}async getParsedConfirmedTransaction(t,e){const r=this._buildArgsAtLeastConfirmed([t],e,"jsonParsed"),s=await this._rpcRequest("getTransaction",r),i=st(s,Qn);if("error"in i)throw new ft(i.error,"failed to get confirmed transaction");return i.result}async getParsedConfirmedTransactions(t,e){const r=t.map(o=>({methodName:"getTransaction",args:this._buildArgsAtLeastConfirmed([o],e,"jsonParsed")}));return(await this._rpcBatchRequest(r)).map(o=>{const a=st(o,Qn);if("error"in a)throw new ft(a.error,"failed to get confirmed transactions");return a.result})}async getConfirmedSignaturesForAddress(t,e,r){let s={},i=await this.getFirstAvailableBlock();for(;!("until"in s)&&(e--,!(e<=0||e<i));)try{const l=await this.getConfirmedBlockSignatures(e,"finalized");l.signatures.length>0&&(s.until=l.signatures[l.signatures.length-1].toString())}catch(l){if(l instanceof Error&&l.message.includes("skipped"))continue;throw l}let o=await this.getSlot("finalized");for(;!("before"in s)&&(r++,!(r>o));)try{const l=await this.getConfirmedBlockSignatures(r);l.signatures.length>0&&(s.before=l.signatures[l.signatures.length-1].toString())}catch(l){if(l instanceof Error&&l.message.includes("skipped"))continue;throw l}return(await this.getConfirmedSignaturesForAddress2(t,s)).map(l=>l.signature)}async getConfirmedSignaturesForAddress2(t,e,r){const s=this._buildArgsAtLeastConfirmed([t.toBase58()],r,void 0,e),i=await this._rpcRequest("getConfirmedSignaturesForAddress2",s),o=st(i,zy);if("error"in o)throw new ft(o.error,"failed to get confirmed signatures for address");return o.result}async getSignaturesForAddress(t,e,r){const s=this._buildArgsAtLeastConfirmed([t.toBase58()],r,void 0,e),i=await this._rpcRequest("getSignaturesForAddress",s),o=st(i,Ky);if("error"in o)throw new ft(o.error,"failed to get signatures for address");return o.result}async getAddressLookupTable(t,e){const{context:r,value:s}=await this.getAccountInfoAndContext(t,e);let i=null;return s!==null&&(i=new co({key:t,state:co.deserialize(s.data)})),{context:r,value:i}}async getNonceAndContext(t,e){const{context:r,value:s}=await this.getAccountInfoAndContext(t,e);let i=null;return s!==null&&(i=Ui.fromAccountData(s.data)),{context:r,value:i}}async getNonce(t,e){return await this.getNonceAndContext(t,e).then(r=>r.value).catch(r=>{throw new Error("failed to get nonce for account "+t.toBase58()+": "+r)})}async requestAirdrop(t,e){const r=await this._rpcRequest("requestAirdrop",[t.toBase58(),e]),s=st(r,wg);if("error"in s)throw new ft(s.error,`airdrop to ${t.toBase58()} failed`);return s.result}async _blockhashWithExpiryBlockHeight(t){if(!t){for(;this._pollingBlockhash;)await Tr(100);const r=Date.now()-this._blockhashInfo.lastFetch>=sl;if(this._blockhashInfo.latestBlockhash!==null&&!r)return this._blockhashInfo.latestBlockhash}return await this._pollNewBlockhash()}async _pollNewBlockhash(){this._pollingBlockhash=!0;try{const t=Date.now(),e=this._blockhashInfo.latestBlockhash,r=e?e.blockhash:null;for(let s=0;s<50;s++){const i=await this.getLatestBlockhash("finalized");if(r!==i.blockhash)return this._blockhashInfo={latestBlockhash:i,lastFetch:Date.now(),transactionSignatures:[],simulatedSignatures:[]},i;await Tr(tl/2)}throw new Error(`Unable to obtain a new blockhash after ${Date.now()-t}ms`)}finally{this._pollingBlockhash=!1}}async getStakeMinimumDelegation(t){const{commitment:e,config:r}=Bt(t),s=this._buildArgs([],e,"base64",r),i=await this._rpcRequest("getStakeMinimumDelegation",s),o=st(i,Yt(W()));if("error"in o)throw new ft(o.error,"failed to get stake minimum delegation");return o.result}async simulateTransaction(t,e,r){if("message"in t){const O=t.serialize(),x=ht.Buffer.from(O).toString("base64");if(Array.isArray(e)||r!==void 0)throw new Error("Invalid arguments");const M=e||{};M.encoding="base64","commitment"in M||(M.commitment=this.commitment),e&&typeof e=="object"&&"innerInstructions"in e&&(M.innerInstructions=e.innerInstructions);const H=[x,M],P=await this._rpcRequest("simulateTransaction",H),q=st(P,ec);if("error"in q)throw new Error("failed to simulate transaction: "+q.error.message);return q.result}let s;if(t instanceof At){let I=t;s=new At,s.feePayer=I.feePayer,s.instructions=t.instructions,s.nonceInfo=I.nonceInfo,s.signatures=I.signatures}else s=At.populate(t),s._message=s._json=void 0;if(e!==void 0&&!Array.isArray(e))throw new Error("Invalid arguments");const i=e;if(s.nonceInfo&&i)s.sign(...i);else{let I=this._disableBlockhashCaching;for(;;){const O=await this._blockhashWithExpiryBlockHeight(I);if(s.lastValidBlockHeight=O.lastValidBlockHeight,s.recentBlockhash=O.blockhash,!i)break;if(s.sign(...i),!s.signature)throw new Error("!signature");const x=s.signature.toString("base64");if(!this._blockhashInfo.simulatedSignatures.includes(x)&&!this._blockhashInfo.transactionSignatures.includes(x)){this._blockhashInfo.simulatedSignatures.push(x);break}else I=!0}}const o=s._compile(),a=o.serialize(),p=s._serialize(a).toString("base64"),m={encoding:"base64",commitment:this.commitment};if(r){const I=(Array.isArray(r)?r:o.nonProgramIds()).map(O=>O.toBase58());m.accounts={encoding:"base64",addresses:I}}i&&(m.sigVerify=!0),e&&typeof e=="object"&&"innerInstructions"in e&&(m.innerInstructions=e.innerInstructions);const S=[p,m],R=await this._rpcRequest("simulateTransaction",S),_=st(R,ec);if("error"in _){let I;if("data"in _.error&&(I=_.error.data.logs,I&&Array.isArray(I))){const O=`
    `,x=O+I.join(O);console.error(_.error.message,x)}throw new Ar({action:"simulate",signature:"",transactionMessage:_.error.message,logs:I})}return _.result}async sendTransaction(t,e,r){if("version"in t){if(e&&Array.isArray(e))throw new Error("Invalid arguments");const o=t.serialize();return await this.sendRawTransaction(o,e)}if(e===void 0||!Array.isArray(e))throw new Error("Invalid arguments");const s=e;if(t.nonceInfo)t.sign(...s);else{let o=this._disableBlockhashCaching;for(;;){const a=await this._blockhashWithExpiryBlockHeight(o);if(t.lastValidBlockHeight=a.lastValidBlockHeight,t.recentBlockhash=a.blockhash,t.sign(...s),!t.signature)throw new Error("!signature");const l=t.signature.toString("base64");if(this._blockhashInfo.transactionSignatures.includes(l))o=!0;else{this._blockhashInfo.transactionSignatures.push(l);break}}}const i=t.serialize();return await this.sendRawTransaction(i,r)}async sendRawTransaction(t,e){const r=bt(t).toString("base64");return await this.sendEncodedTransaction(r,e)}async sendEncodedTransaction(t,e){const r={encoding:"base64"},s=e&&e.skipPreflight,i=s===!0?"processed":e&&e.preflightCommitment||this.commitment;e&&e.maxRetries!=null&&(r.maxRetries=e.maxRetries),e&&e.minContextSlot!=null&&(r.minContextSlot=e.minContextSlot),s&&(r.skipPreflight=s),i&&(r.preflightCommitment=i);const o=[t,r],a=await this._rpcRequest("sendTransaction",o),l=st(a,_g);if("error"in l){let p;throw"data"in l.error&&(p=l.error.data.logs),new Ar({action:s?"send":"simulate",signature:"",transactionMessage:l.error.message,logs:p})}return l.result}_wsOnOpen(){this._rpcWebSocketConnected=!0,this._rpcWebSocketHeartbeat=setInterval(()=>{(async()=>{try{await this._rpcWebSocket.notify("ping")}catch{}})()},5e3),this._updateSubscriptions()}_wsOnError(t){this._rpcWebSocketConnected=!1,console.error("ws error:",t.message)}_wsOnClose(t){if(this._rpcWebSocketConnected=!1,this._rpcWebSocketGeneration=(this._rpcWebSocketGeneration+1)%Number.MAX_SAFE_INTEGER,this._rpcWebSocketIdleTimeout&&(clearTimeout(this._rpcWebSocketIdleTimeout),this._rpcWebSocketIdleTimeout=null),this._rpcWebSocketHeartbeat&&(clearInterval(this._rpcWebSocketHeartbeat),this._rpcWebSocketHeartbeat=null),t===1e3){this._updateSubscriptions();return}this._subscriptionCallbacksByServerSubscriptionId={},Object.entries(this._subscriptionsByHash).forEach(([e,r])=>{this._setSubscription(e,{...r,state:"pending"})})}_setSubscription(t,e){const r=this._subscriptionsByHash[t]?.state;if(this._subscriptionsByHash[t]=e,r!==e.state){const s=this._subscriptionStateChangeCallbacksByHash[t];s&&s.forEach(i=>{try{i(e.state)}catch{}})}}_onSubscriptionStateChange(t,e){var i;const r=this._subscriptionHashByClientSubscriptionId[t];if(r==null)return()=>{};const s=(i=this._subscriptionStateChangeCallbacksByHash)[r]||(i[r]=new Set);return s.add(e),()=>{s.delete(e),s.size===0&&delete this._subscriptionStateChangeCallbacksByHash[r]}}async _updateSubscriptions(){if(Object.keys(this._subscriptionsByHash).length===0){this._rpcWebSocketConnected&&(this._rpcWebSocketConnected=!1,this._rpcWebSocketIdleTimeout=setTimeout(()=>{this._rpcWebSocketIdleTimeout=null;try{this._rpcWebSocket.close()}catch(r){r instanceof Error&&console.log(`Error when closing socket connection: ${r.message}`)}},500));return}if(this._rpcWebSocketIdleTimeout!==null&&(clearTimeout(this._rpcWebSocketIdleTimeout),this._rpcWebSocketIdleTimeout=null,this._rpcWebSocketConnected=!0),!this._rpcWebSocketConnected){this._rpcWebSocket.connect();return}const t=this._rpcWebSocketGeneration,e=()=>t===this._rpcWebSocketGeneration;await Promise.all(Object.keys(this._subscriptionsByHash).map(async r=>{const s=this._subscriptionsByHash[r];if(s!==void 0)switch(s.state){case"pending":case"unsubscribed":if(s.callbacks.size===0){delete this._subscriptionsByHash[r],s.state==="unsubscribed"&&delete this._subscriptionCallbacksByServerSubscriptionId[s.serverSubscriptionId],await this._updateSubscriptions();return}await(async()=>{const{args:i,method:o}=s;try{this._setSubscription(r,{...s,state:"subscribing"});const a=await this._rpcWebSocket.call(o,i);this._setSubscription(r,{...s,serverSubscriptionId:a,state:"subscribed"}),this._subscriptionCallbacksByServerSubscriptionId[a]=s.callbacks,await this._updateSubscriptions()}catch(a){if(console.error(`Received ${a instanceof Error?"":"JSON-RPC "}error calling \`${o}\``,{args:i,error:a}),!e())return;this._setSubscription(r,{...s,state:"pending"}),await this._updateSubscriptions()}})();break;case"subscribed":s.callbacks.size===0&&await(async()=>{const{serverSubscriptionId:i,unsubscribeMethod:o}=s;if(this._subscriptionsAutoDisposedByRpc.has(i))this._subscriptionsAutoDisposedByRpc.delete(i);else{this._setSubscription(r,{...s,state:"unsubscribing"}),this._setSubscription(r,{...s,state:"unsubscribing"});try{await this._rpcWebSocket.call(o,[i])}catch(a){if(a instanceof Error&&console.error(`${o} error:`,a.message),!e())return;this._setSubscription(r,{...s,state:"subscribed"}),await this._updateSubscriptions();return}}this._setSubscription(r,{...s,state:"unsubscribed"}),await this._updateSubscriptions()})();break}}))}_handleServerNotification(t,e){const r=this._subscriptionCallbacksByServerSubscriptionId[t];r!==void 0&&r.forEach(s=>{try{s(...e)}catch(i){console.error(i)}})}_wsOnAccountNotification(t){const{result:e,subscription:r}=st(t,qy);this._handleServerNotification(r,[e.value,e.context])}_makeSubscription(t,e){const r=this._nextClientSubscriptionId++,s=Ja([t.method,e]),i=this._subscriptionsByHash[s];return i===void 0?this._subscriptionsByHash[s]={...t,args:e,callbacks:new Set([t.callback]),state:"pending"}:i.callbacks.add(t.callback),this._subscriptionHashByClientSubscriptionId[r]=s,this._subscriptionDisposeFunctionsByClientSubscriptionId[r]=async()=>{delete this._subscriptionDisposeFunctionsByClientSubscriptionId[r],delete this._subscriptionHashByClientSubscriptionId[r];const o=this._subscriptionsByHash[s];It(o!==void 0,`Could not find a \`Subscription\` when tearing down client subscription #${r}`),o.callbacks.delete(t.callback),await this._updateSubscriptions()},this._updateSubscriptions(),r}onAccountChange(t,e,r){const{commitment:s,config:i}=Bt(r),o=this._buildArgs([t.toBase58()],s||this._commitment||"finalized","base64",i);return this._makeSubscription({callback:e,method:"accountSubscribe",unsubscribeMethod:"accountUnsubscribe"},o)}async removeAccountChangeListener(t){await this._unsubscribeClientSubscription(t,"account change")}_wsOnProgramAccountNotification(t){const{result:e,subscription:r}=st(t,Vy);this._handleServerNotification(r,[{accountId:e.value.pubkey,accountInfo:e.value.account},e.context])}onProgramAccountChange(t,e,r,s){const{commitment:i,config:o}=Bt(r),a=this._buildArgs([t.toBase58()],i||this._commitment||"finalized","base64",o||(s?{filters:tc(s)}:void 0));return this._makeSubscription({callback:e,method:"programSubscribe",unsubscribeMethod:"programUnsubscribe"},a)}async removeProgramAccountChangeListener(t){await this._unsubscribeClientSubscription(t,"program account change")}onLogs(t,e,r){const s=this._buildArgs([typeof t=="object"?{mentions:[t.toString()]}:t],r||this._commitment||"finalized");return this._makeSubscription({callback:e,method:"logsSubscribe",unsubscribeMethod:"logsUnsubscribe"},s)}async removeOnLogsListener(t){await this._unsubscribeClientSubscription(t,"logs")}_wsOnLogsNotification(t){const{result:e,subscription:r}=st(t,Eg);this._handleServerNotification(r,[e.value,e.context])}_wsOnSlotNotification(t){const{result:e,subscription:r}=st(t,Gy);this._handleServerNotification(r,[e])}onSlotChange(t){return this._makeSubscription({callback:t,method:"slotSubscribe",unsubscribeMethod:"slotUnsubscribe"},[])}async removeSlotChangeListener(t){await this._unsubscribeClientSubscription(t,"slot change")}_wsOnSlotUpdatesNotification(t){const{result:e,subscription:r}=st(t,Yy);this._handleServerNotification(r,[e])}onSlotUpdate(t){return this._makeSubscription({callback:t,method:"slotsUpdatesSubscribe",unsubscribeMethod:"slotsUpdatesUnsubscribe"},[])}async removeSlotUpdateListener(t){await this._unsubscribeClientSubscription(t,"slot update")}async _unsubscribeClientSubscription(t,e){const r=this._subscriptionDisposeFunctionsByClientSubscriptionId[t];r?await r():console.warn(`Ignored unsubscribe request because an active subscription with id \`${t}\` for '${e}' events could not be found.`)}_buildArgs(t,e,r,s){const i=e||this._commitment;if(i||r||s){let o={};r&&(o.encoding=r),i&&(o.commitment=i),s&&(o=Object.assign(o,s)),t.push(o)}return t}_buildArgsAtLeastConfirmed(t,e,r,s){const i=e||this._commitment;if(i&&!["confirmed","finalized"].includes(i))throw new Error("Using Connection with default commitment: `"+this._commitment+"`, but method requires at least `confirmed`");return this._buildArgs(t,e,r,s)}_wsOnSignatureNotification(t){const{result:e,subscription:r}=st(t,Zy);e.value!=="receivedSignature"&&this._subscriptionsAutoDisposedByRpc.add(r),this._handleServerNotification(r,e.value==="receivedSignature"?[{type:"received"},e.context]:[{type:"status",result:e.value},e.context])}onSignature(t,e,r){const s=this._buildArgs([t],r||this._commitment||"finalized"),i=this._makeSubscription({callback:(o,a)=>{if(o.type==="status"){e(o.result,a);try{this.removeSignatureListener(i)}catch{}}},method:"signatureSubscribe",unsubscribeMethod:"signatureUnsubscribe"},s);return i}onSignatureWithOptions(t,e,r){const{commitment:s,...i}={...r,commitment:r&&r.commitment||this._commitment||"finalized"},o=this._buildArgs([t],s,void 0,i),a=this._makeSubscription({callback:(l,p)=>{e(l,p);try{this.removeSignatureListener(a)}catch{}},method:"signatureSubscribe",unsubscribeMethod:"signatureUnsubscribe"},o);return a}async removeSignatureListener(t){await this._unsubscribeClientSubscription(t,"signature result")}_wsOnRootNotification(t){const{result:e,subscription:r}=st(t,Xy);this._handleServerNotification(r,[e])}onRootChange(t){return this._makeSubscription({callback:t,method:"rootSubscribe",unsubscribeMethod:"rootUnsubscribe"},[])}async removeRootChangeListener(t){await this._unsubscribeClientSubscription(t,"root change")}}class rn{constructor(t){this._keypair=void 0,this._keypair=t??ja()}static generate(){return new rn(ja())}static fromSecretKey(t,e){if(t.byteLength!==64)throw new Error("bad secret key size");const r=t.slice(32,64);if(!e||!e.skipValidation){const s=t.slice(0,32),i=Ei(s);for(let o=0;o<32;o++)if(r[o]!==i[o])throw new Error("provided secretKey is invalid")}return new rn({publicKey:r,secretKey:t})}static fromSeed(t){const e=Ei(t),r=new Uint8Array(64);return r.set(t),r.set(e,32),new rn({publicKey:e,secretKey:r})}get publicKey(){return new rt(this._keypair.publicKey)}get secretKey(){return new Uint8Array(this._keypair.secretKey)}}const cr=Object.freeze({CreateLookupTable:{index:0,layout:D.struct([D.u32("instruction"),ln("recentSlot"),D.u8("bumpSeed")])},FreezeLookupTable:{index:1,layout:D.struct([D.u32("instruction")])},ExtendLookupTable:{index:2,layout:D.struct([D.u32("instruction"),ln(),D.seq(Et(),D.offset(D.u32(),-8),"addresses")])},DeactivateLookupTable:{index:3,layout:D.struct([D.u32("instruction")])},CloseLookupTable:{index:4,layout:D.struct([D.u32("instruction")])}});class Ag{constructor(){}static decodeInstructionType(t){this.checkProgramId(t.programId);const r=D.u32("instruction").decode(t.data);let s;for(const[i,o]of Object.entries(cr))if(o.index==r){s=i;break}if(!s)throw new Error("Invalid Instruction. Should be a LookupTable Instruction");return s}static decodeCreateLookupTable(t){this.checkProgramId(t.programId),this.checkKeysLength(t.keys,4);const{recentSlot:e}=Tt(cr.CreateLookupTable,t.data);return{authority:t.keys[1].pubkey,payer:t.keys[2].pubkey,recentSlot:Number(e)}}static decodeExtendLookupTable(t){if(this.checkProgramId(t.programId),t.keys.length<2)throw new Error(`invalid instruction; found ${t.keys.length} keys, expected at least 2`);const{addresses:e}=Tt(cr.ExtendLookupTable,t.data);return{lookupTable:t.keys[0].pubkey,authority:t.keys[1].pubkey,payer:t.keys.length>2?t.keys[2].pubkey:void 0,addresses:e.map(r=>new rt(r))}}static decodeCloseLookupTable(t){return this.checkProgramId(t.programId),this.checkKeysLength(t.keys,3),{lookupTable:t.keys[0].pubkey,authority:t.keys[1].pubkey,recipient:t.keys[2].pubkey}}static decodeFreezeLookupTable(t){return this.checkProgramId(t.programId),this.checkKeysLength(t.keys,2),{lookupTable:t.keys[0].pubkey,authority:t.keys[1].pubkey}}static decodeDeactivateLookupTable(t){return this.checkProgramId(t.programId),this.checkKeysLength(t.keys,2),{lookupTable:t.keys[0].pubkey,authority:t.keys[1].pubkey}}static checkProgramId(t){if(!t.equals(Yo.programId))throw new Error("invalid instruction; programId is not AddressLookupTable Program")}static checkKeysLength(t,e){if(t.length<e)throw new Error(`invalid instruction; found ${t.length} keys, expected at least ${e}`)}}class Yo{constructor(){}static createLookupTable(t){const[e,r]=rt.findProgramAddressSync([t.authority.toBuffer(),Nu().encode(t.recentSlot)],this.programId),s=cr.CreateLookupTable,i=vt(s,{recentSlot:BigInt(t.recentSlot),bumpSeed:r}),o=[{pubkey:e,isSigner:!1,isWritable:!0},{pubkey:t.authority,isSigner:!0,isWritable:!1},{pubkey:t.payer,isSigner:!0,isWritable:!0},{pubkey:ye.programId,isSigner:!1,isWritable:!1}];return[new xt({programId:this.programId,keys:o,data:i}),e]}static freezeLookupTable(t){const e=cr.FreezeLookupTable,r=vt(e),s=[{pubkey:t.lookupTable,isSigner:!1,isWritable:!0},{pubkey:t.authority,isSigner:!0,isWritable:!1}];return new xt({programId:this.programId,keys:s,data:r})}static extendLookupTable(t){const e=cr.ExtendLookupTable,r=vt(e,{addresses:t.addresses.map(i=>i.toBytes())}),s=[{pubkey:t.lookupTable,isSigner:!1,isWritable:!0},{pubkey:t.authority,isSigner:!0,isWritable:!1}];return t.payer&&s.push({pubkey:t.payer,isSigner:!0,isWritable:!0},{pubkey:ye.programId,isSigner:!1,isWritable:!1}),new xt({programId:this.programId,keys:s,data:r})}static deactivateLookupTable(t){const e=cr.DeactivateLookupTable,r=vt(e),s=[{pubkey:t.lookupTable,isSigner:!1,isWritable:!0},{pubkey:t.authority,isSigner:!0,isWritable:!1}];return new xt({programId:this.programId,keys:s,data:r})}static closeLookupTable(t){const e=cr.CloseLookupTable,r=vt(e),s=[{pubkey:t.lookupTable,isSigner:!1,isWritable:!0},{pubkey:t.authority,isSigner:!0,isWritable:!1},{pubkey:t.recipient,isSigner:!1,isWritable:!0}];return new xt({programId:this.programId,keys:s,data:r})}}Yo.programId=new rt("AddressLookupTab1e1111111111111111111111111");class Ig{constructor(){}static decodeInstructionType(t){this.checkProgramId(t.programId);const r=D.u8("instruction").decode(t.data);let s;for(const[i,o]of Object.entries(Ye))if(o.index==r){s=i;break}if(!s)throw new Error("Instruction type incorrect; not a ComputeBudgetInstruction");return s}static decodeRequestUnits(t){this.checkProgramId(t.programId);const{units:e,additionalFee:r}=Tt(Ye.RequestUnits,t.data);return{units:e,additionalFee:r}}static decodeRequestHeapFrame(t){this.checkProgramId(t.programId);const{bytes:e}=Tt(Ye.RequestHeapFrame,t.data);return{bytes:e}}static decodeSetComputeUnitLimit(t){this.checkProgramId(t.programId);const{units:e}=Tt(Ye.SetComputeUnitLimit,t.data);return{units:e}}static decodeSetComputeUnitPrice(t){this.checkProgramId(t.programId);const{microLamports:e}=Tt(Ye.SetComputeUnitPrice,t.data);return{microLamports:e}}static checkProgramId(t){if(!t.equals(Zo.programId))throw new Error("invalid instruction; programId is not ComputeBudgetProgram")}}const Ye=Object.freeze({RequestUnits:{index:0,layout:D.struct([D.u8("instruction"),D.u32("units"),D.u32("additionalFee")])},RequestHeapFrame:{index:1,layout:D.struct([D.u8("instruction"),D.u32("bytes")])},SetComputeUnitLimit:{index:2,layout:D.struct([D.u8("instruction"),D.u32("units")])},SetComputeUnitPrice:{index:3,layout:D.struct([D.u8("instruction"),ln("microLamports")])}});class Zo{constructor(){}static requestUnits(t){const e=Ye.RequestUnits,r=vt(e,t);return new xt({keys:[],programId:this.programId,data:r})}static requestHeapFrame(t){const e=Ye.RequestHeapFrame,r=vt(e,t);return new xt({keys:[],programId:this.programId,data:r})}static setComputeUnitLimit(t){const e=Ye.SetComputeUnitLimit,r=vt(e,t);return new xt({keys:[],programId:this.programId,data:r})}static setComputeUnitPrice(t){const e=Ye.SetComputeUnitPrice,r=vt(e,{microLamports:BigInt(t.microLamports)});return new xt({keys:[],programId:this.programId,data:r})}}Zo.programId=new rt("ComputeBudget111111111111111111111111111111");const ic=64,sc=32,oc=64,ac=D.struct([D.u8("numSignatures"),D.u8("padding"),D.u16("signatureOffset"),D.u16("signatureInstructionIndex"),D.u16("publicKeyOffset"),D.u16("publicKeyInstructionIndex"),D.u16("messageDataOffset"),D.u16("messageDataSize"),D.u16("messageInstructionIndex")]);class Fi{constructor(){}static createInstructionWithPublicKey(t){const{publicKey:e,message:r,signature:s,instructionIndex:i}=t;It(e.length===sc,`Public Key must be ${sc} bytes but received ${e.length} bytes`),It(s.length===oc,`Signature must be ${oc} bytes but received ${s.length} bytes`);const o=ac.span,a=o+e.length,l=a+s.length,p=1,m=ht.Buffer.alloc(l+r.length),S=i??65535;return ac.encode({numSignatures:p,padding:0,signatureOffset:a,signatureInstructionIndex:S,publicKeyOffset:o,publicKeyInstructionIndex:S,messageDataOffset:l,messageDataSize:r.length,messageInstructionIndex:S},m),m.fill(e,o),m.fill(s,a),m.fill(r,l),new xt({keys:[],programId:Fi.programId,data:m})}static createInstructionWithPrivateKey(t){const{privateKey:e,message:r,instructionIndex:s}=t;It(e.length===ic,`Private key must be ${ic} bytes but received ${e.length} bytes`);try{const i=rn.fromSecretKey(e),o=i.publicKey.toBytes(),a=Ho(r,i.secretKey);return this.createInstructionWithPublicKey({publicKey:o,message:r,signature:a,instructionIndex:s})}catch(i){throw new Error(`Error creating instruction; ${i}`)}}}Fi.programId=new rt("Ed25519SigVerify111111111111111111111111111");const Sg=(n,t)=>{const e=Do.sign(n,t);return[e.toCompactRawBytes(),e.recovery]};Do.utils.isValidPrivateKey;const kg=Do.getPublicKey,cc=32,Fs=20,uc=64,Tg=11,zs=D.struct([D.u8("numSignatures"),D.u16("signatureOffset"),D.u8("signatureInstructionIndex"),D.u16("ethAddressOffset"),D.u8("ethAddressInstructionIndex"),D.u16("messageDataOffset"),D.u16("messageDataSize"),D.u8("messageInstructionIndex"),D.blob(20,"ethAddress"),D.blob(64,"signature"),D.u8("recoveryId")]);class nn{constructor(){}static publicKeyToEthAddress(t){It(t.length===uc,`Public key must be ${uc} bytes but received ${t.length} bytes`);try{return ht.Buffer.from(Va(bt(t))).slice(-Fs)}catch(e){throw new Error(`Error constructing Ethereum address: ${e}`)}}static createInstructionWithPublicKey(t){const{publicKey:e,message:r,signature:s,recoveryId:i,instructionIndex:o}=t;return nn.createInstructionWithEthAddress({ethAddress:nn.publicKeyToEthAddress(e),message:r,signature:s,recoveryId:i,instructionIndex:o})}static createInstructionWithEthAddress(t){const{ethAddress:e,message:r,signature:s,recoveryId:i,instructionIndex:o=0}=t;let a;typeof e=="string"?e.startsWith("0x")?a=ht.Buffer.from(e.substr(2),"hex"):a=ht.Buffer.from(e,"hex"):a=e,It(a.length===Fs,`Address must be ${Fs} bytes but received ${a.length} bytes`);const l=1+Tg,p=l,m=l+a.length,S=m+s.length+1,R=1,_=ht.Buffer.alloc(zs.span+r.length);return zs.encode({numSignatures:R,signatureOffset:m,signatureInstructionIndex:o,ethAddressOffset:p,ethAddressInstructionIndex:o,messageDataOffset:S,messageDataSize:r.length,messageInstructionIndex:o,signature:bt(s),ethAddress:bt(a),recoveryId:i},_),_.fill(bt(r),zs.span),new xt({keys:[],programId:nn.programId,data:_})}static createInstructionWithPrivateKey(t){const{privateKey:e,message:r,instructionIndex:s}=t;It(e.length===cc,`Private key must be ${cc} bytes but received ${e.length} bytes`);try{const i=bt(e),o=kg(i,!1).slice(1),a=ht.Buffer.from(Va(bt(r))),[l,p]=Sg(a,i);return this.createInstructionWithPublicKey({publicKey:o,message:r,signature:l,recoveryId:p,instructionIndex:s})}catch(i){throw new Error(`Error creating instruction; ${i}`)}}}nn.programId=new rt("KeccakSecp256k11111111111111111111111111111");var yl;const gl=new rt("StakeConfig11111111111111111111111111111111");class ml{constructor(t,e){this.staker=void 0,this.withdrawer=void 0,this.staker=t,this.withdrawer=e}}class Dn{constructor(t,e,r){this.unixTimestamp=void 0,this.epoch=void 0,this.custodian=void 0,this.unixTimestamp=t,this.epoch=e,this.custodian=r}}yl=Dn;Dn.default=new yl(0,0,rt.default);class Og{constructor(){}static decodeInstructionType(t){this.checkProgramId(t.programId);const r=D.u32("instruction").decode(t.data);let s;for(const[i,o]of Object.entries(we))if(o.index==r){s=i;break}if(!s)throw new Error("Instruction type incorrect; not a StakeInstruction");return s}static decodeInitialize(t){this.checkProgramId(t.programId),this.checkKeyLength(t.keys,2);const{authorized:e,lockup:r}=Tt(we.Initialize,t.data);return{stakePubkey:t.keys[0].pubkey,authorized:new ml(new rt(e.staker),new rt(e.withdrawer)),lockup:new Dn(r.unixTimestamp,r.epoch,new rt(r.custodian))}}static decodeDelegate(t){return this.checkProgramId(t.programId),this.checkKeyLength(t.keys,6),Tt(we.Delegate,t.data),{stakePubkey:t.keys[0].pubkey,votePubkey:t.keys[1].pubkey,authorizedPubkey:t.keys[5].pubkey}}static decodeAuthorize(t){this.checkProgramId(t.programId),this.checkKeyLength(t.keys,3);const{newAuthorized:e,stakeAuthorizationType:r}=Tt(we.Authorize,t.data),s={stakePubkey:t.keys[0].pubkey,authorizedPubkey:t.keys[2].pubkey,newAuthorizedPubkey:new rt(e),stakeAuthorizationType:{index:r}};return t.keys.length>3&&(s.custodianPubkey=t.keys[3].pubkey),s}static decodeAuthorizeWithSeed(t){this.checkProgramId(t.programId),this.checkKeyLength(t.keys,2);const{newAuthorized:e,stakeAuthorizationType:r,authoritySeed:s,authorityOwner:i}=Tt(we.AuthorizeWithSeed,t.data),o={stakePubkey:t.keys[0].pubkey,authorityBase:t.keys[1].pubkey,authoritySeed:s,authorityOwner:new rt(i),newAuthorizedPubkey:new rt(e),stakeAuthorizationType:{index:r}};return t.keys.length>3&&(o.custodianPubkey=t.keys[3].pubkey),o}static decodeSplit(t){this.checkProgramId(t.programId),this.checkKeyLength(t.keys,3);const{lamports:e}=Tt(we.Split,t.data);return{stakePubkey:t.keys[0].pubkey,splitStakePubkey:t.keys[1].pubkey,authorizedPubkey:t.keys[2].pubkey,lamports:e}}static decodeMerge(t){return this.checkProgramId(t.programId),this.checkKeyLength(t.keys,3),Tt(we.Merge,t.data),{stakePubkey:t.keys[0].pubkey,sourceStakePubKey:t.keys[1].pubkey,authorizedPubkey:t.keys[4].pubkey}}static decodeWithdraw(t){this.checkProgramId(t.programId),this.checkKeyLength(t.keys,5);const{lamports:e}=Tt(we.Withdraw,t.data),r={stakePubkey:t.keys[0].pubkey,toPubkey:t.keys[1].pubkey,authorizedPubkey:t.keys[4].pubkey,lamports:e};return t.keys.length>5&&(r.custodianPubkey=t.keys[5].pubkey),r}static decodeDeactivate(t){return this.checkProgramId(t.programId),this.checkKeyLength(t.keys,3),Tt(we.Deactivate,t.data),{stakePubkey:t.keys[0].pubkey,authorizedPubkey:t.keys[2].pubkey}}static checkProgramId(t){if(!t.equals(zi.programId))throw new Error("invalid instruction; programId is not StakeProgram")}static checkKeyLength(t,e){if(t.length<e)throw new Error(`invalid instruction; found ${t.length} keys, expected at least ${e}`)}}const we=Object.freeze({Initialize:{index:0,layout:D.struct([D.u32("instruction"),Bp(),Mp()])},Authorize:{index:1,layout:D.struct([D.u32("instruction"),Et("newAuthorized"),D.u32("stakeAuthorizationType")])},Delegate:{index:2,layout:D.struct([D.u32("instruction")])},Split:{index:3,layout:D.struct([D.u32("instruction"),D.ns64("lamports")])},Withdraw:{index:4,layout:D.struct([D.u32("instruction"),D.ns64("lamports")])},Deactivate:{index:5,layout:D.struct([D.u32("instruction")])},Merge:{index:7,layout:D.struct([D.u32("instruction")])},AuthorizeWithSeed:{index:8,layout:D.struct([D.u32("instruction"),Et("newAuthorized"),D.u32("stakeAuthorizationType"),Cr("authoritySeed"),Et("authorityOwner")])}}),xg=Object.freeze({Staker:{index:0},Withdrawer:{index:1}});class zi{constructor(){}static initialize(t){const{stakePubkey:e,authorized:r,lockup:s}=t,i=s||Dn.default,o=we.Initialize,a=vt(o,{authorized:{staker:bt(r.staker.toBuffer()),withdrawer:bt(r.withdrawer.toBuffer())},lockup:{unixTimestamp:i.unixTimestamp,epoch:i.epoch,custodian:bt(i.custodian.toBuffer())}}),l={keys:[{pubkey:e,isSigner:!1,isWritable:!0},{pubkey:un,isSigner:!1,isWritable:!1}],programId:this.programId,data:a};return new xt(l)}static createAccountWithSeed(t){const e=new At;e.add(ye.createAccountWithSeed({fromPubkey:t.fromPubkey,newAccountPubkey:t.stakePubkey,basePubkey:t.basePubkey,seed:t.seed,lamports:t.lamports,space:this.space,programId:this.programId}));const{stakePubkey:r,authorized:s,lockup:i}=t;return e.add(this.initialize({stakePubkey:r,authorized:s,lockup:i}))}static createAccount(t){const e=new At;e.add(ye.createAccount({fromPubkey:t.fromPubkey,newAccountPubkey:t.stakePubkey,lamports:t.lamports,space:this.space,programId:this.programId}));const{stakePubkey:r,authorized:s,lockup:i}=t;return e.add(this.initialize({stakePubkey:r,authorized:s,lockup:i}))}static delegate(t){const{stakePubkey:e,authorizedPubkey:r,votePubkey:s}=t,i=we.Delegate,o=vt(i);return new At().add({keys:[{pubkey:e,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!1},{pubkey:We,isSigner:!1,isWritable:!1},{pubkey:ui,isSigner:!1,isWritable:!1},{pubkey:gl,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!1}],programId:this.programId,data:o})}static authorize(t){const{stakePubkey:e,authorizedPubkey:r,newAuthorizedPubkey:s,stakeAuthorizationType:i,custodianPubkey:o}=t,a=we.Authorize,l=vt(a,{newAuthorized:bt(s.toBuffer()),stakeAuthorizationType:i.index}),p=[{pubkey:e,isSigner:!1,isWritable:!0},{pubkey:We,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!0,isWritable:!1}];return o&&p.push({pubkey:o,isSigner:!0,isWritable:!1}),new At().add({keys:p,programId:this.programId,data:l})}static authorizeWithSeed(t){const{stakePubkey:e,authorityBase:r,authoritySeed:s,authorityOwner:i,newAuthorizedPubkey:o,stakeAuthorizationType:a,custodianPubkey:l}=t,p=we.AuthorizeWithSeed,m=vt(p,{newAuthorized:bt(o.toBuffer()),stakeAuthorizationType:a.index,authoritySeed:s,authorityOwner:bt(i.toBuffer())}),S=[{pubkey:e,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!0,isWritable:!1},{pubkey:We,isSigner:!1,isWritable:!1}];return l&&S.push({pubkey:l,isSigner:!0,isWritable:!1}),new At().add({keys:S,programId:this.programId,data:m})}static splitInstruction(t){const{stakePubkey:e,authorizedPubkey:r,splitStakePubkey:s,lamports:i}=t,o=we.Split,a=vt(o,{lamports:i});return new xt({keys:[{pubkey:e,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!0,isWritable:!1}],programId:this.programId,data:a})}static split(t,e){const r=new At;return r.add(ye.createAccount({fromPubkey:t.authorizedPubkey,newAccountPubkey:t.splitStakePubkey,lamports:e,space:this.space,programId:this.programId})),r.add(this.splitInstruction(t))}static splitWithSeed(t,e){const{stakePubkey:r,authorizedPubkey:s,splitStakePubkey:i,basePubkey:o,seed:a,lamports:l}=t,p=new At;return p.add(ye.allocate({accountPubkey:i,basePubkey:o,seed:a,space:this.space,programId:this.programId})),e&&e>0&&p.add(ye.transfer({fromPubkey:t.authorizedPubkey,toPubkey:i,lamports:e})),p.add(this.splitInstruction({stakePubkey:r,authorizedPubkey:s,splitStakePubkey:i,lamports:l}))}static merge(t){const{stakePubkey:e,sourceStakePubKey:r,authorizedPubkey:s}=t,i=we.Merge,o=vt(i);return new At().add({keys:[{pubkey:e,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:We,isSigner:!1,isWritable:!1},{pubkey:ui,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!0,isWritable:!1}],programId:this.programId,data:o})}static withdraw(t){const{stakePubkey:e,authorizedPubkey:r,toPubkey:s,lamports:i,custodianPubkey:o}=t,a=we.Withdraw,l=vt(a,{lamports:i}),p=[{pubkey:e,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:We,isSigner:!1,isWritable:!1},{pubkey:ui,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!1}];return o&&p.push({pubkey:o,isSigner:!0,isWritable:!1}),new At().add({keys:p,programId:this.programId,data:l})}static deactivate(t){const{stakePubkey:e,authorizedPubkey:r}=t,s=we.Deactivate,i=vt(s);return new At().add({keys:[{pubkey:e,isSigner:!1,isWritable:!0},{pubkey:We,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!1}],programId:this.programId,data:i})}}zi.programId=new rt("Stake11111111111111111111111111111111111111");zi.space=200;class wl{constructor(t,e,r,s){this.nodePubkey=void 0,this.authorizedVoter=void 0,this.authorizedWithdrawer=void 0,this.commission=void 0,this.nodePubkey=t,this.authorizedVoter=e,this.authorizedWithdrawer=r,this.commission=s}}class Ng{constructor(){}static decodeInstructionType(t){this.checkProgramId(t.programId);const r=D.u32("instruction").decode(t.data);let s;for(const[i,o]of Object.entries(Ze))if(o.index==r){s=i;break}if(!s)throw new Error("Instruction type incorrect; not a VoteInstruction");return s}static decodeInitializeAccount(t){this.checkProgramId(t.programId),this.checkKeyLength(t.keys,4);const{voteInit:e}=Tt(Ze.InitializeAccount,t.data);return{votePubkey:t.keys[0].pubkey,nodePubkey:t.keys[3].pubkey,voteInit:new wl(new rt(e.nodePubkey),new rt(e.authorizedVoter),new rt(e.authorizedWithdrawer),e.commission)}}static decodeAuthorize(t){this.checkProgramId(t.programId),this.checkKeyLength(t.keys,3);const{newAuthorized:e,voteAuthorizationType:r}=Tt(Ze.Authorize,t.data);return{votePubkey:t.keys[0].pubkey,authorizedPubkey:t.keys[2].pubkey,newAuthorizedPubkey:new rt(e),voteAuthorizationType:{index:r}}}static decodeAuthorizeWithSeed(t){this.checkProgramId(t.programId),this.checkKeyLength(t.keys,3);const{voteAuthorizeWithSeedArgs:{currentAuthorityDerivedKeyOwnerPubkey:e,currentAuthorityDerivedKeySeed:r,newAuthorized:s,voteAuthorizationType:i}}=Tt(Ze.AuthorizeWithSeed,t.data);return{currentAuthorityDerivedKeyBasePubkey:t.keys[2].pubkey,currentAuthorityDerivedKeyOwnerPubkey:new rt(e),currentAuthorityDerivedKeySeed:r,newAuthorizedPubkey:new rt(s),voteAuthorizationType:{index:i},votePubkey:t.keys[0].pubkey}}static decodeWithdraw(t){this.checkProgramId(t.programId),this.checkKeyLength(t.keys,3);const{lamports:e}=Tt(Ze.Withdraw,t.data);return{votePubkey:t.keys[0].pubkey,authorizedWithdrawerPubkey:t.keys[2].pubkey,lamports:e,toPubkey:t.keys[1].pubkey}}static checkProgramId(t){if(!t.equals(pn.programId))throw new Error("invalid instruction; programId is not VoteProgram")}static checkKeyLength(t,e){if(t.length<e)throw new Error(`invalid instruction; found ${t.length} keys, expected at least ${e}`)}}const Ze=Object.freeze({InitializeAccount:{index:0,layout:D.struct([D.u32("instruction"),Lp()])},Authorize:{index:1,layout:D.struct([D.u32("instruction"),Et("newAuthorized"),D.u32("voteAuthorizationType")])},Withdraw:{index:3,layout:D.struct([D.u32("instruction"),D.ns64("lamports")])},UpdateValidatorIdentity:{index:4,layout:D.struct([D.u32("instruction")])},AuthorizeWithSeed:{index:10,layout:D.struct([D.u32("instruction"),Pp()])}}),Cg=Object.freeze({Voter:{index:0},Withdrawer:{index:1}});class pn{constructor(){}static initializeAccount(t){const{votePubkey:e,nodePubkey:r,voteInit:s}=t,i=Ze.InitializeAccount,o=vt(i,{voteInit:{nodePubkey:bt(s.nodePubkey.toBuffer()),authorizedVoter:bt(s.authorizedVoter.toBuffer()),authorizedWithdrawer:bt(s.authorizedWithdrawer.toBuffer()),commission:s.commission}}),a={keys:[{pubkey:e,isSigner:!1,isWritable:!0},{pubkey:un,isSigner:!1,isWritable:!1},{pubkey:We,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!1}],programId:this.programId,data:o};return new xt(a)}static createAccount(t){const e=new At;return e.add(ye.createAccount({fromPubkey:t.fromPubkey,newAccountPubkey:t.votePubkey,lamports:t.lamports,space:this.space,programId:this.programId})),e.add(this.initializeAccount({votePubkey:t.votePubkey,nodePubkey:t.voteInit.nodePubkey,voteInit:t.voteInit}))}static authorize(t){const{votePubkey:e,authorizedPubkey:r,newAuthorizedPubkey:s,voteAuthorizationType:i}=t,o=Ze.Authorize,a=vt(o,{newAuthorized:bt(s.toBuffer()),voteAuthorizationType:i.index}),l=[{pubkey:e,isSigner:!1,isWritable:!0},{pubkey:We,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!1}];return new At().add({keys:l,programId:this.programId,data:a})}static authorizeWithSeed(t){const{currentAuthorityDerivedKeyBasePubkey:e,currentAuthorityDerivedKeyOwnerPubkey:r,currentAuthorityDerivedKeySeed:s,newAuthorizedPubkey:i,voteAuthorizationType:o,votePubkey:a}=t,l=Ze.AuthorizeWithSeed,p=vt(l,{voteAuthorizeWithSeedArgs:{currentAuthorityDerivedKeyOwnerPubkey:bt(r.toBuffer()),currentAuthorityDerivedKeySeed:s,newAuthorized:bt(i.toBuffer()),voteAuthorizationType:o.index}}),m=[{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:We,isSigner:!1,isWritable:!1},{pubkey:e,isSigner:!0,isWritable:!1}];return new At().add({keys:m,programId:this.programId,data:p})}static withdraw(t){const{votePubkey:e,authorizedWithdrawerPubkey:r,lamports:s,toPubkey:i}=t,o=Ze.Withdraw,a=vt(o,{lamports:s}),l=[{pubkey:e,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!0,isWritable:!1}];return new At().add({keys:l,programId:this.programId,data:a})}static safeWithdraw(t,e,r){if(t.lamports>e-r)throw new Error("Withdraw will leave vote account with insufficient funds.");return pn.withdraw(t)}static updateValidatorIdentity(t){const{votePubkey:e,authorizedWithdrawerPubkey:r,nodePubkey:s}=t,i=Ze.UpdateValidatorIdentity,o=vt(i),a=[{pubkey:e,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!0,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!1}];return new At().add({keys:a,programId:this.programId,data:o})}}pn.programId=new rt("Vote111111111111111111111111111111111111111");pn.space=3762;const _l=new rt("Va1idator1nfo111111111111111111111111111111"),Bg=et({name:nt(),website:dt(nt()),details:dt(nt()),iconUrl:dt(nt()),keybaseUsername:dt(nt())});class Xo{constructor(t,e){this.key=void 0,this.info=void 0,this.key=t,this.info=e}static fromConfigData(t){let e=[...t];if(Te(e)!==2)return null;const s=[];for(let i=0;i<2;i++){const o=new rt(Oe(e,0,Xe)),a=je(e)===1;s.push({publicKey:o,isSigner:a})}if(s[0].publicKey.equals(_l)&&s[1].isSigner){const i=Cr().decode(ht.Buffer.from(e)),o=JSON.parse(i);return Cu(o,Bg),new Xo(s[1].publicKey,o)}return null}}const Mg=new rt("Vote111111111111111111111111111111111111111"),Lg=D.struct([Et("nodePubkey"),Et("authorizedWithdrawer"),D.u8("commission"),D.nu64(),D.seq(D.struct([D.nu64("slot"),D.u32("confirmationCount")]),D.offset(D.u32(),-8),"votes"),D.u8("rootSlotValid"),D.nu64("rootSlot"),D.nu64(),D.seq(D.struct([D.nu64("epoch"),Et("authorizedVoter")]),D.offset(D.u32(),-8),"authorizedVoters"),D.struct([D.seq(D.struct([Et("authorizedPubkey"),D.nu64("epochOfLastAuthorizedSwitch"),D.nu64("targetEpoch")]),32,"buf"),D.nu64("idx"),D.u8("isEmpty")],"priorVoters"),D.nu64(),D.seq(D.struct([D.nu64("epoch"),D.nu64("credits"),D.nu64("prevCredits")]),D.offset(D.u32(),-8),"epochCredits"),D.struct([D.nu64("slot"),D.nu64("timestamp")],"lastTimestamp")]);class Jo{constructor(t){this.nodePubkey=void 0,this.authorizedWithdrawer=void 0,this.commission=void 0,this.rootSlot=void 0,this.votes=void 0,this.authorizedVoters=void 0,this.priorVoters=void 0,this.epochCredits=void 0,this.lastTimestamp=void 0,this.nodePubkey=t.nodePubkey,this.authorizedWithdrawer=t.authorizedWithdrawer,this.commission=t.commission,this.rootSlot=t.rootSlot,this.votes=t.votes,this.authorizedVoters=t.authorizedVoters,this.priorVoters=t.priorVoters,this.epochCredits=t.epochCredits,this.lastTimestamp=t.lastTimestamp}static fromAccountData(t){const r=Lg.decode(bt(t),4);let s=r.rootSlot;return r.rootSlotValid||(s=null),new Jo({nodePubkey:new rt(r.nodePubkey),authorizedWithdrawer:new rt(r.authorizedWithdrawer),commission:r.commission,votes:r.votes,rootSlot:s,authorizedVoters:r.authorizedVoters.map(Pg),priorVoters:Ug(r.priorVoters),epochCredits:r.epochCredits,lastTimestamp:r.lastTimestamp})}}function Pg({authorizedVoter:n,epoch:t}){return{epoch:t,authorizedVoter:new rt(n)}}function lc({authorizedPubkey:n,epochOfLastAuthorizedSwitch:t,targetEpoch:e}){return{authorizedPubkey:new rt(n),epochOfLastAuthorizedSwitch:t,targetEpoch:e}}function Ug({buf:n,idx:t,isEmpty:e}){return e?[]:[...n.slice(t+1).map(lc),...n.slice(0,t).map(lc)]}const hc={http:{devnet:"http://api.devnet.solana.com",testnet:"http://api.testnet.solana.com","mainnet-beta":"http://api.mainnet-beta.solana.com/"},https:{devnet:"https://api.devnet.solana.com",testnet:"https://api.testnet.solana.com","mainnet-beta":"https://api.mainnet-beta.solana.com/"}};function Dg(n,t){const e=t===!1?"http":"https";if(!n)return hc[e].devnet;const r=hc[e][n];if(!r)throw new Error(`Unknown ${e} cluster: ${n}`);return r}async function Hg(n,t,e,r){let s,i;e&&Object.prototype.hasOwnProperty.call(e,"lastValidBlockHeight")||e&&Object.prototype.hasOwnProperty.call(e,"nonceValue")?(s=e,i=r):i=e;const o=i&&{skipPreflight:i.skipPreflight,preflightCommitment:i.preflightCommitment||i.commitment,minContextSlot:i.minContextSlot},a=await n.sendRawTransaction(t,o),l=i&&i.commitment,m=(await(s?n.confirmTransaction(s,l):n.confirmTransaction(a,l))).value;if(m.err)throw a!=null?new Ar({action:o?.skipPreflight?"send":"simulate",signature:a,transactionMessage:`Status: (${JSON.stringify(m)})`}):new Error(`Raw transaction ${a} failed (${JSON.stringify(m)})`);return a}const Fg=1e9,zg=Object.freeze({__proto__:null,Account:xp,AddressLookupTableAccount:co,AddressLookupTableInstruction:Ag,AddressLookupTableProgram:Yo,Authorized:ml,BLOCKHASH_CACHE_TIMEOUT_MS:sl,BPF_LOADER_DEPRECATED_PROGRAM_ID:Np,BPF_LOADER_PROGRAM_ID:Yp,BpfLoader:Zp,COMPUTE_BUDGET_INSTRUCTION_LAYOUTS:Ye,ComputeBudgetInstruction:Ig,ComputeBudgetProgram:Zo,Connection:vg,Ed25519Program:Fi,Enum:Tp,EpochSchedule:nl,FeeCalculatorLayout:el,Keypair:rn,LAMPORTS_PER_SOL:Fg,LOOKUP_TABLE_INSTRUCTION_LAYOUTS:cr,Loader:Dr,Lockup:Dn,MAX_SEED_LENGTH:Xu,Message:qe,MessageAccountKeys:kn,MessageV0:Ur,NONCE_ACCOUNT_LENGTH:ao,NonceAccount:Ui,PACKET_DATA_SIZE:Er,PUBLIC_KEY_LENGTH:Xe,PublicKey:rt,SIGNATURE_LENGTH_IN_BYTES:Sn,SOLANA_SCHEMA:En,STAKE_CONFIG_ID:gl,STAKE_INSTRUCTION_LAYOUTS:we,SYSTEM_INSTRUCTION_LAYOUTS:Mt,SYSVAR_CLOCK_PUBKEY:We,SYSVAR_EPOCH_SCHEDULE_PUBKEY:zp,SYSVAR_INSTRUCTIONS_PUBKEY:Kp,SYSVAR_RECENT_BLOCKHASHES_PUBKEY:ci,SYSVAR_RENT_PUBKEY:un,SYSVAR_REWARDS_PUBKEY:qp,SYSVAR_SLOT_HASHES_PUBKEY:$p,SYSVAR_SLOT_HISTORY_PUBKEY:Vp,SYSVAR_STAKE_HISTORY_PUBKEY:ui,Secp256k1Program:nn,SendTransactionError:Ar,SolanaJSONRPCError:ft,SolanaJSONRPCErrorCode:Wp,StakeAuthorizationLayout:xg,StakeInstruction:Og,StakeProgram:zi,Struct:Fo,SystemInstruction:Gp,SystemProgram:ye,Transaction:At,TransactionExpiredBlockheightExceededError:zo,TransactionExpiredNonceInvalidError:Jr,TransactionExpiredTimeoutError:Ko,TransactionInstruction:xt,TransactionMessage:$o,TransactionStatus:nr,VALIDATOR_INFO_KEY:_l,VERSION_PREFIX_MASK:Li,VOTE_PROGRAM_ID:Mg,ValidatorInfo:Xo,VersionedMessage:qo,VersionedTransaction:Vo,VoteAccount:Jo,VoteAuthorizationLayout:Cg,VoteInit:wl,VoteInstruction:Ng,VoteProgram:pn,clusterApiUrl:Dg,sendAndConfirmRawTransaction:Hg,sendAndConfirmTransaction:oo}),Kg=Ti(zg);var Ks,fc;function qg(){if(fc)return Ks;fc=1;var n=No().Buffer;function t(e){if(e.length>=255)throw new TypeError("Alphabet too long");for(var r=new Uint8Array(256),s=0;s<r.length;s++)r[s]=255;for(var i=0;i<e.length;i++){var o=e.charAt(i),a=o.charCodeAt(0);if(r[a]!==255)throw new TypeError(o+" is ambiguous");r[a]=i}var l=e.length,p=e.charAt(0),m=Math.log(l)/Math.log(256),S=Math.log(256)/Math.log(l);function R(O){if((Array.isArray(O)||O instanceof Uint8Array)&&(O=n.from(O)),!n.isBuffer(O))throw new TypeError("Expected Buffer");if(O.length===0)return"";for(var x=0,M=0,H=0,P=O.length;H!==P&&O[H]===0;)H++,x++;for(var q=(P-H)*S+1>>>0,G=new Uint8Array(q);H!==P;){for(var J=O[H],Q=0,tt=q-1;(J!==0||Q<M)&&tt!==-1;tt--,Q++)J+=256*G[tt]>>>0,G[tt]=J%l>>>0,J=J/l>>>0;if(J!==0)throw new Error("Non-zero carry");M=Q,H++}for(var L=q-M;L!==q&&G[L]===0;)L++;for(var U=p.repeat(x);L<q;++L)U+=e.charAt(G[L]);return U}function _(O){if(typeof O!="string")throw new TypeError("Expected String");if(O.length===0)return n.alloc(0);for(var x=0,M=0,H=0;O[x]===p;)M++,x++;for(var P=(O.length-x)*m+1>>>0,q=new Uint8Array(P);x<O.length;){var G=O.charCodeAt(x);if(G>255)return;var J=r[G];if(J===255)return;for(var Q=0,tt=P-1;(J!==0||Q<H)&&tt!==-1;tt--,Q++)J+=l*q[tt]>>>0,q[tt]=J%256>>>0,J=J/256>>>0;if(J!==0)throw new Error("Non-zero carry");H=Q,x++}for(var L=P-H;L!==P&&q[L]===0;)L++;var U=n.allocUnsafe(M+(P-L));U.fill(0,0,M);for(var F=M;L!==P;)U[F++]=q[L++];return U}function I(O){var x=_(O);if(x)return x;throw new Error("Non-base"+l+" character")}return{encode:R,decodeUnsafe:_,decode:I}}return Ks=t,Ks}var qs,dc;function $g(){if(dc)return qs;dc=1;var n=qg(),t="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";return qs=n(t),qs}var Vg=$g();const Ki=Fr(Vg);var ti={exports:{}},pc;function Wg(){if(pc)return ti.exports;pc=1;const n=/[\p{Lu}]/u,t=/[\p{Ll}]/u,e=/^[\p{Lu}](?![\p{Lu}])/gu,r=/([\p{Alpha}\p{N}_]|$)/u,s=/[_.\- ]+/,i=new RegExp("^"+s.source),o=new RegExp(s.source+r.source,"gu"),a=new RegExp("\\d+"+r.source,"gu"),l=(R,_,I)=>{let O=!1,x=!1,M=!1;for(let H=0;H<R.length;H++){const P=R[H];O&&n.test(P)?(R=R.slice(0,H)+"-"+R.slice(H),O=!1,M=x,x=!0,H++):x&&M&&t.test(P)?(R=R.slice(0,H-1)+"-"+R.slice(H-1),M=x,x=!1,O=!0):(O=_(P)===P&&I(P)!==P,M=x,x=I(P)===P&&_(P)!==P)}return R},p=(R,_)=>(e.lastIndex=0,R.replace(e,I=>_(I))),m=(R,_)=>(o.lastIndex=0,a.lastIndex=0,R.replace(o,(I,O)=>_(O)).replace(a,I=>_(I))),S=(R,_)=>{if(!(typeof R=="string"||Array.isArray(R)))throw new TypeError("Expected the input to be `string | string[]`");if(_={pascalCase:!1,preserveConsecutiveUppercase:!1,..._},Array.isArray(R)?R=R.map(M=>M.trim()).filter(M=>M.length).join("-"):R=R.trim(),R.length===0)return"";const I=_.locale===!1?M=>M.toLowerCase():M=>M.toLocaleLowerCase(_.locale),O=_.locale===!1?M=>M.toUpperCase():M=>M.toLocaleUpperCase(_.locale);return R.length===1?_.pascalCase?O(R):I(R):(R!==I(R)&&(R=l(R,I,O)),R=R.replace(i,""),_.preserveConsecutiveUppercase?R=p(R,I):R=I(R),_.pascalCase&&(R=O(R.charAt(0))+R.slice(1)),m(R,O))};return ti.exports=S,ti.exports.default=S,ti.exports}var Gg=Wg();const jg=Fr(Gg);var _n={},lt={},yc;function gc(){if(yc)return lt;yc=1;class n{constructor(g,d){if(!Number.isInteger(g))throw new TypeError("span must be an integer");this.span=g,this.property=d}makeDestinationObject(){return{}}decode(g,d){throw new Error("Layout is abstract")}encode(g,d,u){throw new Error("Layout is abstract")}getSpan(g,d){if(0>this.span)throw new RangeError("indeterminate span");return this.span}replicate(g){const d=Object.create(this.constructor.prototype);return Object.assign(d,this),d.property=g,d}fromArray(g){}}lt.Layout=n;function t(A,g){return g.property?A+"["+g.property+"]":A}lt.nameWithProperty=t;function e(A,g){if(typeof A!="function")throw new TypeError("Class must be constructor");if(A.hasOwnProperty("layout_"))throw new Error("Class is already bound to a layout");if(!(g&&g instanceof n))throw new TypeError("layout must be a Layout");if(g.hasOwnProperty("boundConstructor_"))throw new Error("layout is already bound to a constructor");A.layout_=g,g.boundConstructor_=A,g.makeDestinationObject=(()=>new A),Object.defineProperty(A.prototype,"encode",{value:function(d,u){return g.encode(this,d,u)},writable:!0}),Object.defineProperty(A,"decode",{value:function(d,u){return g.decode(d,u)},writable:!0})}lt.bindConstructorLayout=e;class r extends n{isCount(){throw new Error("ExternalLayout is abstract")}}class s extends r{constructor(g,d){if(g===void 0&&(g=1),!Number.isInteger(g)||0>=g)throw new TypeError("elementSpan must be a (positive) integer");super(-1,d),this.elementSpan=g}isCount(){return!0}decode(g,d){d===void 0&&(d=0);const u=g.length-d;return Math.floor(u/this.elementSpan)}encode(g,d,u){return 0}}class i extends r{constructor(g,d,u){if(!(g instanceof n))throw new TypeError("layout must be a Layout");if(d===void 0)d=0;else if(!Number.isInteger(d))throw new TypeError("offset must be integer or undefined");super(g.span,u||g.property),this.layout=g,this.offset=d}isCount(){return this.layout instanceof o||this.layout instanceof a}decode(g,d){return d===void 0&&(d=0),this.layout.decode(g,d+this.offset)}encode(g,d,u){return u===void 0&&(u=0),this.layout.encode(g,d,u+this.offset)}}class o extends n{constructor(g,d){if(super(g,d),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(g,d){return d===void 0&&(d=0),g.readUIntLE(d,this.span)}encode(g,d,u){return u===void 0&&(u=0),d.writeUIntLE(g,u,this.span),this.span}}class a extends n{constructor(g,d){if(super(g,d),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(g,d){return d===void 0&&(d=0),g.readUIntBE(d,this.span)}encode(g,d,u){return u===void 0&&(u=0),d.writeUIntBE(g,u,this.span),this.span}}class l extends n{constructor(g,d){if(super(g,d),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(g,d){return d===void 0&&(d=0),g.readIntLE(d,this.span)}encode(g,d,u){return u===void 0&&(u=0),d.writeIntLE(g,u,this.span),this.span}}class p extends n{constructor(g,d){if(super(g,d),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(g,d){return d===void 0&&(d=0),g.readIntBE(d,this.span)}encode(g,d,u){return u===void 0&&(u=0),d.writeIntBE(g,u,this.span),this.span}}const m=Math.pow(2,32);function S(A){const g=Math.floor(A/m),d=A-g*m;return{hi32:g,lo32:d}}function R(A,g){return A*m+g}class _ extends n{constructor(g){super(8,g)}decode(g,d){d===void 0&&(d=0);const u=g.readUInt32LE(d),h=g.readUInt32LE(d+4);return R(h,u)}encode(g,d,u){u===void 0&&(u=0);const h=S(g);return d.writeUInt32LE(h.lo32,u),d.writeUInt32LE(h.hi32,u+4),8}}class I extends n{constructor(g){super(8,g)}decode(g,d){d===void 0&&(d=0);const u=g.readUInt32BE(d),h=g.readUInt32BE(d+4);return R(u,h)}encode(g,d,u){u===void 0&&(u=0);const h=S(g);return d.writeUInt32BE(h.hi32,u),d.writeUInt32BE(h.lo32,u+4),8}}class O extends n{constructor(g){super(8,g)}decode(g,d){d===void 0&&(d=0);const u=g.readUInt32LE(d),h=g.readInt32LE(d+4);return R(h,u)}encode(g,d,u){u===void 0&&(u=0);const h=S(g);return d.writeUInt32LE(h.lo32,u),d.writeInt32LE(h.hi32,u+4),8}}class x extends n{constructor(g){super(8,g)}decode(g,d){d===void 0&&(d=0);const u=g.readInt32BE(d),h=g.readUInt32BE(d+4);return R(u,h)}encode(g,d,u){u===void 0&&(u=0);const h=S(g);return d.writeInt32BE(h.hi32,u),d.writeUInt32BE(h.lo32,u+4),8}}class M extends n{constructor(g){super(4,g)}decode(g,d){return d===void 0&&(d=0),g.readFloatLE(d)}encode(g,d,u){return u===void 0&&(u=0),d.writeFloatLE(g,u),4}}class H extends n{constructor(g){super(4,g)}decode(g,d){return d===void 0&&(d=0),g.readFloatBE(d)}encode(g,d,u){return u===void 0&&(u=0),d.writeFloatBE(g,u),4}}class P extends n{constructor(g){super(8,g)}decode(g,d){return d===void 0&&(d=0),g.readDoubleLE(d)}encode(g,d,u){return u===void 0&&(u=0),d.writeDoubleLE(g,u),8}}class q extends n{constructor(g){super(8,g)}decode(g,d){return d===void 0&&(d=0),g.readDoubleBE(d)}encode(g,d,u){return u===void 0&&(u=0),d.writeDoubleBE(g,u),8}}class G extends n{constructor(g,d,u){if(!(g instanceof n))throw new TypeError("elementLayout must be a Layout");if(!(d instanceof r&&d.isCount()||Number.isInteger(d)&&0<=d))throw new TypeError("count must be non-negative integer or an unsigned integer ExternalLayout");let h=-1;!(d instanceof r)&&0<g.span&&(h=d*g.span),super(h,u),this.elementLayout=g,this.count=d}getSpan(g,d){if(0<=this.span)return this.span;d===void 0&&(d=0);let u=0,h=this.count;if(h instanceof r&&(h=h.decode(g,d)),0<this.elementLayout.span)u=h*this.elementLayout.span;else{let v=0;for(;v<h;)u+=this.elementLayout.getSpan(g,d+u),++v}return u}decode(g,d){d===void 0&&(d=0);const u=[];let h=0,v=this.count;for(v instanceof r&&(v=v.decode(g,d));h<v;)u.push(this.elementLayout.decode(g,d)),d+=this.elementLayout.getSpan(g,d),h+=1;return u}encode(g,d,u){u===void 0&&(u=0);const h=this.elementLayout,v=g.reduce((C,K)=>C+h.encode(K,d,u+C),0);return this.count instanceof r&&this.count.encode(g.length,d,u),v}}class J extends n{constructor(g,d,u){if(!(Array.isArray(g)&&g.reduce((v,C)=>v&&C instanceof n,!0)))throw new TypeError("fields must be array of Layout instances");typeof d=="boolean"&&u===void 0&&(u=d,d=void 0);for(const v of g)if(0>v.span&&v.property===void 0)throw new Error("fields cannot contain unnamed variable-length layout");let h=-1;try{h=g.reduce((v,C)=>v+C.getSpan(),0)}catch{}super(h,d),this.fields=g,this.decodePrefixes=!!u}getSpan(g,d){if(0<=this.span)return this.span;d===void 0&&(d=0);let u=0;try{u=this.fields.reduce((h,v)=>{const C=v.getSpan(g,d);return d+=C,h+C},0)}catch{throw new RangeError("indeterminate span")}return u}decode(g,d){d===void 0&&(d=0);const u=this.makeDestinationObject();for(const h of this.fields)if(h.property!==void 0&&(u[h.property]=h.decode(g,d)),d+=h.getSpan(g,d),this.decodePrefixes&&g.length===d)break;return u}encode(g,d,u){u===void 0&&(u=0);const h=u;let v=0,C=0;for(const K of this.fields){let Z=K.span;if(C=0<Z?Z:0,K.property!==void 0){const it=g[K.property];it!==void 0&&(C=K.encode(it,d,u),0>Z&&(Z=K.getSpan(d,u)))}v=u,u+=Z}return v+C-h}fromArray(g){const d=this.makeDestinationObject();for(const u of this.fields)u.property!==void 0&&0<g.length&&(d[u.property]=g.shift());return d}layoutFor(g){if(typeof g!="string")throw new TypeError("property must be string");for(const d of this.fields)if(d.property===g)return d}offsetOf(g){if(typeof g!="string")throw new TypeError("property must be string");let d=0;for(const u of this.fields){if(u.property===g)return d;0>u.span?d=-1:0<=d&&(d+=u.span)}}}class Q{constructor(g){this.property=g}decode(){throw new Error("UnionDiscriminator is abstract")}encode(){throw new Error("UnionDiscriminator is abstract")}}class tt extends Q{constructor(g,d){if(!(g instanceof r&&g.isCount()))throw new TypeError("layout must be an unsigned integer ExternalLayout");super(d||g.property||"variant"),this.layout=g}decode(g,d){return this.layout.decode(g,d)}encode(g,d,u){return this.layout.encode(g,d,u)}}class L extends n{constructor(g,d,u){const h=g instanceof o||g instanceof a;if(h)g=new tt(new i(g));else if(g instanceof r&&g.isCount())g=new tt(g);else if(!(g instanceof Q))throw new TypeError("discr must be a UnionDiscriminator or an unsigned integer layout");if(d===void 0&&(d=null),!(d===null||d instanceof n))throw new TypeError("defaultLayout must be null or a Layout");if(d!==null){if(0>d.span)throw new Error("defaultLayout must have constant span");d.property===void 0&&(d=d.replicate("content"))}let v=-1;d&&(v=d.span,0<=v&&h&&(v+=g.layout.span)),super(v,u),this.discriminator=g,this.usesPrefixDiscriminator=h,this.defaultLayout=d,this.registry={};let C=this.defaultGetSourceVariant.bind(this);this.getSourceVariant=function(K){return C(K)},this.configGetSourceVariant=function(K){C=K.bind(this)}}getSpan(g,d){if(0<=this.span)return this.span;d===void 0&&(d=0);const u=this.getVariant(g,d);if(!u)throw new Error("unable to determine span for unrecognized variant");return u.getSpan(g,d)}defaultGetSourceVariant(g){if(g.hasOwnProperty(this.discriminator.property)){if(this.defaultLayout&&g.hasOwnProperty(this.defaultLayout.property))return;const d=this.registry[g[this.discriminator.property]];if(d&&(!d.layout||g.hasOwnProperty(d.property)))return d}else for(const d in this.registry){const u=this.registry[d];if(g.hasOwnProperty(u.property))return u}throw new Error("unable to infer src variant")}decode(g,d){d===void 0&&(d=0);let u;const h=this.discriminator,v=h.decode(g,d);let C=this.registry[v];if(C===void 0){let K=0;C=this.defaultLayout,this.usesPrefixDiscriminator&&(K=h.layout.span),u=this.makeDestinationObject(),u[h.property]=v,u[C.property]=this.defaultLayout.decode(g,d+K)}else u=C.decode(g,d);return u}encode(g,d,u){u===void 0&&(u=0);const h=this.getSourceVariant(g);if(h===void 0){const v=this.discriminator,C=this.defaultLayout;let K=0;return this.usesPrefixDiscriminator&&(K=v.layout.span),v.encode(g[v.property],d,u),K+C.encode(g[C.property],d,u+K)}return h.encode(g,d,u)}addVariant(g,d,u){const h=new U(this,g,d,u);return this.registry[g]=h,h}getVariant(g,d){let u=g;return Buffer.isBuffer(g)&&(d===void 0&&(d=0),u=this.discriminator.decode(g,d)),this.registry[u]}}class U extends n{constructor(g,d,u,h){if(!(g instanceof L))throw new TypeError("union must be a Union");if(!Number.isInteger(d)||0>d)throw new TypeError("variant must be a (non-negative) integer");if(typeof u=="string"&&h===void 0&&(h=u,u=null),u){if(!(u instanceof n))throw new TypeError("layout must be a Layout");if(g.defaultLayout!==null&&0<=u.span&&u.span>g.defaultLayout.span)throw new Error("variant span exceeds span of containing union");if(typeof h!="string")throw new TypeError("variant must have a String property")}let v=g.span;0>g.span&&(v=u?u.span:0,0<=v&&g.usesPrefixDiscriminator&&(v+=g.discriminator.layout.span)),super(v,h),this.union=g,this.variant=d,this.layout=u||null}getSpan(g,d){if(0<=this.span)return this.span;d===void 0&&(d=0);let u=0;return this.union.usesPrefixDiscriminator&&(u=this.union.discriminator.layout.span),u+this.layout.getSpan(g,d+u)}decode(g,d){const u=this.makeDestinationObject();if(d===void 0&&(d=0),this!==this.union.getVariant(g,d))throw new Error("variant mismatch");let h=0;return this.union.usesPrefixDiscriminator&&(h=this.union.discriminator.layout.span),this.layout?u[this.property]=this.layout.decode(g,d+h):this.property?u[this.property]=!0:this.union.usesPrefixDiscriminator&&(u[this.union.discriminator.property]=this.variant),u}encode(g,d,u){u===void 0&&(u=0);let h=0;if(this.union.usesPrefixDiscriminator&&(h=this.union.discriminator.layout.span),this.layout&&!g.hasOwnProperty(this.property))throw new TypeError("variant lacks property "+this.property);this.union.discriminator.encode(this.variant,d,u);let v=h;if(this.layout&&(this.layout.encode(g[this.property],d,u+h),v+=this.layout.getSpan(d,u+h),0<=this.union.span&&v>this.union.span))throw new Error("encoded variant overruns containing union");return v}fromArray(g){if(this.layout)return this.layout.fromArray(g)}}function F(A){return 0>A&&(A+=4294967296),A}class z extends n{constructor(g,d,u){if(!(g instanceof o||g instanceof a))throw new TypeError("word must be a UInt or UIntBE layout");if(typeof d=="string"&&u===void 0&&(u=d,d=void 0),4<g.span)throw new RangeError("word cannot exceed 32 bits");super(g.span,u),this.word=g,this.msb=!!d,this.fields=[];let h=0;this._packedSetValue=function(v){return h=F(v),this},this._packedGetValue=function(){return h}}decode(g,d){const u=this.makeDestinationObject();d===void 0&&(d=0);const h=this.word.decode(g,d);this._packedSetValue(h);for(const v of this.fields)v.property!==void 0&&(u[v.property]=v.decode(h));return u}encode(g,d,u){u===void 0&&(u=0);const h=this.word.decode(d,u);this._packedSetValue(h);for(const v of this.fields)if(v.property!==void 0){const C=g[v.property];C!==void 0&&v.encode(C)}return this.word.encode(this._packedGetValue(),d,u)}addField(g,d){const u=new b(this,g,d);return this.fields.push(u),u}addBoolean(g){const d=new c(this,g);return this.fields.push(d),d}fieldFor(g){if(typeof g!="string")throw new TypeError("property must be string");for(const d of this.fields)if(d.property===g)return d}}class b{constructor(g,d,u){if(!(g instanceof z))throw new TypeError("container must be a BitStructure");if(!Number.isInteger(d)||0>=d)throw new TypeError("bits must be positive integer");const h=8*g.span,v=g.fields.reduce((C,K)=>C+K.bits,0);if(d+v>h)throw new Error("bits too long for span remainder ("+(h-v)+" of "+h+" remain)");this.container=g,this.bits=d,this.valueMask=(1<<d)-1,d===32&&(this.valueMask=4294967295),this.start=v,this.container.msb&&(this.start=h-v-d),this.wordMask=F(this.valueMask<<this.start),this.property=u}decode(){const g=this.container._packedGetValue();return F(g&this.wordMask)>>>this.start}encode(g){if(!Number.isInteger(g)||g!==F(g&this.valueMask))throw new TypeError(t("BitField.encode",this)+" value must be integer not exceeding "+this.valueMask);const d=this.container._packedGetValue(),u=F(g<<this.start);this.container._packedSetValue(F(d&~this.wordMask)|u)}}class c extends b{constructor(g,d){super(g,1,d)}decode(g,d){return!!b.prototype.decode.call(this,g,d)}encode(g){return typeof g=="boolean"&&(g=+g),b.prototype.encode.call(this,g)}}class f extends n{constructor(g,d){if(!(g instanceof r&&g.isCount()||Number.isInteger(g)&&0<=g))throw new TypeError("length must be positive integer or an unsigned integer ExternalLayout");let u=-1;g instanceof r||(u=g),super(u,d),this.length=g}getSpan(g,d){let u=this.span;return 0>u&&(u=this.length.decode(g,d)),u}decode(g,d){d===void 0&&(d=0);let u=this.span;return 0>u&&(u=this.length.decode(g,d)),g.slice(d,d+u)}encode(g,d,u){let h=this.length;if(this.length instanceof r&&(h=g.length),!(Buffer.isBuffer(g)&&h===g.length))throw new TypeError(t("Blob.encode",this)+" requires (length "+h+") Buffer as src");if(u+h>d.length)throw new RangeError("encoding overruns Buffer");return d.write(g.toString("hex"),u,h,"hex"),this.length instanceof r&&this.length.encode(h,d,u),h}}class E extends n{constructor(g){super(-1,g)}getSpan(g,d){if(!Buffer.isBuffer(g))throw new TypeError("b must be a Buffer");d===void 0&&(d=0);let u=d;for(;u<g.length&&g[u]!==0;)u+=1;return 1+u-d}decode(g,d,u){d===void 0&&(d=0);let h=this.getSpan(g,d);return g.slice(d,d+h-1).toString("utf-8")}encode(g,d,u){u===void 0&&(u=0),typeof g!="string"&&(g=g.toString());const h=new Buffer(g,"utf8"),v=h.length;if(u+v>d.length)throw new RangeError("encoding overruns Buffer");return h.copy(d,u),d[u+v]=0,v+1}}class T extends n{constructor(g,d){if(typeof g=="string"&&d===void 0&&(d=g,g=void 0),g===void 0)g=-1;else if(!Number.isInteger(g))throw new TypeError("maxSpan must be an integer");super(-1,d),this.maxSpan=g}getSpan(g,d){if(!Buffer.isBuffer(g))throw new TypeError("b must be a Buffer");return d===void 0&&(d=0),g.length-d}decode(g,d,u){d===void 0&&(d=0);let h=this.getSpan(g,d);if(0<=this.maxSpan&&this.maxSpan<h)throw new RangeError("text length exceeds maxSpan");return g.slice(d,d+h).toString("utf-8")}encode(g,d,u){u===void 0&&(u=0),typeof g!="string"&&(g=g.toString());const h=new Buffer(g,"utf8"),v=h.length;if(0<=this.maxSpan&&this.maxSpan<v)throw new RangeError("text length exceeds maxSpan");if(u+v>d.length)throw new RangeError("encoding overruns Buffer");return h.copy(d,u),v}}class N extends n{constructor(g,d){super(0,d),this.value=g}decode(g,d,u){return this.value}encode(g,d,u){return 0}}return lt.ExternalLayout=r,lt.GreedyCount=s,lt.OffsetLayout=i,lt.UInt=o,lt.UIntBE=a,lt.Int=l,lt.IntBE=p,lt.Float=M,lt.FloatBE=H,lt.Double=P,lt.DoubleBE=q,lt.Sequence=G,lt.Structure=J,lt.UnionDiscriminator=Q,lt.UnionLayoutDiscriminator=tt,lt.Union=L,lt.VariantLayout=U,lt.BitStructure=z,lt.BitField=b,lt.Boolean=c,lt.Blob=f,lt.CString=E,lt.UTF8=T,lt.Constant=N,lt.greedy=((A,g)=>new s(A,g)),lt.offset=((A,g,d)=>new i(A,g,d)),lt.u8=(A=>new o(1,A)),lt.u16=(A=>new o(2,A)),lt.u24=(A=>new o(3,A)),lt.u32=(A=>new o(4,A)),lt.u40=(A=>new o(5,A)),lt.u48=(A=>new o(6,A)),lt.nu64=(A=>new _(A)),lt.u16be=(A=>new a(2,A)),lt.u24be=(A=>new a(3,A)),lt.u32be=(A=>new a(4,A)),lt.u40be=(A=>new a(5,A)),lt.u48be=(A=>new a(6,A)),lt.nu64be=(A=>new I(A)),lt.s8=(A=>new l(1,A)),lt.s16=(A=>new l(2,A)),lt.s24=(A=>new l(3,A)),lt.s32=(A=>new l(4,A)),lt.s40=(A=>new l(5,A)),lt.s48=(A=>new l(6,A)),lt.ns64=(A=>new O(A)),lt.s16be=(A=>new p(2,A)),lt.s24be=(A=>new p(3,A)),lt.s32be=(A=>new p(4,A)),lt.s40be=(A=>new p(5,A)),lt.s48be=(A=>new p(6,A)),lt.ns64be=(A=>new x(A)),lt.f32=(A=>new M(A)),lt.f32be=(A=>new H(A)),lt.f64=(A=>new P(A)),lt.f64be=(A=>new q(A)),lt.struct=((A,g,d)=>new J(A,g,d)),lt.bits=((A,g,d)=>new z(A,g,d)),lt.seq=((A,g,d)=>new G(A,g,d)),lt.union=((A,g,d)=>new L(A,g,d)),lt.unionLayoutDiscriminator=((A,g)=>new tt(A,g)),lt.blob=((A,g)=>new f(A,g)),lt.cstr=(A=>new E(A)),lt.utf8=((A,g)=>new T(A,g)),lt.const=((A,g)=>new N(A,g)),lt}var mc;function Yg(){return mc||(mc=1,(function(n){var t=_n&&_n.__importDefault||function(z){return z&&z.__esModule?z:{default:z}};Object.defineProperty(n,"__esModule",{value:!0}),n.struct=n.f64=n.f32=n.i32=n.u32=n.i16=n.u16=n.i8=n.u8=void 0,n.u64=a,n.i64=l,n.u128=p,n.i128=m,n.u256=S,n.i256=R,n.publicKey=I,n.option=x,n.bool=M,n.vec=q,n.tagged=G,n.vecU8=J,n.str=Q,n.rustEnum=tt,n.array=L,n.map=F;const e=gc(),r=Kg,s=t(xo());var i=gc();Object.defineProperty(n,"u8",{enumerable:!0,get:function(){return i.u8}}),Object.defineProperty(n,"i8",{enumerable:!0,get:function(){return i.s8}}),Object.defineProperty(n,"u16",{enumerable:!0,get:function(){return i.u16}}),Object.defineProperty(n,"i16",{enumerable:!0,get:function(){return i.s16}}),Object.defineProperty(n,"u32",{enumerable:!0,get:function(){return i.u32}}),Object.defineProperty(n,"i32",{enumerable:!0,get:function(){return i.s32}}),Object.defineProperty(n,"f32",{enumerable:!0,get:function(){return i.f32}}),Object.defineProperty(n,"f64",{enumerable:!0,get:function(){return i.f64}}),Object.defineProperty(n,"struct",{enumerable:!0,get:function(){return i.struct}});class o extends e.Layout{constructor(b,c,f){super(b,f),this.blob=(0,e.blob)(b),this.signed=c}decode(b,c=0){const f=new s.default(this.blob.decode(b,c),10,"le");return this.signed?f.fromTwos(this.span*8).clone():f}encode(b,c,f=0){return this.signed&&(b=b.toTwos(this.span*8)),this.blob.encode(b.toArrayLike(Buffer,"le",this.span),c,f)}}function a(z){return new o(8,!1,z)}function l(z){return new o(8,!0,z)}function p(z){return new o(16,!1,z)}function m(z){return new o(16,!0,z)}function S(z){return new o(32,!1,z)}function R(z){return new o(32,!0,z)}class _ extends e.Layout{constructor(b,c,f,E){super(b.span,E),this.layout=b,this.decoder=c,this.encoder=f}decode(b,c){return this.decoder(this.layout.decode(b,c))}encode(b,c,f){return this.layout.encode(this.encoder(b),c,f)}getSpan(b,c){return this.layout.getSpan(b,c)}}function I(z){return new _((0,e.blob)(32),b=>new r.PublicKey(b),b=>b.toBuffer(),z)}class O extends e.Layout{constructor(b,c){super(-1,c),this.layout=b,this.discriminator=(0,e.u8)()}encode(b,c,f=0){return b==null?this.discriminator.encode(0,c,f):(this.discriminator.encode(1,c,f),this.layout.encode(b,c,f+1)+1)}decode(b,c=0){const f=this.discriminator.decode(b,c);if(f===0)return null;if(f===1)return this.layout.decode(b,c+1);throw new Error("Invalid option "+this.property)}getSpan(b,c=0){const f=this.discriminator.decode(b,c);if(f===0)return 1;if(f===1)return this.layout.getSpan(b,c+1)+1;throw new Error("Invalid option "+this.property)}}function x(z,b){return new O(z,b)}function M(z){return new _((0,e.u8)(),H,P,z)}function H(z){if(z===0)return!1;if(z===1)return!0;throw new Error("Invalid bool: "+z)}function P(z){return z?1:0}function q(z,b){const c=(0,e.u32)("length"),f=(0,e.struct)([c,(0,e.seq)(z,(0,e.offset)(c,-c.span),"values")]);return new _(f,({values:E})=>E,E=>({values:E}),b)}function G(z,b,c){const f=(0,e.struct)([a("tag"),b.replicate("data")]);function E({tag:T,data:N}){if(!T.eq(z))throw new Error("Invalid tag, expected: "+z.toString("hex")+", got: "+T.toString("hex"));return N}return new _(f,E,T=>({tag:z,data:T}),c)}function J(z){const b=(0,e.u32)("length"),c=(0,e.struct)([b,(0,e.blob)((0,e.offset)(b,-b.span),"data")]);return new _(c,({data:f})=>f,f=>({data:f}),z)}function Q(z){return new _(J(),b=>b.toString("utf-8"),b=>Buffer.from(b,"utf-8"),z)}function tt(z,b,c){const f=(0,e.union)(c??(0,e.u8)(),b);return z.forEach((E,T)=>f.addVariant(T,E,E.property)),f}function L(z,b,c){const f=(0,e.struct)([(0,e.seq)(z,b,"values")]);return new _(f,({values:E})=>E,E=>({values:E}),c)}class U extends e.Layout{constructor(b,c,f){super(b.span+c.span,f),this.keyLayout=b,this.valueLayout=c}decode(b,c){c=c||0;const f=this.keyLayout.decode(b,c),E=this.valueLayout.decode(b,c+this.keyLayout.getSpan(b,c));return[f,E]}encode(b,c,f){f=f||0;const E=this.keyLayout.encode(b[0],c,f),T=this.valueLayout.encode(b[1],c,f+E);return E+T}getSpan(b,c){return this.keyLayout.getSpan(b,c)+this.valueLayout.getSpan(b,c)}}function F(z,b,c){const f=(0,e.u32)("length"),E=(0,e.struct)([f,(0,e.seq)(new U(z,b),(0,e.offset)(f,-f.span),"values")]);return new _(E,({values:T})=>new Map(T),T=>({values:Array.from(T.entries())}),c)}})(_n)),_n}var mt=Yg();/*! pako 2.1.0 https://github.com/nodeca/pako @license (MIT AND Zlib) */function yn(n){let t=n.length;for(;--t>=0;)n[t]=0}const Zg=3,Xg=258,bl=29,Jg=256,Qg=Jg+1+bl,El=30,tm=512,em=new Array((Qg+2)*2);yn(em);const rm=new Array(El*2);yn(rm);const nm=new Array(tm);yn(nm);const im=new Array(Xg-Zg+1);yn(im);const sm=new Array(bl);yn(sm);const om=new Array(El);yn(om);const am=(n,t,e,r)=>{let s=n&65535|0,i=n>>>16&65535|0,o=0;for(;e!==0;){o=e>2e3?2e3:e,e-=o;do s=s+t[r++]|0,i=i+s|0;while(--o);s%=65521,i%=65521}return s|i<<16|0};var fo=am;const cm=()=>{let n,t=[];for(var e=0;e<256;e++){n=e;for(var r=0;r<8;r++)n=n&1?3988292384^n>>>1:n>>>1;t[e]=n}return t},um=new Uint32Array(cm()),lm=(n,t,e,r)=>{const s=um,i=r+e;n^=-1;for(let o=r;o<i;o++)n=n>>>8^s[(n^t[o])&255];return n^-1};var Ve=lm,po={2:"need dictionary",1:"stream end",0:"","-1":"file error","-2":"stream error","-3":"data error","-4":"insufficient memory","-5":"buffer error","-6":"incompatible version"},Rl={Z_NO_FLUSH:0,Z_FINISH:4,Z_BLOCK:5,Z_TREES:6,Z_OK:0,Z_STREAM_END:1,Z_NEED_DICT:2,Z_STREAM_ERROR:-2,Z_DATA_ERROR:-3,Z_MEM_ERROR:-4,Z_BUF_ERROR:-5,Z_DEFLATED:8};const hm=(n,t)=>Object.prototype.hasOwnProperty.call(n,t);var fm=function(n){const t=Array.prototype.slice.call(arguments,1);for(;t.length;){const e=t.shift();if(e){if(typeof e!="object")throw new TypeError(e+"must be non-object");for(const r in e)hm(e,r)&&(n[r]=e[r])}}return n},dm=n=>{let t=0;for(let r=0,s=n.length;r<s;r++)t+=n[r].length;const e=new Uint8Array(t);for(let r=0,s=0,i=n.length;r<i;r++){let o=n[r];e.set(o,s),s+=o.length}return e},vl={assign:fm,flattenChunks:dm};let Al=!0;try{String.fromCharCode.apply(null,new Uint8Array(1))}catch{Al=!1}const On=new Uint8Array(256);for(let n=0;n<256;n++)On[n]=n>=252?6:n>=248?5:n>=240?4:n>=224?3:n>=192?2:1;On[254]=On[254]=1;var pm=n=>{if(typeof TextEncoder=="function"&&TextEncoder.prototype.encode)return new TextEncoder().encode(n);let t,e,r,s,i,o=n.length,a=0;for(s=0;s<o;s++)e=n.charCodeAt(s),(e&64512)===55296&&s+1<o&&(r=n.charCodeAt(s+1),(r&64512)===56320&&(e=65536+(e-55296<<10)+(r-56320),s++)),a+=e<128?1:e<2048?2:e<65536?3:4;for(t=new Uint8Array(a),i=0,s=0;i<a;s++)e=n.charCodeAt(s),(e&64512)===55296&&s+1<o&&(r=n.charCodeAt(s+1),(r&64512)===56320&&(e=65536+(e-55296<<10)+(r-56320),s++)),e<128?t[i++]=e:e<2048?(t[i++]=192|e>>>6,t[i++]=128|e&63):e<65536?(t[i++]=224|e>>>12,t[i++]=128|e>>>6&63,t[i++]=128|e&63):(t[i++]=240|e>>>18,t[i++]=128|e>>>12&63,t[i++]=128|e>>>6&63,t[i++]=128|e&63);return t};const ym=(n,t)=>{if(t<65534&&n.subarray&&Al)return String.fromCharCode.apply(null,n.length===t?n:n.subarray(0,t));let e="";for(let r=0;r<t;r++)e+=String.fromCharCode(n[r]);return e};var gm=(n,t)=>{const e=t||n.length;if(typeof TextDecoder=="function"&&TextDecoder.prototype.decode)return new TextDecoder().decode(n.subarray(0,t));let r,s;const i=new Array(e*2);for(s=0,r=0;r<e;){let o=n[r++];if(o<128){i[s++]=o;continue}let a=On[o];if(a>4){i[s++]=65533,r+=a-1;continue}for(o&=a===2?31:a===3?15:7;a>1&&r<e;)o=o<<6|n[r++]&63,a--;if(a>1){i[s++]=65533;continue}o<65536?i[s++]=o:(o-=65536,i[s++]=55296|o>>10&1023,i[s++]=56320|o&1023)}return ym(i,s)},mm=(n,t)=>{t=t||n.length,t>n.length&&(t=n.length);let e=t-1;for(;e>=0&&(n[e]&192)===128;)e--;return e<0||e===0?t:e+On[n[e]]>t?e:t},yo={string2buf:pm,buf2string:gm,utf8border:mm};function wm(){this.input=null,this.next_in=0,this.avail_in=0,this.total_in=0,this.output=null,this.next_out=0,this.avail_out=0,this.total_out=0,this.msg="",this.state=null,this.data_type=2,this.adler=0}var _m=wm;const ei=16209,bm=16191;var Em=function(t,e){let r,s,i,o,a,l,p,m,S,R,_,I,O,x,M,H,P,q,G,J,Q,tt,L,U;const F=t.state;r=t.next_in,L=t.input,s=r+(t.avail_in-5),i=t.next_out,U=t.output,o=i-(e-t.avail_out),a=i+(t.avail_out-257),l=F.dmax,p=F.wsize,m=F.whave,S=F.wnext,R=F.window,_=F.hold,I=F.bits,O=F.lencode,x=F.distcode,M=(1<<F.lenbits)-1,H=(1<<F.distbits)-1;t:do{I<15&&(_+=L[r++]<<I,I+=8,_+=L[r++]<<I,I+=8),P=O[_&M];e:for(;;){if(q=P>>>24,_>>>=q,I-=q,q=P>>>16&255,q===0)U[i++]=P&65535;else if(q&16){G=P&65535,q&=15,q&&(I<q&&(_+=L[r++]<<I,I+=8),G+=_&(1<<q)-1,_>>>=q,I-=q),I<15&&(_+=L[r++]<<I,I+=8,_+=L[r++]<<I,I+=8),P=x[_&H];r:for(;;){if(q=P>>>24,_>>>=q,I-=q,q=P>>>16&255,q&16){if(J=P&65535,q&=15,I<q&&(_+=L[r++]<<I,I+=8,I<q&&(_+=L[r++]<<I,I+=8)),J+=_&(1<<q)-1,J>l){t.msg="invalid distance too far back",F.mode=ei;break t}if(_>>>=q,I-=q,q=i-o,J>q){if(q=J-q,q>m&&F.sane){t.msg="invalid distance too far back",F.mode=ei;break t}if(Q=0,tt=R,S===0){if(Q+=p-q,q<G){G-=q;do U[i++]=R[Q++];while(--q);Q=i-J,tt=U}}else if(S<q){if(Q+=p+S-q,q-=S,q<G){G-=q;do U[i++]=R[Q++];while(--q);if(Q=0,S<G){q=S,G-=q;do U[i++]=R[Q++];while(--q);Q=i-J,tt=U}}}else if(Q+=S-q,q<G){G-=q;do U[i++]=R[Q++];while(--q);Q=i-J,tt=U}for(;G>2;)U[i++]=tt[Q++],U[i++]=tt[Q++],U[i++]=tt[Q++],G-=3;G&&(U[i++]=tt[Q++],G>1&&(U[i++]=tt[Q++]))}else{Q=i-J;do U[i++]=U[Q++],U[i++]=U[Q++],U[i++]=U[Q++],G-=3;while(G>2);G&&(U[i++]=U[Q++],G>1&&(U[i++]=U[Q++]))}}else if((q&64)===0){P=x[(P&65535)+(_&(1<<q)-1)];continue r}else{t.msg="invalid distance code",F.mode=ei;break t}break}}else if((q&64)===0){P=O[(P&65535)+(_&(1<<q)-1)];continue e}else if(q&32){F.mode=bm;break t}else{t.msg="invalid literal/length code",F.mode=ei;break t}break}}while(r<s&&i<a);G=I>>3,r-=G,I-=G<<3,_&=(1<<I)-1,t.next_in=r,t.next_out=i,t.avail_in=r<s?5+(s-r):5-(r-s),t.avail_out=i<a?257+(a-i):257-(i-a),F.hold=_,F.bits=I};const Zr=15,wc=852,_c=592,bc=0,$s=1,Ec=2,Rm=new Uint16Array([3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0]),vm=new Uint8Array([16,16,16,16,16,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21,21,16,72,78]),Am=new Uint16Array([1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0]),Im=new Uint8Array([16,16,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,64,64]),Sm=(n,t,e,r,s,i,o,a)=>{const l=a.bits;let p=0,m=0,S=0,R=0,_=0,I=0,O=0,x=0,M=0,H=0,P,q,G,J,Q,tt=null,L;const U=new Uint16Array(Zr+1),F=new Uint16Array(Zr+1);let z=null,b,c,f;for(p=0;p<=Zr;p++)U[p]=0;for(m=0;m<r;m++)U[t[e+m]]++;for(_=l,R=Zr;R>=1&&U[R]===0;R--);if(_>R&&(_=R),R===0)return s[i++]=1<<24|64<<16|0,s[i++]=1<<24|64<<16|0,a.bits=1,0;for(S=1;S<R&&U[S]===0;S++);for(_<S&&(_=S),x=1,p=1;p<=Zr;p++)if(x<<=1,x-=U[p],x<0)return-1;if(x>0&&(n===bc||R!==1))return-1;for(F[1]=0,p=1;p<Zr;p++)F[p+1]=F[p]+U[p];for(m=0;m<r;m++)t[e+m]!==0&&(o[F[t[e+m]]++]=m);if(n===bc?(tt=z=o,L=20):n===$s?(tt=Rm,z=vm,L=257):(tt=Am,z=Im,L=0),H=0,m=0,p=S,Q=i,I=_,O=0,G=-1,M=1<<_,J=M-1,n===$s&&M>wc||n===Ec&&M>_c)return 1;for(;;){b=p-O,o[m]+1<L?(c=0,f=o[m]):o[m]>=L?(c=z[o[m]-L],f=tt[o[m]-L]):(c=96,f=0),P=1<<p-O,q=1<<I,S=q;do q-=P,s[Q+(H>>O)+q]=b<<24|c<<16|f|0;while(q!==0);for(P=1<<p-1;H&P;)P>>=1;if(P!==0?(H&=P-1,H+=P):H=0,m++,--U[p]===0){if(p===R)break;p=t[e+o[m]]}if(p>_&&(H&J)!==G){for(O===0&&(O=_),Q+=S,I=p-O,x=1<<I;I+O<R&&(x-=U[I+O],!(x<=0));)I++,x<<=1;if(M+=1<<I,n===$s&&M>wc||n===Ec&&M>_c)return 1;G=H&J,s[G]=_<<24|I<<16|Q-i|0}}return H!==0&&(s[Q+H]=p-O<<24|64<<16|0),a.bits=_,0};var Rn=Sm;const km=0,Il=1,Sl=2,{Z_FINISH:Rc,Z_BLOCK:Tm,Z_TREES:ri,Z_OK:Hr,Z_STREAM_END:Om,Z_NEED_DICT:xm,Z_STREAM_ERROR:De,Z_DATA_ERROR:kl,Z_MEM_ERROR:Tl,Z_BUF_ERROR:Nm,Z_DEFLATED:vc}=Rl,qi=16180,Ac=16181,Ic=16182,Sc=16183,kc=16184,Tc=16185,Oc=16186,xc=16187,Nc=16188,Cc=16189,vi=16190,rr=16191,Vs=16192,Bc=16193,Ws=16194,Mc=16195,Lc=16196,Pc=16197,Uc=16198,ni=16199,ii=16200,Dc=16201,Hc=16202,Fc=16203,zc=16204,Kc=16205,Gs=16206,qc=16207,$c=16208,Ht=16209,Ol=16210,xl=16211,Cm=852,Bm=592,Mm=15,Lm=Mm,Vc=n=>(n>>>24&255)+(n>>>8&65280)+((n&65280)<<8)+((n&255)<<24);function Pm(){this.strm=null,this.mode=0,this.last=!1,this.wrap=0,this.havedict=!1,this.flags=0,this.dmax=0,this.check=0,this.total=0,this.head=null,this.wbits=0,this.wsize=0,this.whave=0,this.wnext=0,this.window=null,this.hold=0,this.bits=0,this.length=0,this.offset=0,this.extra=0,this.lencode=null,this.distcode=null,this.lenbits=0,this.distbits=0,this.ncode=0,this.nlen=0,this.ndist=0,this.have=0,this.next=null,this.lens=new Uint16Array(320),this.work=new Uint16Array(288),this.lendyn=null,this.distdyn=null,this.sane=0,this.back=0,this.was=0}const Vr=n=>{if(!n)return 1;const t=n.state;return!t||t.strm!==n||t.mode<qi||t.mode>xl?1:0},Nl=n=>{if(Vr(n))return De;const t=n.state;return n.total_in=n.total_out=t.total=0,n.msg="",t.wrap&&(n.adler=t.wrap&1),t.mode=qi,t.last=0,t.havedict=0,t.flags=-1,t.dmax=32768,t.head=null,t.hold=0,t.bits=0,t.lencode=t.lendyn=new Int32Array(Cm),t.distcode=t.distdyn=new Int32Array(Bm),t.sane=1,t.back=-1,Hr},Cl=n=>{if(Vr(n))return De;const t=n.state;return t.wsize=0,t.whave=0,t.wnext=0,Nl(n)},Bl=(n,t)=>{let e;if(Vr(n))return De;const r=n.state;return t<0?(e=0,t=-t):(e=(t>>4)+5,t<48&&(t&=15)),t&&(t<8||t>15)?De:(r.window!==null&&r.wbits!==t&&(r.window=null),r.wrap=e,r.wbits=t,Cl(n))},Ml=(n,t)=>{if(!n)return De;const e=new Pm;n.state=e,e.strm=n,e.window=null,e.mode=qi;const r=Bl(n,t);return r!==Hr&&(n.state=null),r},Um=n=>Ml(n,Lm);let Wc=!0,js,Ys;const Dm=n=>{if(Wc){js=new Int32Array(512),Ys=new Int32Array(32);let t=0;for(;t<144;)n.lens[t++]=8;for(;t<256;)n.lens[t++]=9;for(;t<280;)n.lens[t++]=7;for(;t<288;)n.lens[t++]=8;for(Rn(Il,n.lens,0,288,js,0,n.work,{bits:9}),t=0;t<32;)n.lens[t++]=5;Rn(Sl,n.lens,0,32,Ys,0,n.work,{bits:5}),Wc=!1}n.lencode=js,n.lenbits=9,n.distcode=Ys,n.distbits=5},Ll=(n,t,e,r)=>{let s;const i=n.state;return i.window===null&&(i.wsize=1<<i.wbits,i.wnext=0,i.whave=0,i.window=new Uint8Array(i.wsize)),r>=i.wsize?(i.window.set(t.subarray(e-i.wsize,e),0),i.wnext=0,i.whave=i.wsize):(s=i.wsize-i.wnext,s>r&&(s=r),i.window.set(t.subarray(e-r,e-r+s),i.wnext),r-=s,r?(i.window.set(t.subarray(e-r,e),0),i.wnext=r,i.whave=i.wsize):(i.wnext+=s,i.wnext===i.wsize&&(i.wnext=0),i.whave<i.wsize&&(i.whave+=s))),0},Hm=(n,t)=>{let e,r,s,i,o,a,l,p,m,S,R,_,I,O,x=0,M,H,P,q,G,J,Q,tt;const L=new Uint8Array(4);let U,F;const z=new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]);if(Vr(n)||!n.output||!n.input&&n.avail_in!==0)return De;e=n.state,e.mode===rr&&(e.mode=Vs),o=n.next_out,s=n.output,l=n.avail_out,i=n.next_in,r=n.input,a=n.avail_in,p=e.hold,m=e.bits,S=a,R=l,tt=Hr;t:for(;;)switch(e.mode){case qi:if(e.wrap===0){e.mode=Vs;break}for(;m<16;){if(a===0)break t;a--,p+=r[i++]<<m,m+=8}if(e.wrap&2&&p===35615){e.wbits===0&&(e.wbits=15),e.check=0,L[0]=p&255,L[1]=p>>>8&255,e.check=Ve(e.check,L,2,0),p=0,m=0,e.mode=Ac;break}if(e.head&&(e.head.done=!1),!(e.wrap&1)||(((p&255)<<8)+(p>>8))%31){n.msg="incorrect header check",e.mode=Ht;break}if((p&15)!==vc){n.msg="unknown compression method",e.mode=Ht;break}if(p>>>=4,m-=4,Q=(p&15)+8,e.wbits===0&&(e.wbits=Q),Q>15||Q>e.wbits){n.msg="invalid window size",e.mode=Ht;break}e.dmax=1<<e.wbits,e.flags=0,n.adler=e.check=1,e.mode=p&512?Cc:rr,p=0,m=0;break;case Ac:for(;m<16;){if(a===0)break t;a--,p+=r[i++]<<m,m+=8}if(e.flags=p,(e.flags&255)!==vc){n.msg="unknown compression method",e.mode=Ht;break}if(e.flags&57344){n.msg="unknown header flags set",e.mode=Ht;break}e.head&&(e.head.text=p>>8&1),e.flags&512&&e.wrap&4&&(L[0]=p&255,L[1]=p>>>8&255,e.check=Ve(e.check,L,2,0)),p=0,m=0,e.mode=Ic;case Ic:for(;m<32;){if(a===0)break t;a--,p+=r[i++]<<m,m+=8}e.head&&(e.head.time=p),e.flags&512&&e.wrap&4&&(L[0]=p&255,L[1]=p>>>8&255,L[2]=p>>>16&255,L[3]=p>>>24&255,e.check=Ve(e.check,L,4,0)),p=0,m=0,e.mode=Sc;case Sc:for(;m<16;){if(a===0)break t;a--,p+=r[i++]<<m,m+=8}e.head&&(e.head.xflags=p&255,e.head.os=p>>8),e.flags&512&&e.wrap&4&&(L[0]=p&255,L[1]=p>>>8&255,e.check=Ve(e.check,L,2,0)),p=0,m=0,e.mode=kc;case kc:if(e.flags&1024){for(;m<16;){if(a===0)break t;a--,p+=r[i++]<<m,m+=8}e.length=p,e.head&&(e.head.extra_len=p),e.flags&512&&e.wrap&4&&(L[0]=p&255,L[1]=p>>>8&255,e.check=Ve(e.check,L,2,0)),p=0,m=0}else e.head&&(e.head.extra=null);e.mode=Tc;case Tc:if(e.flags&1024&&(_=e.length,_>a&&(_=a),_&&(e.head&&(Q=e.head.extra_len-e.length,e.head.extra||(e.head.extra=new Uint8Array(e.head.extra_len)),e.head.extra.set(r.subarray(i,i+_),Q)),e.flags&512&&e.wrap&4&&(e.check=Ve(e.check,r,_,i)),a-=_,i+=_,e.length-=_),e.length))break t;e.length=0,e.mode=Oc;case Oc:if(e.flags&2048){if(a===0)break t;_=0;do Q=r[i+_++],e.head&&Q&&e.length<65536&&(e.head.name+=String.fromCharCode(Q));while(Q&&_<a);if(e.flags&512&&e.wrap&4&&(e.check=Ve(e.check,r,_,i)),a-=_,i+=_,Q)break t}else e.head&&(e.head.name=null);e.length=0,e.mode=xc;case xc:if(e.flags&4096){if(a===0)break t;_=0;do Q=r[i+_++],e.head&&Q&&e.length<65536&&(e.head.comment+=String.fromCharCode(Q));while(Q&&_<a);if(e.flags&512&&e.wrap&4&&(e.check=Ve(e.check,r,_,i)),a-=_,i+=_,Q)break t}else e.head&&(e.head.comment=null);e.mode=Nc;case Nc:if(e.flags&512){for(;m<16;){if(a===0)break t;a--,p+=r[i++]<<m,m+=8}if(e.wrap&4&&p!==(e.check&65535)){n.msg="header crc mismatch",e.mode=Ht;break}p=0,m=0}e.head&&(e.head.hcrc=e.flags>>9&1,e.head.done=!0),n.adler=e.check=0,e.mode=rr;break;case Cc:for(;m<32;){if(a===0)break t;a--,p+=r[i++]<<m,m+=8}n.adler=e.check=Vc(p),p=0,m=0,e.mode=vi;case vi:if(e.havedict===0)return n.next_out=o,n.avail_out=l,n.next_in=i,n.avail_in=a,e.hold=p,e.bits=m,xm;n.adler=e.check=1,e.mode=rr;case rr:if(t===Tm||t===ri)break t;case Vs:if(e.last){p>>>=m&7,m-=m&7,e.mode=Gs;break}for(;m<3;){if(a===0)break t;a--,p+=r[i++]<<m,m+=8}switch(e.last=p&1,p>>>=1,m-=1,p&3){case 0:e.mode=Bc;break;case 1:if(Dm(e),e.mode=ni,t===ri){p>>>=2,m-=2;break t}break;case 2:e.mode=Lc;break;case 3:n.msg="invalid block type",e.mode=Ht}p>>>=2,m-=2;break;case Bc:for(p>>>=m&7,m-=m&7;m<32;){if(a===0)break t;a--,p+=r[i++]<<m,m+=8}if((p&65535)!==(p>>>16^65535)){n.msg="invalid stored block lengths",e.mode=Ht;break}if(e.length=p&65535,p=0,m=0,e.mode=Ws,t===ri)break t;case Ws:e.mode=Mc;case Mc:if(_=e.length,_){if(_>a&&(_=a),_>l&&(_=l),_===0)break t;s.set(r.subarray(i,i+_),o),a-=_,i+=_,l-=_,o+=_,e.length-=_;break}e.mode=rr;break;case Lc:for(;m<14;){if(a===0)break t;a--,p+=r[i++]<<m,m+=8}if(e.nlen=(p&31)+257,p>>>=5,m-=5,e.ndist=(p&31)+1,p>>>=5,m-=5,e.ncode=(p&15)+4,p>>>=4,m-=4,e.nlen>286||e.ndist>30){n.msg="too many length or distance symbols",e.mode=Ht;break}e.have=0,e.mode=Pc;case Pc:for(;e.have<e.ncode;){for(;m<3;){if(a===0)break t;a--,p+=r[i++]<<m,m+=8}e.lens[z[e.have++]]=p&7,p>>>=3,m-=3}for(;e.have<19;)e.lens[z[e.have++]]=0;if(e.lencode=e.lendyn,e.lenbits=7,U={bits:e.lenbits},tt=Rn(km,e.lens,0,19,e.lencode,0,e.work,U),e.lenbits=U.bits,tt){n.msg="invalid code lengths set",e.mode=Ht;break}e.have=0,e.mode=Uc;case Uc:for(;e.have<e.nlen+e.ndist;){for(;x=e.lencode[p&(1<<e.lenbits)-1],M=x>>>24,H=x>>>16&255,P=x&65535,!(M<=m);){if(a===0)break t;a--,p+=r[i++]<<m,m+=8}if(P<16)p>>>=M,m-=M,e.lens[e.have++]=P;else{if(P===16){for(F=M+2;m<F;){if(a===0)break t;a--,p+=r[i++]<<m,m+=8}if(p>>>=M,m-=M,e.have===0){n.msg="invalid bit length repeat",e.mode=Ht;break}Q=e.lens[e.have-1],_=3+(p&3),p>>>=2,m-=2}else if(P===17){for(F=M+3;m<F;){if(a===0)break t;a--,p+=r[i++]<<m,m+=8}p>>>=M,m-=M,Q=0,_=3+(p&7),p>>>=3,m-=3}else{for(F=M+7;m<F;){if(a===0)break t;a--,p+=r[i++]<<m,m+=8}p>>>=M,m-=M,Q=0,_=11+(p&127),p>>>=7,m-=7}if(e.have+_>e.nlen+e.ndist){n.msg="invalid bit length repeat",e.mode=Ht;break}for(;_--;)e.lens[e.have++]=Q}}if(e.mode===Ht)break;if(e.lens[256]===0){n.msg="invalid code -- missing end-of-block",e.mode=Ht;break}if(e.lenbits=9,U={bits:e.lenbits},tt=Rn(Il,e.lens,0,e.nlen,e.lencode,0,e.work,U),e.lenbits=U.bits,tt){n.msg="invalid literal/lengths set",e.mode=Ht;break}if(e.distbits=6,e.distcode=e.distdyn,U={bits:e.distbits},tt=Rn(Sl,e.lens,e.nlen,e.ndist,e.distcode,0,e.work,U),e.distbits=U.bits,tt){n.msg="invalid distances set",e.mode=Ht;break}if(e.mode=ni,t===ri)break t;case ni:e.mode=ii;case ii:if(a>=6&&l>=258){n.next_out=o,n.avail_out=l,n.next_in=i,n.avail_in=a,e.hold=p,e.bits=m,Em(n,R),o=n.next_out,s=n.output,l=n.avail_out,i=n.next_in,r=n.input,a=n.avail_in,p=e.hold,m=e.bits,e.mode===rr&&(e.back=-1);break}for(e.back=0;x=e.lencode[p&(1<<e.lenbits)-1],M=x>>>24,H=x>>>16&255,P=x&65535,!(M<=m);){if(a===0)break t;a--,p+=r[i++]<<m,m+=8}if(H&&(H&240)===0){for(q=M,G=H,J=P;x=e.lencode[J+((p&(1<<q+G)-1)>>q)],M=x>>>24,H=x>>>16&255,P=x&65535,!(q+M<=m);){if(a===0)break t;a--,p+=r[i++]<<m,m+=8}p>>>=q,m-=q,e.back+=q}if(p>>>=M,m-=M,e.back+=M,e.length=P,H===0){e.mode=Kc;break}if(H&32){e.back=-1,e.mode=rr;break}if(H&64){n.msg="invalid literal/length code",e.mode=Ht;break}e.extra=H&15,e.mode=Dc;case Dc:if(e.extra){for(F=e.extra;m<F;){if(a===0)break t;a--,p+=r[i++]<<m,m+=8}e.length+=p&(1<<e.extra)-1,p>>>=e.extra,m-=e.extra,e.back+=e.extra}e.was=e.length,e.mode=Hc;case Hc:for(;x=e.distcode[p&(1<<e.distbits)-1],M=x>>>24,H=x>>>16&255,P=x&65535,!(M<=m);){if(a===0)break t;a--,p+=r[i++]<<m,m+=8}if((H&240)===0){for(q=M,G=H,J=P;x=e.distcode[J+((p&(1<<q+G)-1)>>q)],M=x>>>24,H=x>>>16&255,P=x&65535,!(q+M<=m);){if(a===0)break t;a--,p+=r[i++]<<m,m+=8}p>>>=q,m-=q,e.back+=q}if(p>>>=M,m-=M,e.back+=M,H&64){n.msg="invalid distance code",e.mode=Ht;break}e.offset=P,e.extra=H&15,e.mode=Fc;case Fc:if(e.extra){for(F=e.extra;m<F;){if(a===0)break t;a--,p+=r[i++]<<m,m+=8}e.offset+=p&(1<<e.extra)-1,p>>>=e.extra,m-=e.extra,e.back+=e.extra}if(e.offset>e.dmax){n.msg="invalid distance too far back",e.mode=Ht;break}e.mode=zc;case zc:if(l===0)break t;if(_=R-l,e.offset>_){if(_=e.offset-_,_>e.whave&&e.sane){n.msg="invalid distance too far back",e.mode=Ht;break}_>e.wnext?(_-=e.wnext,I=e.wsize-_):I=e.wnext-_,_>e.length&&(_=e.length),O=e.window}else O=s,I=o-e.offset,_=e.length;_>l&&(_=l),l-=_,e.length-=_;do s[o++]=O[I++];while(--_);e.length===0&&(e.mode=ii);break;case Kc:if(l===0)break t;s[o++]=e.length,l--,e.mode=ii;break;case Gs:if(e.wrap){for(;m<32;){if(a===0)break t;a--,p|=r[i++]<<m,m+=8}if(R-=l,n.total_out+=R,e.total+=R,e.wrap&4&&R&&(n.adler=e.check=e.flags?Ve(e.check,s,R,o-R):fo(e.check,s,R,o-R)),R=l,e.wrap&4&&(e.flags?p:Vc(p))!==e.check){n.msg="incorrect data check",e.mode=Ht;break}p=0,m=0}e.mode=qc;case qc:if(e.wrap&&e.flags){for(;m<32;){if(a===0)break t;a--,p+=r[i++]<<m,m+=8}if(e.wrap&4&&p!==(e.total&4294967295)){n.msg="incorrect length check",e.mode=Ht;break}p=0,m=0}e.mode=$c;case $c:tt=Om;break t;case Ht:tt=kl;break t;case Ol:return Tl;case xl:default:return De}return n.next_out=o,n.avail_out=l,n.next_in=i,n.avail_in=a,e.hold=p,e.bits=m,(e.wsize||R!==n.avail_out&&e.mode<Ht&&(e.mode<Gs||t!==Rc))&&Ll(n,n.output,n.next_out,R-n.avail_out),S-=n.avail_in,R-=n.avail_out,n.total_in+=S,n.total_out+=R,e.total+=R,e.wrap&4&&R&&(n.adler=e.check=e.flags?Ve(e.check,s,R,n.next_out-R):fo(e.check,s,R,n.next_out-R)),n.data_type=e.bits+(e.last?64:0)+(e.mode===rr?128:0)+(e.mode===ni||e.mode===Ws?256:0),(S===0&&R===0||t===Rc)&&tt===Hr&&(tt=Nm),tt},Fm=n=>{if(Vr(n))return De;let t=n.state;return t.window&&(t.window=null),n.state=null,Hr},zm=(n,t)=>{if(Vr(n))return De;const e=n.state;return(e.wrap&2)===0?De:(e.head=t,t.done=!1,Hr)},Km=(n,t)=>{const e=t.length;let r,s,i;return Vr(n)||(r=n.state,r.wrap!==0&&r.mode!==vi)?De:r.mode===vi&&(s=1,s=fo(s,t,e,0),s!==r.check)?kl:(i=Ll(n,t,e,e),i?(r.mode=Ol,Tl):(r.havedict=1,Hr))};var qm=Cl,$m=Bl,Vm=Nl,Wm=Um,Gm=Ml,jm=Hm,Ym=Fm,Zm=zm,Xm=Km,Jm="pako inflate (from Nodeca project)",sr={inflateReset:qm,inflateReset2:$m,inflateResetKeep:Vm,inflateInit:Wm,inflateInit2:Gm,inflate:jm,inflateEnd:Ym,inflateGetHeader:Zm,inflateSetDictionary:Xm,inflateInfo:Jm};function Qm(){this.text=0,this.time=0,this.xflags=0,this.os=0,this.extra=null,this.extra_len=0,this.name="",this.comment="",this.hcrc=0,this.done=!1}var tw=Qm;const Pl=Object.prototype.toString,{Z_NO_FLUSH:ew,Z_FINISH:rw,Z_OK:xn,Z_STREAM_END:Zs,Z_NEED_DICT:Xs,Z_STREAM_ERROR:nw,Z_DATA_ERROR:Gc,Z_MEM_ERROR:iw}=Rl;function $i(n){this.options=vl.assign({chunkSize:1024*64,windowBits:15,to:""},n||{});const t=this.options;t.raw&&t.windowBits>=0&&t.windowBits<16&&(t.windowBits=-t.windowBits,t.windowBits===0&&(t.windowBits=-15)),t.windowBits>=0&&t.windowBits<16&&!(n&&n.windowBits)&&(t.windowBits+=32),t.windowBits>15&&t.windowBits<48&&(t.windowBits&15)===0&&(t.windowBits|=15),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new _m,this.strm.avail_out=0;let e=sr.inflateInit2(this.strm,t.windowBits);if(e!==xn)throw new Error(po[e]);if(this.header=new tw,sr.inflateGetHeader(this.strm,this.header),t.dictionary&&(typeof t.dictionary=="string"?t.dictionary=yo.string2buf(t.dictionary):Pl.call(t.dictionary)==="[object ArrayBuffer]"&&(t.dictionary=new Uint8Array(t.dictionary)),t.raw&&(e=sr.inflateSetDictionary(this.strm,t.dictionary),e!==xn)))throw new Error(po[e])}$i.prototype.push=function(n,t){const e=this.strm,r=this.options.chunkSize,s=this.options.dictionary;let i,o,a;if(this.ended)return!1;for(t===~~t?o=t:o=t===!0?rw:ew,Pl.call(n)==="[object ArrayBuffer]"?e.input=new Uint8Array(n):e.input=n,e.next_in=0,e.avail_in=e.input.length;;){for(e.avail_out===0&&(e.output=new Uint8Array(r),e.next_out=0,e.avail_out=r),i=sr.inflate(e,o),i===Xs&&s&&(i=sr.inflateSetDictionary(e,s),i===xn?i=sr.inflate(e,o):i===Gc&&(i=Xs));e.avail_in>0&&i===Zs&&e.state.wrap>0&&n[e.next_in]!==0;)sr.inflateReset(e),i=sr.inflate(e,o);switch(i){case nw:case Gc:case Xs:case iw:return this.onEnd(i),this.ended=!0,!1}if(a=e.avail_out,e.next_out&&(e.avail_out===0||i===Zs))if(this.options.to==="string"){let l=yo.utf8border(e.output,e.next_out),p=e.next_out-l,m=yo.buf2string(e.output,l);e.next_out=p,e.avail_out=r-p,p&&e.output.set(e.output.subarray(l,l+p),0),this.onData(m)}else this.onData(e.output.length===e.next_out?e.output:e.output.subarray(0,e.next_out));if(!(i===xn&&a===0)){if(i===Zs)return i=sr.inflateEnd(this.strm),this.onEnd(i),this.ended=!0,!0;if(e.avail_in===0)break}}return!0};$i.prototype.onData=function(n){this.chunks.push(n)};$i.prototype.onEnd=function(n){n===xn&&(this.options.to==="string"?this.result=this.chunks.join(""):this.result=vl.flattenChunks(this.chunks)),this.chunks=[],this.err=n,this.msg=this.strm.msg};function sw(n,t){const e=new $i(t);if(e.push(n),e.err)throw e.msg||po[e.err];return e.result}var ow=sw,aw={inflate:ow};const{inflate:cw}=aw;var uw=cw,Js={exports:{}},jc;function lw(){return jc||(jc=1,(function(n){var t=Object.prototype.hasOwnProperty,e="~";function r(){}Object.create&&(r.prototype=Object.create(null),new r().__proto__||(e=!1));function s(l,p,m){this.fn=l,this.context=p,this.once=m||!1}function i(l,p,m,S,R){if(typeof m!="function")throw new TypeError("The listener must be a function");var _=new s(m,S||l,R),I=e?e+p:p;return l._events[I]?l._events[I].fn?l._events[I]=[l._events[I],_]:l._events[I].push(_):(l._events[I]=_,l._eventsCount++),l}function o(l,p){--l._eventsCount===0?l._events=new r:delete l._events[p]}function a(){this._events=new r,this._eventsCount=0}a.prototype.eventNames=function(){var p=[],m,S;if(this._eventsCount===0)return p;for(S in m=this._events)t.call(m,S)&&p.push(e?S.slice(1):S);return Object.getOwnPropertySymbols?p.concat(Object.getOwnPropertySymbols(m)):p},a.prototype.listeners=function(p){var m=e?e+p:p,S=this._events[m];if(!S)return[];if(S.fn)return[S.fn];for(var R=0,_=S.length,I=new Array(_);R<_;R++)I[R]=S[R].fn;return I},a.prototype.listenerCount=function(p){var m=e?e+p:p,S=this._events[m];return S?S.fn?1:S.length:0},a.prototype.emit=function(p,m,S,R,_,I){var O=e?e+p:p;if(!this._events[O])return!1;var x=this._events[O],M=arguments.length,H,P;if(x.fn){switch(x.once&&this.removeListener(p,x.fn,void 0,!0),M){case 1:return x.fn.call(x.context),!0;case 2:return x.fn.call(x.context,m),!0;case 3:return x.fn.call(x.context,m,S),!0;case 4:return x.fn.call(x.context,m,S,R),!0;case 5:return x.fn.call(x.context,m,S,R,_),!0;case 6:return x.fn.call(x.context,m,S,R,_,I),!0}for(P=1,H=new Array(M-1);P<M;P++)H[P-1]=arguments[P];x.fn.apply(x.context,H)}else{var q=x.length,G;for(P=0;P<q;P++)switch(x[P].once&&this.removeListener(p,x[P].fn,void 0,!0),M){case 1:x[P].fn.call(x[P].context);break;case 2:x[P].fn.call(x[P].context,m);break;case 3:x[P].fn.call(x[P].context,m,S);break;case 4:x[P].fn.call(x[P].context,m,S,R);break;default:if(!H)for(G=1,H=new Array(M-1);G<M;G++)H[G-1]=arguments[G];x[P].fn.apply(x[P].context,H)}}return!0},a.prototype.on=function(p,m,S){return i(this,p,m,S,!1)},a.prototype.once=function(p,m,S){return i(this,p,m,S,!0)},a.prototype.removeListener=function(p,m,S,R){var _=e?e+p:p;if(!this._events[_])return this;if(!m)return o(this,_),this;var I=this._events[_];if(I.fn)I.fn===m&&(!R||I.once)&&(!S||I.context===S)&&o(this,_);else{for(var O=0,x=[],M=I.length;O<M;O++)(I[O].fn!==m||R&&!I[O].once||S&&I[O].context!==S)&&x.push(I[O]);x.length?this._events[_]=x.length===1?x[0]:x:o(this,_)}return this},a.prototype.removeAllListeners=function(p){var m;return p?(m=e?e+p:p,this._events[m]&&o(this,m)):(this._events=new r,this._eventsCount=0),this},a.prototype.off=a.prototype.removeListener,a.prototype.addListener=a.prototype.on,a.prefixed=e,a.EventEmitter=a,n.exports=a})(Js)),Js.exports}var hw=lw();const fw=Fr(hw);function dw(n,t){return Array.apply(0,new Array(Math.ceil(n.length/t))).map((e,r)=>n.slice(r*t,(r+1)*t))}const kr=n=>"version"in n;function pw(n){return n.reduce((t,e)=>t+e.toString(16).padStart(2,"0"),"0x")}function yw(n){n.indexOf("0x")===0&&(n=n.substr(2)),n.length%2===1&&(n="0"+n);let t=n.match(/.{2}/g);return t===null?ht.Buffer.from([]):ht.Buffer.from(t.map(e=>parseInt(e,16)))}var gw=Object.freeze({__proto__:null,encode:pw,decode:yw});function Ul(n){return new TextDecoder("utf-8").decode(n)}function mw(n){return new TextEncoder().encode(n)}var ww=Object.freeze({__proto__:null,decode:Ul,encode:mw});function go(n){return Ki.encode(n)}function _w(n){return Ki.decode(n)}var bw=Object.freeze({__proto__:null,encode:go,decode:_w});function Ew(n){return n.toString("base64")}function Qo(n){return ht.Buffer.from(n,"base64")}var Rw=Object.freeze({__proto__:null,encode:Ew,decode:Qo}),vw=Object.freeze({__proto__:null,hex:gw,utf8:ww,bs58:bw,base64:Rw});function _r(n){return"accounts"in n}async function Aw(n){const t=(await rt.findProgramAddress([],n))[0];return await rt.createWithSeed(t,Iw(),n)}function Iw(){return"anchor:idl"}const Sw=mt.struct([mt.publicKey("authority"),mt.vecU8("data")]);function kw(n){return Sw.decode(n)}function Tw(n){const t=["name","path","account","relations","generic"],e=i=>i.split(".").map(jg).join("."),r=i=>{for(const o in i){const a=i[o];t.includes(o)?i[o]=Array.isArray(a)?a.map(e):e(a):typeof a=="object"&&r(a)}},s=structuredClone(n);return r(s),s}function Qr(n,t,e,r){return n?.length?n[0].name?e(n):r(n):t()}function Ow(n){const t=new Map;return n.errors&&n.errors.forEach(e=>{var r;let s=(r=e.msg)!==null&&r!==void 0?r:e.name;t.set(e.code,s)}),t}function xw(n,...t){if(n.args.length!=t.length)throw new Error("Invalid argument length");const e={};let r=0;return n.args.forEach(s=>{e[s.name]=t[r],r+=1}),e}function Dl(n,t={}){n.forEach(e=>{if(_r(e))Dl(e.accounts,t[e.name]);else if(!t[e.name])throw new Error(`Account \`${e.name}\` not provided.`)})}function Ue(n){return n instanceof rt?n:new rt(n)}class Nw extends TypeError{constructor(t,e){let r;const{message:s,...i}=t,{path:o}=t,a=o.length===0?s:"At path: "+o.join(".")+" -- "+s;super(a),this.value=void 0,this.key=void 0,this.type=void 0,this.refinement=void 0,this.path=void 0,this.branch=void 0,this.failures=void 0,Object.assign(this,i),this.name=this.constructor.name,this.failures=()=>{var l;return(l=r)!=null?l:r=[t,...e()]}}}function Cw(n){return sn(n)&&typeof n[Symbol.iterator]=="function"}function sn(n){return typeof n=="object"&&n!=null}function Ir(n){return typeof n=="string"?JSON.stringify(n):""+n}function Bw(n){const{done:t,value:e}=n.next();return t?void 0:e}function Mw(n,t,e,r){if(n===!0)return;n===!1?n={}:typeof n=="string"&&(n={message:n});const{path:s,branch:i}=t,{type:o}=e,{refinement:a,message:l="Expected a value of type `"+o+"`"+(a?" with refinement `"+a+"`":"")+", but received: `"+Ir(r)+"`"}=n;return{value:r,type:o,refinement:a,key:s[s.length-1],path:s,branch:i,...n,message:l}}function*Yc(n,t,e,r){Cw(n)||(n=[n]);for(const s of n){const i=Mw(s,t,e,r);i&&(yield i)}}function*ta(n,t,e){e===void 0&&(e={});const{path:r=[],branch:s=[n],coerce:i=!1,mask:o=!1}=e,a={path:r,branch:s};if(i&&(n=t.coercer(n,a),o&&t.type!=="type"&&sn(t.schema)&&sn(n)&&!Array.isArray(n)))for(const p in n)t.schema[p]===void 0&&delete n[p];let l=!0;for(const p of t.validator(n,a))l=!1,yield[p,void 0];for(let[p,m,S]of t.entries(n,a)){const R=ta(m,S,{path:p===void 0?r:[...r,p],branch:p===void 0?s:[...s,m],coerce:i,mask:o});for(const _ of R)_[0]?(l=!1,yield[_[0],void 0]):i&&(m=_[1],p===void 0?n=m:n instanceof Map?n.set(p,m):n instanceof Set?n.add(m):sn(n)&&(n[p]=m))}if(l)for(const p of t.refiner(n,a))l=!1,yield[p,void 0];l&&(yield[void 0,n])}class Sr{constructor(t){this.TYPE=void 0,this.type=void 0,this.schema=void 0,this.coercer=void 0,this.validator=void 0,this.refiner=void 0,this.entries=void 0;const{type:e,schema:r,validator:s,refiner:i,coercer:o=l=>l,entries:a=function*(){}}=t;this.type=e,this.schema=r,this.entries=a,this.coercer=o,s?this.validator=(l,p)=>{const m=s(l,p);return Yc(m,p,this,l)}:this.validator=()=>[],i?this.refiner=(l,p)=>{const m=i(l,p);return Yc(m,p,this,l)}:this.refiner=()=>[]}assert(t){return Lw(t,this)}create(t){return ea(t,this)}is(t){return Hl(t,this)}mask(t){return Pw(t,this)}validate(t,e){return e===void 0&&(e={}),Hn(t,this,e)}}function Lw(n,t){const e=Hn(n,t);if(e[0])throw e[0]}function ea(n,t){const e=Hn(n,t,{coerce:!0});if(e[0])throw e[0];return e[1]}function Pw(n,t){const e=Hn(n,t,{coerce:!0,mask:!0});if(e[0])throw e[0];return e[1]}function Hl(n,t){return!Hn(n,t)[0]}function Hn(n,t,e){e===void 0&&(e={});const r=ta(n,t,e),s=Bw(r);return s[0]?[new Nw(s[0],function*(){for(const o of r)o[0]&&(yield o[0])}),void 0]:[void 0,s[1]]}function Fn(n,t){return new Sr({type:n,schema:null,validator:t})}function Uw(){return Fn("any",()=>!0)}function Qs(n){return new Sr({type:"array",schema:n,*entries(t){if(n&&Array.isArray(t))for(const[e,r]of t.entries())yield[e,r,n]},coercer(t){return Array.isArray(t)?t.slice():t},validator(t){return Array.isArray(t)||"Expected an array value, but received: "+Ir(t)}})}function Dw(){return Fn("boolean",n=>typeof n=="boolean")}function Zc(n){const t=Ir(n);return new Sr({type:"literal",schema:n,validator(e){return e===n||"Expected the literal `"+t+"`, but received: "+Ir(e)}})}function si(n){return new Sr({...n,validator:(t,e)=>t===null||n.validator(t,e),refiner:(t,e)=>t===null||n.refiner(t,e)})}function li(){return Fn("number",n=>typeof n=="number"&&!isNaN(n)||"Expected a number, but received: "+Ir(n))}function hi(n){return new Sr({...n,validator:(t,e)=>t===void 0||n.validator(t,e),refiner:(t,e)=>t===void 0||n.refiner(t,e)})}function Br(){return Fn("string",n=>typeof n=="string"||"Expected a string, but received: "+Ir(n))}function Rr(n){const t=Object.keys(n);return new Sr({type:"type",schema:n,*entries(e){if(sn(e))for(const r of t)yield[r,e[r],n[r]]},validator(e){return sn(e)||"Expected an object, but received: "+Ir(e)}})}function Fl(n){const t=n.map(e=>e.type).join(" | ");return new Sr({type:"union",schema:null,coercer(e,r){return(n.find(i=>{const[o]=i.validate(e,{coerce:!0});return!o})||ra()).coercer(e,r)},validator(e,r){const s=[];for(const i of n){const[...o]=ta(e,i,r),[a]=o;if(a[0])for(const[l]of o)l&&s.push(l);else return[]}return["Expected the value to satisfy a union of `"+t+"`, but received: "+Ir(e),...s]}})}function ra(){return Fn("unknown",()=>!0)}function Hw(n,t,e){return new Sr({...n,coercer:(r,s)=>Hl(r,t)?n.coercer(e(r,s),s):n.coercer(r,s)})}async function Fw(n,t,e,r){n=Ue(n),r||(r=Ii());const s=new At;if(s.add(new xt({programId:n,keys:t??[],data:e})),r.sendAndConfirm===void 0)throw new Error("This function requires 'Provider.sendAndConfirm' to be implemented.");return await r.sendAndConfirm(s,[])}const Xc=99;async function zw(n,t,e){return(await na(n,t,e)).map(s=>s?{publicKey:s.publicKey,account:s.account}:null)}async function na(n,t,e){if(t.length<=Xc)return await Jc(n,t,e);{const r=dw(t,Xc);return(await Promise.all(r.map(i=>Jc(n,i,e)))).flat()}}async function Jc(n,t,e){const r=e??n.commitment,{value:s,context:i}=await n.getMultipleAccountsInfoAndContext(t,r);return s.map((a,l)=>a===null?null:{publicKey:t[l],account:a,context:i})}async function zl(n,t,e,r,s){var i;e&&e.length>0&&t.sign(...e);const o=t._compile(),a=o.serialize(),p=t._serialize(a).toString("base64"),m={encoding:"base64",commitment:r??n.commitment};if(s){const I=(Array.isArray(s)?s:o.nonProgramIds()).map(O=>O.toBase58());m.accounts={encoding:"base64",addresses:I}}e&&e.length>0&&(m.sigVerify=!0);const S=[p,m],R=await n._rpcRequest("simulateTransaction",S),_=ea(R,Vw);if("error"in _){let I;if("data"in _.error&&(I=(i=_.error.data)===null||i===void 0?void 0:i.logs,I&&Array.isArray(I))){const O=`
    `,x=O+I.join(O);console.error(_.error.message,x)}throw new Ar("failed to simulate transaction: "+_.error.message,I)}return _.result}function Kw(n){return Hw(Kl(n),qw,t=>"error"in t?t:{...t,result:ea(t.result,n)})}const qw=Kl(ra());function Kl(n){return Fl([Rr({jsonrpc:Zc("2.0"),id:Br(),result:n}),Rr({jsonrpc:Zc("2.0"),id:Br(),error:Rr({code:ra(),message:Br(),data:hi(Uw())})})])}function $w(n){return Kw(Rr({context:Rr({slot:li()}),value:n}))}const Vw=$w(Rr({err:si(Fl([Rr({}),Br()])),logs:si(Qs(Br())),accounts:hi(si(Qs(si(Rr({executable:Dw(),owner:Br(),lamports:li(),data:Qs(Br()),rentEpoch:hi(li())}))))),unitsConsumed:hi(li())}));var Ww=Object.freeze({__proto__:null,invoke:Fw,getMultipleAccounts:zw,getMultipleAccountsAndContext:na,simulateTransaction:zl});class Ai{constructor(t,e,r=Ai.defaultOptions()){this.connection=t,this.wallet=e,this.opts=r,this.publicKey=e?.publicKey}static defaultOptions(){return{preflightCommitment:"processed",commitment:"processed"}}static local(t,e=Ai.defaultOptions()){throw new Error("Provider local is not available on browser.")}static env(){throw new Error("Provider env is not available on browser.")}async sendAndConfirm(t,e,r){var s,i,o,a;if(r===void 0&&(r=this.opts),kr(t))e&&t.sign(e);else if(t.feePayer=(s=t.feePayer)!==null&&s!==void 0?s:this.wallet.publicKey,t.recentBlockhash=(await this.connection.getLatestBlockhash(r.preflightCommitment)).blockhash,e)for(const p of e)t.partialSign(p);t=await this.wallet.signTransaction(t);const l=t.serialize();try{return await Qc(this.connection,l,r)}catch(p){if(p instanceof mo){const m=go(kr(t)?((i=t.signatures)===null||i===void 0?void 0:i[0])||new Uint8Array:(o=t.signature)!==null&&o!==void 0?o:new Uint8Array),S=kr(t)?0:void 0,R=await this.connection.getTransaction(m,{commitment:"confirmed",maxSupportedTransactionVersion:S});if(R){const _=(a=R.meta)===null||a===void 0?void 0:a.logMessages;throw _?new Ar(p.message,_):p}else throw p}else throw p}}async sendAll(t,e){var r,s,i;e===void 0&&(e=this.opts);const o=(await this.connection.getLatestBlockhash(e.preflightCommitment)).blockhash;let a=t.map(m=>{var S,R;if(kr(m.tx)){let _=m.tx;return m.signers&&_.sign(m.signers),_}else{let _=m.tx,I=(S=m.signers)!==null&&S!==void 0?S:[];return _.feePayer=(R=_.feePayer)!==null&&R!==void 0?R:this.wallet.publicKey,_.recentBlockhash=o,I.forEach(O=>{_.partialSign(O)}),_}});const l=await this.wallet.signAllTransactions(a),p=[];for(let m=0;m<a.length;m+=1){const S=l[m],R=S.serialize();try{p.push(await Qc(this.connection,R,e))}catch(_){if(_ instanceof mo){const I=go(kr(S)?((r=S.signatures)===null||r===void 0?void 0:r[0])||new Uint8Array:(s=S.signature)!==null&&s!==void 0?s:new Uint8Array),O=kr(S)?0:void 0,x=await this.connection.getTransaction(I,{commitment:"confirmed",maxSupportedTransactionVersion:O});if(x){const M=(i=x.meta)===null||i===void 0?void 0:i.logMessages;throw M?new Ar(_.message,M):_}else throw _}else throw _}}return p}async simulate(t,e,r,s){let i=(await this.connection.getLatestBlockhash(r??this.connection.commitment)).blockhash,o;if(kr(t)?(e&&e.length>0&&(t.sign(e),t=await this.wallet.signTransaction(t)),o=await this.connection.simulateTransaction(t,{commitment:r})):(t.feePayer=t.feePayer||this.wallet.publicKey,t.recentBlockhash=i,e&&e.length>0&&(t=await this.wallet.signTransaction(t)),o=await zl(this.connection,t,e,r,s)),o.value.err)throw new Gw(o.value);return o.value}}class Gw extends Error{constructor(t,e){super(e),this.simulationResponse=t}}async function Qc(n,t,e){const r=e?{skipPreflight:e.skipPreflight,preflightCommitment:e.preflightCommitment||e.commitment,maxRetries:e.maxRetries,minContextSlot:e.minContextSlot}:{};let s;const i=Date.now();for(;Date.now()-i<6e4;)try{const o=await n.sendRawTransaction(t,r);if(e?.blockhash)if(r.maxRetries===0){const a=AbortSignal.timeout(15e3);s=(await n.confirmTransaction({abortSignal:a,signature:o,...e.blockhash},e&&e.commitment)).value}else s=(await n.confirmTransaction({signature:o,...e.blockhash},e&&e.commitment)).value;else s=(await n.confirmTransaction(o,e&&e.commitment)).value;if(s.err)throw new mo(`Raw transaction ${o} failed (${JSON.stringify(s)})`);return o}catch(o){if(o.name==="TimeoutError")continue;throw o}throw Error("Transaction failed to confirm in 60s")}class mo extends Error{constructor(t){super(t)}}function Ii(){return Ai.local()}var jw=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof globalThis<"u"?globalThis:typeof self<"u"?self:{};function Yw(n){return n&&n.__esModule&&Object.prototype.hasOwnProperty.call(n,"default")?n.default:n}var j={};Object.defineProperty(j,"__esModule",{value:!0});var ql=j.ANCHOR_ERROR__REQUIRE_EQ_VIOLATED=Hh=j.ANCHOR_ERROR__REQUIRE_VIOLATED=Dh=j.ANCHOR_ERROR__CONSTRAINT_MINT_TRANSFER_HOOK_EXTENSION_PROGRAM_ID=Uh=j.ANCHOR_ERROR__CONSTRAINT_MINT_TRANSFER_HOOK_EXTENSION_AUTHORITY=Ph=j.ANCHOR_ERROR__CONSTRAINT_MINT_TRANSFER_HOOK_EXTENSION=Lh=j.ANCHOR_ERROR__CONSTRAINT_MINT_PERMANENT_DELEGATE_EXTENSION_DELEGATE=Mh=j.ANCHOR_ERROR__CONSTRAINT_MINT_PERMANENT_DELEGATE_EXTENSION=Bh=j.ANCHOR_ERROR__CONSTRAINT_MINT_CLOSE_AUTHORITY_EXTENSION_AUTHORITY=Ch=j.ANCHOR_ERROR__CONSTRAINT_MINT_CLOSE_AUTHORITY_EXTENSION=Nh=j.ANCHOR_ERROR__CONSTRAINT_MINT_METADATA_POINTER_EXTENSION_METADATA_ADDRESS=xh=j.ANCHOR_ERROR__CONSTRAINT_MINT_METADATA_POINTER_EXTENSION_AUTHORITY=Oh=j.ANCHOR_ERROR__CONSTRAINT_MINT_METADATA_POINTER_EXTENSION=Th=j.ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_MEMBER_POINTER_EXTENSION_MEMBER_ADDRESS=kh=j.ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_MEMBER_POINTER_EXTENSION_AUTHORITY=Sh=j.ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_MEMBER_POINTER_EXTENSION=Ih=j.ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_POINTER_EXTENSION_GROUP_ADDRESS=Ah=j.ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_POINTER_EXTENSION_AUTHORITY=vh=j.ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_POINTER_EXTENSION=Rh=j.ANCHOR_ERROR__CONSTRAINT_ASSOCIATED_TOKEN_TOKEN_PROGRAM=Eh=j.ANCHOR_ERROR__CONSTRAINT_MINT_TOKEN_PROGRAM=bh=j.ANCHOR_ERROR__CONSTRAINT_TOKEN_TOKEN_PROGRAM=_h=j.ANCHOR_ERROR__CONSTRAINT_ACCOUNT_IS_NONE=wh=j.ANCHOR_ERROR__CONSTRAINT_SPACE=mh=j.ANCHOR_ERROR__CONSTRAINT_MINT_DECIMALS=gh=j.ANCHOR_ERROR__CONSTRAINT_MINT_FREEZE_AUTHORITY=yh=j.ANCHOR_ERROR__CONSTRAINT_MINT_MINT_AUTHORITY=ph=j.ANCHOR_ERROR__CONSTRAINT_TOKEN_OWNER=dh=j.ANCHOR_ERROR__CONSTRAINT_TOKEN_MINT=fh=j.ANCHOR_ERROR__CONSTRAINT_ZERO=hh=j.ANCHOR_ERROR__CONSTRAINT_ADDRESS=lh=j.ANCHOR_ERROR__CONSTRAINT_CLOSE=uh=j.ANCHOR_ERROR__CONSTRAINT_ASSOCIATED_INIT=ch=j.ANCHOR_ERROR__CONSTRAINT_ASSOCIATED=ah=j.ANCHOR_ERROR__CONSTRAINT_STATE=oh=j.ANCHOR_ERROR__CONSTRAINT_EXECUTABLE=sh=j.ANCHOR_ERROR__CONSTRAINT_SEEDS=ih=j.ANCHOR_ERROR__CONSTRAINT_RENT_EXEMPT=nh=j.ANCHOR_ERROR__CONSTRAINT_OWNER=rh=j.ANCHOR_ERROR__CONSTRAINT_RAW=eh=j.ANCHOR_ERROR__CONSTRAINT_SIGNER=th=j.ANCHOR_ERROR__CONSTRAINT_HAS_ONE=Ql=j.ANCHOR_ERROR__CONSTRAINT_MUT=Jl=j.ANCHOR_ERROR__EVENT_INSTRUCTION_STUB=Xl=j.ANCHOR_ERROR__IDL_ACCOUNT_NOT_EMPTY=Zl=j.ANCHOR_ERROR__IDL_INSTRUCTION_INVALID_PROGRAM=Yl=j.ANCHOR_ERROR__IDL_INSTRUCTION_STUB=jl=j.ANCHOR_ERROR__INSTRUCTION_DID_NOT_SERIALIZE=Gl=j.ANCHOR_ERROR__INSTRUCTION_DID_NOT_DESERIALIZE=Wl=j.ANCHOR_ERROR__INSTRUCTION_FALLBACK_NOT_FOUND=Vl=j.ANCHOR_ERROR__INSTRUCTION_MISSING=void 0,$l=j.ANCHOR_ERROR__DEPRECATED=ff=j.ANCHOR_ERROR__INVALID_NUMERIC_CONVERSION=hf=j.ANCHOR_ERROR__TRYING_TO_INIT_PAYER_AS_PROGRAM_ACCOUNT=lf=j.ANCHOR_ERROR__DECLARED_PROGRAM_ID_MISMATCH=uf=j.ANCHOR_ERROR__ACCOUNT_DUPLICATE_REALLOCS=cf=j.ANCHOR_ERROR__ACCOUNT_REALLOC_EXCEEDS_LIMIT=af=j.ANCHOR_ERROR__ACCOUNT_SYSVAR_MISMATCH=of=j.ANCHOR_ERROR__ACCOUNT_NOT_ASSOCIATED_TOKEN_ACCOUNT=sf=j.ANCHOR_ERROR__ACCOUNT_NOT_PROGRAM_DATA=nf=j.ANCHOR_ERROR__ACCOUNT_NOT_INITIALIZED=rf=j.ANCHOR_ERROR__ACCOUNT_NOT_SYSTEM_OWNED=ef=j.ANCHOR_ERROR__ACCOUNT_NOT_SIGNER=tf=j.ANCHOR_ERROR__INVALID_PROGRAM_EXECUTABLE=Qh=j.ANCHOR_ERROR__INVALID_PROGRAM_ID=Jh=j.ANCHOR_ERROR__ACCOUNT_OWNED_BY_WRONG_PROGRAM=Xh=j.ANCHOR_ERROR__ACCOUNT_NOT_MUTABLE=Zh=j.ANCHOR_ERROR__ACCOUNT_NOT_ENOUGH_KEYS=Yh=j.ANCHOR_ERROR__ACCOUNT_DID_NOT_SERIALIZE=jh=j.ANCHOR_ERROR__ACCOUNT_DID_NOT_DESERIALIZE=Gh=j.ANCHOR_ERROR__ACCOUNT_DISCRIMINATOR_MISMATCH=Wh=j.ANCHOR_ERROR__ACCOUNT_DISCRIMINATOR_NOT_FOUND=Vh=j.ANCHOR_ERROR__ACCOUNT_DISCRIMINATOR_ALREADY_SET=$h=j.ANCHOR_ERROR__REQUIRE_GTE_VIOLATED=qh=j.ANCHOR_ERROR__REQUIRE_GT_VIOLATED=Kh=j.ANCHOR_ERROR__REQUIRE_KEYS_NEQ_VIOLATED=zh=j.ANCHOR_ERROR__REQUIRE_NEQ_VIOLATED=Fh=j.ANCHOR_ERROR__REQUIRE_KEYS_EQ_VIOLATED=void 0,Vl=j.ANCHOR_ERROR__INSTRUCTION_MISSING=100,Wl=j.ANCHOR_ERROR__INSTRUCTION_FALLBACK_NOT_FOUND=101,Gl=j.ANCHOR_ERROR__INSTRUCTION_DID_NOT_DESERIALIZE=102,jl=j.ANCHOR_ERROR__INSTRUCTION_DID_NOT_SERIALIZE=103,Yl=j.ANCHOR_ERROR__IDL_INSTRUCTION_STUB=1e3,Zl=j.ANCHOR_ERROR__IDL_INSTRUCTION_INVALID_PROGRAM=1001,Xl=j.ANCHOR_ERROR__IDL_ACCOUNT_NOT_EMPTY=1002,Jl=j.ANCHOR_ERROR__EVENT_INSTRUCTION_STUB=1500,Ql=j.ANCHOR_ERROR__CONSTRAINT_MUT=2e3,th=j.ANCHOR_ERROR__CONSTRAINT_HAS_ONE=2001,eh=j.ANCHOR_ERROR__CONSTRAINT_SIGNER=2002,rh=j.ANCHOR_ERROR__CONSTRAINT_RAW=2003,nh=j.ANCHOR_ERROR__CONSTRAINT_OWNER=2004,ih=j.ANCHOR_ERROR__CONSTRAINT_RENT_EXEMPT=2005,sh=j.ANCHOR_ERROR__CONSTRAINT_SEEDS=2006,oh=j.ANCHOR_ERROR__CONSTRAINT_EXECUTABLE=2007,ah=j.ANCHOR_ERROR__CONSTRAINT_STATE=2008,ch=j.ANCHOR_ERROR__CONSTRAINT_ASSOCIATED=2009,uh=j.ANCHOR_ERROR__CONSTRAINT_ASSOCIATED_INIT=2010,lh=j.ANCHOR_ERROR__CONSTRAINT_CLOSE=2011,hh=j.ANCHOR_ERROR__CONSTRAINT_ADDRESS=2012,fh=j.ANCHOR_ERROR__CONSTRAINT_ZERO=2013,dh=j.ANCHOR_ERROR__CONSTRAINT_TOKEN_MINT=2014,ph=j.ANCHOR_ERROR__CONSTRAINT_TOKEN_OWNER=2015,yh=j.ANCHOR_ERROR__CONSTRAINT_MINT_MINT_AUTHORITY=2016,gh=j.ANCHOR_ERROR__CONSTRAINT_MINT_FREEZE_AUTHORITY=2017,mh=j.ANCHOR_ERROR__CONSTRAINT_MINT_DECIMALS=2018,wh=j.ANCHOR_ERROR__CONSTRAINT_SPACE=2019,_h=j.ANCHOR_ERROR__CONSTRAINT_ACCOUNT_IS_NONE=2020,bh=j.ANCHOR_ERROR__CONSTRAINT_TOKEN_TOKEN_PROGRAM=2021,Eh=j.ANCHOR_ERROR__CONSTRAINT_MINT_TOKEN_PROGRAM=2022,Rh=j.ANCHOR_ERROR__CONSTRAINT_ASSOCIATED_TOKEN_TOKEN_PROGRAM=2023,vh=j.ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_POINTER_EXTENSION=2024,Ah=j.ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_POINTER_EXTENSION_AUTHORITY=2025,Ih=j.ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_POINTER_EXTENSION_GROUP_ADDRESS=2026,Sh=j.ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_MEMBER_POINTER_EXTENSION=2027,kh=j.ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_MEMBER_POINTER_EXTENSION_AUTHORITY=2028,Th=j.ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_MEMBER_POINTER_EXTENSION_MEMBER_ADDRESS=2029,Oh=j.ANCHOR_ERROR__CONSTRAINT_MINT_METADATA_POINTER_EXTENSION=2030,xh=j.ANCHOR_ERROR__CONSTRAINT_MINT_METADATA_POINTER_EXTENSION_AUTHORITY=2031,Nh=j.ANCHOR_ERROR__CONSTRAINT_MINT_METADATA_POINTER_EXTENSION_METADATA_ADDRESS=2032,Ch=j.ANCHOR_ERROR__CONSTRAINT_MINT_CLOSE_AUTHORITY_EXTENSION=2033,Bh=j.ANCHOR_ERROR__CONSTRAINT_MINT_CLOSE_AUTHORITY_EXTENSION_AUTHORITY=2034,Mh=j.ANCHOR_ERROR__CONSTRAINT_MINT_PERMANENT_DELEGATE_EXTENSION=2035,Lh=j.ANCHOR_ERROR__CONSTRAINT_MINT_PERMANENT_DELEGATE_EXTENSION_DELEGATE=2036,Ph=j.ANCHOR_ERROR__CONSTRAINT_MINT_TRANSFER_HOOK_EXTENSION=2037,Uh=j.ANCHOR_ERROR__CONSTRAINT_MINT_TRANSFER_HOOK_EXTENSION_AUTHORITY=2038,Dh=j.ANCHOR_ERROR__CONSTRAINT_MINT_TRANSFER_HOOK_EXTENSION_PROGRAM_ID=2039,Hh=j.ANCHOR_ERROR__REQUIRE_VIOLATED=2500;ql=j.ANCHOR_ERROR__REQUIRE_EQ_VIOLATED=2501;var Fh=j.ANCHOR_ERROR__REQUIRE_KEYS_EQ_VIOLATED=2502,zh=j.ANCHOR_ERROR__REQUIRE_NEQ_VIOLATED=2503,Kh=j.ANCHOR_ERROR__REQUIRE_KEYS_NEQ_VIOLATED=2504,qh=j.ANCHOR_ERROR__REQUIRE_GT_VIOLATED=2505,$h=j.ANCHOR_ERROR__REQUIRE_GTE_VIOLATED=2506,Vh=j.ANCHOR_ERROR__ACCOUNT_DISCRIMINATOR_ALREADY_SET=3e3,Wh=j.ANCHOR_ERROR__ACCOUNT_DISCRIMINATOR_NOT_FOUND=3001,Gh=j.ANCHOR_ERROR__ACCOUNT_DISCRIMINATOR_MISMATCH=3002,jh=j.ANCHOR_ERROR__ACCOUNT_DID_NOT_DESERIALIZE=3003,Yh=j.ANCHOR_ERROR__ACCOUNT_DID_NOT_SERIALIZE=3004,Zh=j.ANCHOR_ERROR__ACCOUNT_NOT_ENOUGH_KEYS=3005,Xh=j.ANCHOR_ERROR__ACCOUNT_NOT_MUTABLE=3006,Jh=j.ANCHOR_ERROR__ACCOUNT_OWNED_BY_WRONG_PROGRAM=3007,Qh=j.ANCHOR_ERROR__INVALID_PROGRAM_ID=3008,tf=j.ANCHOR_ERROR__INVALID_PROGRAM_EXECUTABLE=3009,ef=j.ANCHOR_ERROR__ACCOUNT_NOT_SIGNER=3010,rf=j.ANCHOR_ERROR__ACCOUNT_NOT_SYSTEM_OWNED=3011,nf=j.ANCHOR_ERROR__ACCOUNT_NOT_INITIALIZED=3012,sf=j.ANCHOR_ERROR__ACCOUNT_NOT_PROGRAM_DATA=3013,of=j.ANCHOR_ERROR__ACCOUNT_NOT_ASSOCIATED_TOKEN_ACCOUNT=3014,af=j.ANCHOR_ERROR__ACCOUNT_SYSVAR_MISMATCH=3015,cf=j.ANCHOR_ERROR__ACCOUNT_REALLOC_EXCEEDS_LIMIT=3016,uf=j.ANCHOR_ERROR__ACCOUNT_DUPLICATE_REALLOCS=3017,lf=j.ANCHOR_ERROR__DECLARED_PROGRAM_ID_MISMATCH=4100,hf=j.ANCHOR_ERROR__TRYING_TO_INIT_PAYER_AS_PROGRAM_ACCOUNT=4101,ff=j.ANCHOR_ERROR__INVALID_NUMERIC_CONVERSION=4102;$l=j.ANCHOR_ERROR__DEPRECATED=5e3;const Zw=new Set(["debug-logs"]),df=new Map;function Xw(n){if(!Zw.has(n))throw new Error("Invalid feature");df.set(n,!0)}function ia(n){return df.get(n)!==void 0}var Jw=Object.freeze({__proto__:null,set:Xw,isSet:ia});class wr extends Error{constructor(t){super(t),this.name="IdlError"}}class zn{constructor(t){this.stack=t}static parse(t){var e;const r=/^Program (\w*) invoke/,s=/^Program \w* success/,i=[];for(let o=0;o<t.length;o++){if(s.exec(t[o])){i.pop();continue}const a=(e=r.exec(t[o]))===null||e===void 0?void 0:e[1];a&&i.push(new rt(a))}return new zn(i)}}class vn extends Error{constructor(t,e,r,s,i,o){super(r.join(`
`).replace("Program log: ","")),this.errorLogs=r,this.logs=s,this.error={errorCode:t,errorMessage:e,comparedValues:o,origin:i},this._programErrorStack=zn.parse(s)}static parse(t){if(!t)return null;const e=t.findIndex(R=>R.startsWith("Program log: AnchorError"));if(e===-1)return null;const r=t[e],s=[r];let i;if(e+1<t.length){if(t[e+1]==="Program log: Left:"){const R=/^Program log: (.*)$/,_=R.exec(t[e+2])[1],I=R.exec(t[e+4])[1];i=[new rt(_),new rt(I)],s.push(...t.slice(e+1,e+5))}else if(t[e+1].startsWith("Program log: Left:")){const R=/^Program log: (Left|Right): (.*)$/,_=R.exec(t[e+1])[2],I=R.exec(t[e+2])[2];s.push(...t.slice(e+1,e+3)),i=[_,I]}}const a=/^Program log: AnchorError occurred\. Error Code: (.*)\. Error Number: (\d*)\. Error Message: (.*)\./.exec(r),p=/^Program log: AnchorError thrown in (.*):(\d*)\. Error Code: (.*)\. Error Number: (\d*)\. Error Message: (.*)\./.exec(r),S=/^Program log: AnchorError caused by account: (.*)\. Error Code: (.*)\. Error Number: (\d*)\. Error Message: (.*)\./.exec(r);if(a){const[R,_,I]=a.slice(1,4),O={code:R,number:parseInt(_)};return new vn(O,I,s,t,void 0,i)}else if(p){const[R,_,I,O,x]=p.slice(1,6),M={code:I,number:parseInt(O)},H={file:R,line:parseInt(_)};return new vn(M,x,s,t,H,i)}else if(S){const[R,_,I,O]=S.slice(1,5),x=R,M={code:_,number:parseInt(I)};return new vn(M,O,s,t,x,i)}else return null}get program(){return this._programErrorStack.stack[this._programErrorStack.stack.length-1]}get programErrorStack(){return this._programErrorStack.stack}toString(){return this.message}}class Si extends Error{constructor(t,e,r){super(),this.code=t,this.msg=e,this.logs=r,r&&(this._programErrorStack=zn.parse(r))}static parse(t,e){const r=t.toString();let s;if(r.includes("custom program error:")){let a=r.split("custom program error: ");if(a.length!==2)return null;s=a[1]}else{const a=r.match(/"Custom":([0-9]+)}/g);if(!a||a.length>1)return null;s=a[0].match(/([0-9]+)/g)[0]}let i;try{i=parseInt(s)}catch{return null}let o=e.get(i);return o!==void 0?new Si(i,o,t.logs):(o=Qw.get(i),o!==void 0?new Si(i,o,t.logs):null)}get program(){var t;return(t=this._programErrorStack)===null||t===void 0?void 0:t.stack[this._programErrorStack.stack.length-1]}get programErrorStack(){var t;return(t=this._programErrorStack)===null||t===void 0?void 0:t.stack}toString(){return this.msg}}function pf(n,t){ia("debug-logs")&&console.log("Translating error:",n);const e=vn.parse(n.logs);if(e)return e;const r=Si.parse(n,t);if(r)return r;if(n.logs){const s={get:function(i,o){return o==="programErrorStack"?i.programErrorStack.stack:o==="program"?i.programErrorStack.stack[n.programErrorStack.stack.length-1]:Reflect.get(...arguments)}};return n.programErrorStack=zn.parse(n.logs),new Proxy(n,s)}return n}const ot={InstructionMissing:Vl,InstructionFallbackNotFound:Wl,InstructionDidNotDeserialize:Gl,InstructionDidNotSerialize:jl,IdlInstructionStub:Yl,IdlInstructionInvalidProgram:Zl,IdlAccountNotEmpty:Xl,EventInstructionStub:Jl,ConstraintMut:Ql,ConstraintHasOne:th,ConstraintSigner:eh,ConstraintRaw:rh,ConstraintOwner:nh,ConstraintRentExempt:ih,ConstraintSeeds:sh,ConstraintExecutable:oh,ConstraintState:ah,ConstraintAssociated:ch,ConstraintAssociatedInit:uh,ConstraintClose:lh,ConstraintAddress:hh,ConstraintZero:fh,ConstraintTokenMint:dh,ConstraintTokenOwner:ph,ConstraintMintMintAuthority:yh,ConstraintMintFreezeAuthority:gh,ConstraintMintDecimals:mh,ConstraintSpace:wh,ConstraintAccountIsNone:_h,ConstraintTokenTokenProgram:bh,ConstraintMintTokenProgram:Eh,ConstraintAssociatedTokenTokenProgram:Rh,ConstraintMintGroupPointerExtension:vh,ConstraintMintGroupPointerExtensionAuthority:Ah,ConstraintMintGroupPointerExtensionGroupAddress:Ih,ConstraintMintGroupMemberPointerExtension:Sh,ConstraintMintGroupMemberPointerExtensionAuthority:kh,ConstraintMintGroupMemberPointerExtensionMemberAddress:Th,ConstraintMintMetadataPointerExtension:Oh,ConstraintMintMetadataPointerExtensionAuthority:xh,ConstraintMintMetadataPointerExtensionMetadataAddress:Nh,ConstraintMintCloseAuthorityExtension:Ch,ConstraintMintCloseAuthorityExtensionAuthority:Bh,ConstraintMintPermanentDelegateExtension:Mh,ConstraintMintPermanentDelegateExtensionDelegate:Lh,ConstraintMintTransferHookExtension:Ph,ConstraintMintTransferHookExtensionAuthority:Uh,ConstraintMintTransferHookExtensionProgramId:Dh,RequireViolated:Hh,RequireEqViolated:ql,RequireKeysEqViolated:Fh,RequireNeqViolated:zh,RequireKeysNeqViolated:Kh,RequireGtViolated:qh,RequireGteViolated:$h,AccountDiscriminatorAlreadySet:Vh,AccountDiscriminatorNotFound:Wh,AccountDiscriminatorMismatch:Gh,AccountDidNotDeserialize:jh,AccountDidNotSerialize:Yh,AccountNotEnoughKeys:Zh,AccountNotMutable:Xh,AccountOwnedByWrongProgram:Jh,InvalidProgramId:Qh,InvalidProgramExecutable:tf,AccountNotSigner:ef,AccountNotSystemOwned:rf,AccountNotInitialized:nf,AccountNotProgramData:sf,AccountNotAssociatedTokenAccount:of,AccountSysvarMismatch:af,AccountReallocExceedsLimit:cf,AccountDuplicateReallocs:uf,DeclaredProgramIdMismatch:lf,TryingToInitPayerAsProgramAccount:hf,InvalidNumericConversion:ff,Deprecated:$l},Qw=new Map([[ot.InstructionMissing,"Instruction discriminator not provided"],[ot.InstructionFallbackNotFound,"Fallback functions are not supported"],[ot.InstructionDidNotDeserialize,"The program could not deserialize the given instruction"],[ot.InstructionDidNotSerialize,"The program could not serialize the given instruction"],[ot.IdlInstructionStub,"The program was compiled without idl instructions"],[ot.IdlInstructionInvalidProgram,"The transaction was given an invalid program for the IDL instruction"],[ot.IdlAccountNotEmpty,"IDL account must be empty in order to resize, try closing first"],[ot.EventInstructionStub,"The program was compiled without `event-cpi` feature"],[ot.ConstraintMut,"A mut constraint was violated"],[ot.ConstraintHasOne,"A has one constraint was violated"],[ot.ConstraintSigner,"A signer constraint was violated"],[ot.ConstraintRaw,"A raw constraint was violated"],[ot.ConstraintOwner,"An owner constraint was violated"],[ot.ConstraintRentExempt,"A rent exemption constraint was violated"],[ot.ConstraintSeeds,"A seeds constraint was violated"],[ot.ConstraintExecutable,"An executable constraint was violated"],[ot.ConstraintState,"Deprecated Error, feel free to replace with something else"],[ot.ConstraintAssociated,"An associated constraint was violated"],[ot.ConstraintAssociatedInit,"An associated init constraint was violated"],[ot.ConstraintClose,"A close constraint was violated"],[ot.ConstraintAddress,"An address constraint was violated"],[ot.ConstraintZero,"Expected zero account discriminant"],[ot.ConstraintTokenMint,"A token mint constraint was violated"],[ot.ConstraintTokenOwner,"A token owner constraint was violated"],[ot.ConstraintMintMintAuthority,"A mint mint authority constraint was violated"],[ot.ConstraintMintFreezeAuthority,"A mint freeze authority constraint was violated"],[ot.ConstraintMintDecimals,"A mint decimals constraint was violated"],[ot.ConstraintSpace,"A space constraint was violated"],[ot.ConstraintAccountIsNone,"A required account for the constraint is None"],[ot.ConstraintTokenTokenProgram,"A token account token program constraint was violated"],[ot.ConstraintMintTokenProgram,"A mint token program constraint was violated"],[ot.ConstraintAssociatedTokenTokenProgram,"An associated token account token program constraint was violated"],[ot.ConstraintMintGroupPointerExtension,"A group pointer extension constraint was violated"],[ot.ConstraintMintGroupPointerExtensionAuthority,"A group pointer extension authority constraint was violated"],[ot.ConstraintMintGroupPointerExtensionGroupAddress,"A group pointer extension group address constraint was violated"],[ot.ConstraintMintGroupMemberPointerExtension,"A group member pointer extension constraint was violated"],[ot.ConstraintMintGroupMemberPointerExtensionAuthority,"A group member pointer extension authority constraint was violated"],[ot.ConstraintMintGroupMemberPointerExtensionMemberAddress,"A group member pointer extension group address constraint was violated"],[ot.ConstraintMintMetadataPointerExtension,"A metadata pointer extension constraint was violated"],[ot.ConstraintMintMetadataPointerExtensionAuthority,"A metadata pointer extension authority constraint was violated"],[ot.ConstraintMintMetadataPointerExtensionMetadataAddress,"A metadata pointer extension metadata address constraint was violated"],[ot.ConstraintMintCloseAuthorityExtension,"A close authority constraint was violated"],[ot.ConstraintMintCloseAuthorityExtensionAuthority,"A close authority extension authority constraint was violated"],[ot.ConstraintMintPermanentDelegateExtension,"A permanent delegate extension constraint was violated"],[ot.ConstraintMintPermanentDelegateExtensionDelegate,"A permanent delegate extension delegate constraint was violated"],[ot.ConstraintMintTransferHookExtension,"A transfer hook extension constraint was violated"],[ot.ConstraintMintTransferHookExtensionAuthority,"A transfer hook extension authority constraint was violated"],[ot.ConstraintMintTransferHookExtensionProgramId,"A transfer hook extension transfer hook program id constraint was violated"],[ot.RequireViolated,"A require expression was violated"],[ot.RequireEqViolated,"A require_eq expression was violated"],[ot.RequireKeysEqViolated,"A require_keys_eq expression was violated"],[ot.RequireNeqViolated,"A require_neq expression was violated"],[ot.RequireKeysNeqViolated,"A require_keys_neq expression was violated"],[ot.RequireGtViolated,"A require_gt expression was violated"],[ot.RequireGteViolated,"A require_gte expression was violated"],[ot.AccountDiscriminatorAlreadySet,"The account discriminator was already set on this account"],[ot.AccountDiscriminatorNotFound,"No discriminator was found on the account"],[ot.AccountDiscriminatorMismatch,"Account discriminator did not match what was expected"],[ot.AccountDidNotDeserialize,"Failed to deserialize the account"],[ot.AccountDidNotSerialize,"Failed to serialize the account"],[ot.AccountNotEnoughKeys,"Not enough account keys given to the instruction"],[ot.AccountNotMutable,"The given account is not mutable"],[ot.AccountOwnedByWrongProgram,"The given account is owned by a different program than expected"],[ot.InvalidProgramId,"Program ID was not as expected"],[ot.InvalidProgramExecutable,"Program account is not executable"],[ot.AccountNotSigner,"The given account did not sign"],[ot.AccountNotSystemOwned,"The given account is not owned by the system program"],[ot.AccountNotInitialized,"The program expected this account to be already initialized"],[ot.AccountNotProgramData,"The given account is not a program data account"],[ot.AccountNotAssociatedTokenAccount,"The given account is not the associated token account"],[ot.AccountSysvarMismatch,"The given public key does not match the required sysvar"],[ot.AccountReallocExceedsLimit,"The account reallocation exceeds the MAX_PERMITTED_DATA_INCREASE limit"],[ot.AccountDuplicateReallocs,"The account was duplicated for more than one reallocation"],[ot.DeclaredProgramIdMismatch,"The declared program id does not match the actual program id"],[ot.TryingToInitPayerAsProgramAccount,"You cannot/should not initialize the payer account as a program account"],[ot.InvalidNumericConversion,"The program could not perform the numeric conversion, out of range integral type conversion attempted"],[ot.Deprecated,"The API being used is deprecated and should no longer be used"]]);class Rt{static fieldLayout(t,e=[],r){const s=t.name;switch(t.type){case"bool":return mt.bool(s);case"u8":return mt.u8(s);case"i8":return mt.i8(s);case"u16":return mt.u16(s);case"i16":return mt.i16(s);case"u32":return mt.u32(s);case"i32":return mt.i32(s);case"f32":return mt.f32(s);case"u64":return mt.u64(s);case"i64":return mt.i64(s);case"f64":return mt.f64(s);case"u128":return mt.u128(s);case"i128":return mt.i128(s);case"u256":return mt.u256(s);case"i256":return mt.i256(s);case"bytes":return mt.vecU8(s);case"string":return mt.str(s);case"pubkey":return mt.publicKey(s);default:{if("option"in t.type)return mt.option(Rt.fieldLayout({type:t.type.option},e,r),s);if("vec"in t.type)return mt.vec(Rt.fieldLayout({type:t.type.vec},e,r),s);if("array"in t.type){let[i,o]=t.type.array;return o=Rt.resolveArrayLen(o,r),mt.array(Rt.fieldLayout({type:i},e,r),o,s)}if("defined"in t.type){if(!e)throw new wr("User defined types not provided");const i=t.type.defined.name,o=e.find(a=>a.name===i);if(!o)throw new wr(`Type not found: ${t.name}`);return Rt.typeDefLayout({typeDef:o,types:e,genericArgs:r??t.type.defined.generics,name:s})}if("generic"in t.type){const i=r?.at(0);if(i?.kind!=="type")throw new wr(`Invalid generic field: ${t.name}`);return Rt.fieldLayout({...t,type:i.type},e)}throw new wr(`Not yet implemented: ${JSON.stringify(t.type)}`)}}}static typeDefLayout({typeDef:t,types:e,name:r,genericArgs:s}){switch(t.type.kind){case"struct":{const i=Qr(t.type.fields,()=>[],o=>o.map(a=>{const l=s&&Rt.resolveGenericArgs({type:a.type,typeDef:t,genericArgs:s});return Rt.fieldLayout(a,e,l)}),o=>o.map((a,l)=>{const p=s&&Rt.resolveGenericArgs({type:a,typeDef:t,genericArgs:s});return Rt.fieldLayout({name:l.toString(),type:a},e,p)}));return mt.struct(i,r)}case"enum":{const i=t.type.variants.map(o=>{const a=Qr(o.fields,()=>[],l=>l.map(p=>{const m=s&&Rt.resolveGenericArgs({type:p.type,typeDef:t,genericArgs:s});return Rt.fieldLayout(p,e,m)}),l=>l.map((p,m)=>{const S=s&&Rt.resolveGenericArgs({type:p,typeDef:t,genericArgs:s});return Rt.fieldLayout({name:m.toString(),type:p},e,S)}));return mt.struct(a,o.name)});return r!==void 0?mt.rustEnum(i).replicate(r):mt.rustEnum(i,r)}case"type":return Rt.fieldLayout({type:t.type.alias,name:r},e)}}static typeSize(t,e,r){var s;switch(t){case"bool":return 1;case"u8":return 1;case"i8":return 1;case"i16":return 2;case"u16":return 2;case"u32":return 4;case"i32":return 4;case"f32":return 4;case"u64":return 8;case"i64":return 8;case"f64":return 8;case"u128":return 16;case"i128":return 16;case"u256":return 32;case"i256":return 32;case"bytes":return 1;case"string":return 1;case"pubkey":return 32;default:if("option"in t)return 1+Rt.typeSize(t.option,e,r);if("coption"in t)return 4+Rt.typeSize(t.coption,e,r);if("vec"in t)return 1;if("array"in t){let[i,o]=t.array;return o=Rt.resolveArrayLen(o,r),Rt.typeSize(i,e,r)*o}if("defined"in t){const i=(s=e.types)===null||s===void 0?void 0:s.find(a=>a.name===t.defined.name);if(!i)throw new wr(`Type not found: ${JSON.stringify(t)}`);const o=a=>{const l=r??t.defined.generics,p=l&&Rt.resolveGenericArgs({type:a,typeDef:i,genericArgs:l});return Rt.typeSize(a,e,p)};switch(i.type.kind){case"struct":return Qr(i.type.fields,()=>[0],a=>a.map(l=>o(l.type)),a=>a.map(l=>o(l))).reduce((a,l)=>a+l,0);case"enum":{const a=i.type.variants.map(l=>Qr(l.fields,()=>[0],p=>p.map(m=>o(m.type)),p=>p.map(m=>o(m))).reduce((p,m)=>p+m,0));return Math.max(...a)+1}case"type":return Rt.typeSize(i.type.alias,e,r)}}if("generic"in t){const i=r?.at(0);if(i?.kind!=="type")throw new wr(`Invalid generic: ${t.generic}`);return Rt.typeSize(i.type,e,r)}throw new Error(`Invalid type ${JSON.stringify(t)}`)}}static resolveArrayLen(t,e){if(typeof t=="number")return t;if(e){const r=e.find(s=>s.kind==="const");r?.kind==="const"&&(t=+r.value)}if(typeof t!="number")throw new wr("Generic array length did not resolve");return t}static resolveGenericArgs({type:t,typeDef:e,genericArgs:r,isDefined:s}){if(typeof t!="object")return null;for(const i in e.generics){const o=e.generics[i];if("generic"in t&&o.name===t.generic)return[r[i]];if("option"in t){const a=Rt.resolveGenericArgs({type:t.option,typeDef:e,genericArgs:r,isDefined:s});if(!a||!s)return a;if(a[0].kind==="type")return[{kind:"type",type:{option:a[0].type}}]}if("vec"in t){const a=Rt.resolveGenericArgs({type:t.vec,typeDef:e,genericArgs:r,isDefined:s});if(!a||!s)return a;if(a[0].kind==="type")return[{kind:"type",type:{vec:a[0].type}}]}if("array"in t){const[a,l]=t.array,p=typeof l=="object",m=Rt.resolveGenericArgs({type:a,typeDef:e,genericArgs:r,isDefined:s})||[];if(p){const S=e.generics.findIndex(R=>R.name===l.generic);S!==-1&&m.push(r[S])}if(m.length>0){if(!s)return m;if(m[0].kind==="type"&&m[1].kind==="const")return[{kind:"type",type:{array:[m[0].type,+m[1].value]}}]}if(p&&o.name===l.generic){const S=r[i];return s?[{kind:"type",type:{array:[a,+S.value]}}]:[S]}return null}if("defined"in t)return t.defined.generics?t.defined.generics.flatMap(a=>{switch(a.kind){case"type":return Rt.resolveGenericArgs({type:a.type,typeDef:e,genericArgs:r,isDefined:!0});case"const":return[a]}}).filter(a=>a!==null):null}return null}}class t_{constructor(t){this.idl=t;const e=t.instructions.map(r=>{const s=r.name,i=r.args.map(a=>Rt.fieldLayout(a,t.types)),o=mt.struct(i,s);return[s,{discriminator:r.discriminator,layout:o}]});this.ixLayouts=new Map(e)}encode(t,e){const r=ht.Buffer.alloc(1e3),s=this.ixLayouts.get(t);if(!s)throw new Error(`Unknown method: ${t}`);const i=s.layout.encode(e,r),o=r.slice(0,i);return ht.Buffer.concat([ht.Buffer.from(s.discriminator),o])}decode(t,e="hex"){typeof t=="string"&&(t=e==="hex"?ht.Buffer.from(t,"hex"):Ki.decode(t));for(const[r,s]of this.ixLayouts){const i=t.subarray(0,s.discriminator.length);if(i.equals(ht.Buffer.from(s.discriminator)))return{name:r,data:s.layout.decode(t.subarray(i.length))}}return null}format(t,e){return Be.format(t,e,this.idl)}}class Be{static format(t,e,r){const s=r.instructions.find(l=>t.name===l.name);if(!s)return console.error("Invalid instruction given"),null;const i=s.args.map(l=>({name:l.name,type:Be.formatIdlType(l.type),data:Be.formatIdlData(l,t.data[l.name],r.types)})),o=Be.flattenIdlAccounts(s.accounts),a=e.map((l,p)=>p<o.length?{name:o[p].name,...l}:{name:void 0,...l});return{args:i,accounts:a}}static formatIdlType(t){if(typeof t=="string")return t;if("option"in t)return`Option<${this.formatIdlType(t.option)}>`;if("coption"in t)return`COption<${this.formatIdlType(t.coption)}>`;if("vec"in t)return`Vec<${this.formatIdlType(t.vec)}>`;if("array"in t)return`Array<${t.array[0]}; ${t.array[1]}>`;if("defined"in t){const e=t.defined.name;if(t.defined.generics){const r=t.defined.generics.map(s=>{switch(s.kind){case"type":return Be.formatIdlType(s.type);case"const":return s.value}}).join(", ");return`${e}<${r}>`}return e}throw new Error(`Unknown IDL type: ${t}`)}static formatIdlData(t,e,r){if(typeof t.type=="string")return e.toString();if("vec"in t.type)return"["+e.map(s=>this.formatIdlData({name:"",type:t.type.vec},s,r)).join(", ")+"]";if("option"in t.type)return e===null?"null":this.formatIdlData({name:"",type:t.type.option},e,r);if("defined"in t.type){if(!r)throw new Error("User defined types not provided");const s=t.type.defined.name,i=r.find(o=>o.name===s);if(!i)throw new Error(`Type not found: ${s}`);return Be.formatIdlDataDefined(i,e,r)}return"unknown"}static formatIdlDataDefined(t,e,r){switch(t.type.kind){case"struct":return"{ "+Qr(t.type.fields,()=>"",s=>Object.entries(e).map(([i,o])=>{const a=s.find(l=>l.name===i);if(!a)throw new Error(`Field not found: ${i}`);return i+": "+Be.formatIdlData(a,o,r)}).join(", "),s=>Object.entries(e).map(([i,o])=>i+": "+Be.formatIdlData({name:"",type:s[i]},o,r)).join(", "))+" }";case"enum":{const s=Object.keys(e)[0],i=t.type.variants.find(a=>a.name===s);if(!i)throw new Error(`Unable to find variant: ${s}`);const o=e[s];return Qr(i.fields,()=>s,a=>{const l=Object.keys(o).map(p=>{const m=o[p],S=a.find(R=>R.name===p);if(!S)throw new Error(`Field not found: ${p}`);return p+": "+Be.formatIdlData(S,m,r)}).join(", ");return`${s} { ${l} }`},a=>{const l=Object.entries(o).map(([p,m])=>p+": "+Be.formatIdlData({name:"",type:a[p]},m,r)).join(", ");return`${s} { ${l} }`})}case"type":return Be.formatIdlType(t.type.alias)}}static flattenIdlAccounts(t,e){return t.map(r=>{const s=e_(r.name);if(r.hasOwnProperty("accounts")){const i=e?`${e} > ${s}`:s;return Be.flattenIdlAccounts(r.accounts,i)}else return{...r,name:e?`${e} > ${s}`:s}}).flat()}}function e_(n){const t=n.replace(/([A-Z])/g," $1");return t.charAt(0).toUpperCase()+t.slice(1)}class r_{constructor(t){if(this.idl=t,!t.accounts){this.accountLayouts=new Map;return}const e=t.types;if(!e)throw new Error("Accounts require `idl.types`");const r=t.accounts.map(s=>{const i=e.find(o=>o.name===s.name);if(!i)throw new Error(`Account not found: ${s.name}`);return[s.name,{discriminator:s.discriminator,layout:Rt.typeDefLayout({typeDef:i,types:e})}]});this.accountLayouts=new Map(r)}async encode(t,e){const r=ht.Buffer.alloc(1e3),s=this.accountLayouts.get(t);if(!s)throw new Error(`Unknown account: ${t}`);const i=s.layout.encode(e,r),o=r.slice(0,i),a=this.accountDiscriminator(t);return ht.Buffer.concat([a,o])}decode(t,e){const r=this.accountDiscriminator(t);if(r.compare(e.slice(0,r.length)))throw new Error("Invalid account discriminator");return this.decodeUnchecked(t,e)}decodeAny(t){for(const[e,r]of this.accountLayouts)if(t.subarray(0,r.discriminator.length).equals(ht.Buffer.from(r.discriminator)))return this.decodeUnchecked(e,t);throw new Error("Account not found")}decodeUnchecked(t,e){const r=this.accountDiscriminator(t),s=e.subarray(r.length),i=this.accountLayouts.get(t);if(!i)throw new Error(`Unknown account: ${t}`);return i.layout.decode(s)}memcmp(t,e){const r=this.accountDiscriminator(t);return{offset:0,bytes:Ki.encode(e?ht.Buffer.concat([r,e]):r)}}size(t){return this.accountDiscriminator(t).length+Rt.typeSize({defined:{name:t}},this.idl)}accountDiscriminator(t){var e;const r=(e=this.idl.accounts)===null||e===void 0?void 0:e.find(s=>s.name===t);if(!r)throw new Error(`Account not found: ${t}`);return ht.Buffer.from(r.discriminator)}}class n_{constructor(t){if(!t.events){this.layouts=new Map;return}const e=t.types;if(!e)throw new Error("Events require `idl.types`");const r=t.events.map(s=>{const i=e.find(o=>o.name===s.name);if(!i)throw new Error(`Event not found: ${s.name}`);return[s.name,{discriminator:s.discriminator,layout:Rt.typeDefLayout({typeDef:i,types:e})}]});this.layouts=new Map(r)}decode(t){let e;try{e=Qo(t)}catch{return null}for(const[r,s]of this.layouts){const i=e.subarray(0,s.discriminator.length);if(i.equals(ht.Buffer.from(s.discriminator)))return{name:r,data:s.layout.decode(e.subarray(i.length))}}return null}}class i_{constructor(t){const e=t.types;if(!e){this.typeLayouts=new Map;return}const r=e.filter(s=>!s.generics).map(s=>[s.name,Rt.typeDefLayout({typeDef:s,types:e})]);this.typeLayouts=new Map(r)}encode(t,e){const r=ht.Buffer.alloc(1e3),s=this.typeLayouts.get(t);if(!s)throw new Error(`Unknown type: ${t}`);const i=s.encode(e,r);return r.slice(0,i)}decode(t,e){const r=this.typeLayouts.get(t);if(!r)throw new Error(`Unknown type: ${t}`);return r.decode(e)}}class yf{constructor(t){this.instruction=new t_(t),this.accounts=new r_(t),this.events=new n_(t),this.types=new i_(t)}}class Ne{constructor(t,e){if(!Number.isInteger(t))throw new TypeError("span must be an integer");this.span=t,this.property=e}makeDestinationObject(){return{}}decode(t,e){throw new Error("Layout is abstract")}encode(t,e,r){throw new Error("Layout is abstract")}getSpan(t,e){if(0>this.span)throw new RangeError("indeterminate span");return this.span}replicate(t){const e=Object.create(this.constructor.prototype);return Object.assign(e,this),e.property=t,e}fromArray(t){}}var Vi=Ne;function s_(n,t){return t.property?n+"["+t.property+"]":n}class Mr extends Ne{isCount(){throw new Error("ExternalLayout is abstract")}}class gf extends Mr{constructor(t,e,r){if(!(t instanceof Ne))throw new TypeError("layout must be a Layout");if(e===void 0)e=0;else if(!Number.isInteger(e))throw new TypeError("offset must be integer or undefined");super(t.span,r||t.property),this.layout=t,this.offset=e}isCount(){return this.layout instanceof Wi||this.layout instanceof mf}decode(t,e){return e===void 0&&(e=0),this.layout.decode(t,e+this.offset)}encode(t,e,r){return r===void 0&&(r=0),this.layout.encode(t,e,r+this.offset)}}class Wi extends Ne{constructor(t,e){if(super(t,e),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(t,e){return e===void 0&&(e=0),t.readUIntLE(e,this.span)}encode(t,e,r){return r===void 0&&(r=0),e.writeUIntLE(t,r,this.span),this.span}}class mf extends Ne{constructor(t,e){if(super(t,e),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(t,e){return e===void 0&&(e=0),t.readUIntBE(e,this.span)}encode(t,e,r){return r===void 0&&(r=0),e.writeUIntBE(t,r,this.span),this.span}}const wo=Math.pow(2,32);function wf(n){const t=Math.floor(n/wo),e=n-t*wo;return{hi32:t,lo32:e}}function _f(n,t){return n*wo+t}class o_ extends Ne{constructor(t){super(8,t)}decode(t,e){e===void 0&&(e=0);const r=t.readUInt32LE(e),s=t.readUInt32LE(e+4);return _f(s,r)}encode(t,e,r){r===void 0&&(r=0);const s=wf(t);return e.writeUInt32LE(s.lo32,r),e.writeUInt32LE(s.hi32,r+4),8}}class a_ extends Ne{constructor(t){super(8,t)}decode(t,e){e===void 0&&(e=0);const r=t.readUInt32LE(e),s=t.readInt32LE(e+4);return _f(s,r)}encode(t,e,r){r===void 0&&(r=0);const s=wf(t);return e.writeUInt32LE(s.lo32,r),e.writeInt32LE(s.hi32,r+4),8}}class c_ extends Ne{constructor(t,e,r){if(!(Array.isArray(t)&&t.reduce((i,o)=>i&&o instanceof Ne,!0)))throw new TypeError("fields must be array of Layout instances");typeof e=="boolean"&&r===void 0&&(r=e,e=void 0);for(const i of t)if(0>i.span&&i.property===void 0)throw new Error("fields cannot contain unnamed variable-length layout");let s=-1;try{s=t.reduce((i,o)=>i+o.getSpan(),0)}catch{}super(s,e),this.fields=t,this.decodePrefixes=!!r}getSpan(t,e){if(0<=this.span)return this.span;e===void 0&&(e=0);let r=0;try{r=this.fields.reduce((s,i)=>{const o=i.getSpan(t,e);return e+=o,s+o},0)}catch{throw new RangeError("indeterminate span")}return r}decode(t,e){e===void 0&&(e=0);const r=this.makeDestinationObject();for(const s of this.fields)if(s.property!==void 0&&(r[s.property]=s.decode(t,e)),e+=s.getSpan(t,e),this.decodePrefixes&&t.length===e)break;return r}encode(t,e,r){r===void 0&&(r=0);const s=r;let i=0,o=0;for(const a of this.fields){let l=a.span;if(o=0<l?l:0,a.property!==void 0){const p=t[a.property];p!==void 0&&(o=a.encode(p,e,r),0>l&&(l=a.getSpan(e,r)))}i=r,r+=l}return i+o-s}fromArray(t){const e=this.makeDestinationObject();for(const r of this.fields)r.property!==void 0&&0<t.length&&(e[r.property]=t.shift());return e}layoutFor(t){if(typeof t!="string")throw new TypeError("property must be string");for(const e of this.fields)if(e.property===t)return e}offsetOf(t){if(typeof t!="string")throw new TypeError("property must be string");let e=0;for(const r of this.fields){if(r.property===t)return e;0>r.span?e=-1:0<=e&&(e+=r.span)}}}class bf{constructor(t){this.property=t}decode(){throw new Error("UnionDiscriminator is abstract")}encode(){throw new Error("UnionDiscriminator is abstract")}}class tu extends bf{constructor(t,e){if(!(t instanceof Mr&&t.isCount()))throw new TypeError("layout must be an unsigned integer ExternalLayout");super(e||t.property||"variant"),this.layout=t}decode(t,e){return this.layout.decode(t,e)}encode(t,e,r){return this.layout.encode(t,e,r)}}class Ef extends Ne{constructor(t,e,r){const s=t instanceof Wi||t instanceof mf;if(s)t=new tu(new gf(t));else if(t instanceof Mr&&t.isCount())t=new tu(t);else if(!(t instanceof bf))throw new TypeError("discr must be a UnionDiscriminator or an unsigned integer layout");if(e===void 0&&(e=null),!(e===null||e instanceof Ne))throw new TypeError("defaultLayout must be null or a Layout");if(e!==null){if(0>e.span)throw new Error("defaultLayout must have constant span");e.property===void 0&&(e=e.replicate("content"))}let i=-1;e&&(i=e.span,0<=i&&s&&(i+=t.layout.span)),super(i,r),this.discriminator=t,this.usesPrefixDiscriminator=s,this.defaultLayout=e,this.registry={};let o=this.defaultGetSourceVariant.bind(this);this.getSourceVariant=function(a){return o(a)},this.configGetSourceVariant=function(a){o=a.bind(this)}}getSpan(t,e){if(0<=this.span)return this.span;e===void 0&&(e=0);const r=this.getVariant(t,e);if(!r)throw new Error("unable to determine span for unrecognized variant");return r.getSpan(t,e)}defaultGetSourceVariant(t){if(t.hasOwnProperty(this.discriminator.property)){if(this.defaultLayout&&t.hasOwnProperty(this.defaultLayout.property))return;const e=this.registry[t[this.discriminator.property]];if(e&&(!e.layout||t.hasOwnProperty(e.property)))return e}else for(const e in this.registry){const r=this.registry[e];if(t.hasOwnProperty(r.property))return r}throw new Error("unable to infer src variant")}decode(t,e){e===void 0&&(e=0);let r;const s=this.discriminator,i=s.decode(t,e);let o=this.registry[i];if(o===void 0){let a=0;o=this.defaultLayout,this.usesPrefixDiscriminator&&(a=s.layout.span),r=this.makeDestinationObject(),r[s.property]=i,r[o.property]=this.defaultLayout.decode(t,e+a)}else r=o.decode(t,e);return r}encode(t,e,r){r===void 0&&(r=0);const s=this.getSourceVariant(t);if(s===void 0){const i=this.discriminator,o=this.defaultLayout;let a=0;return this.usesPrefixDiscriminator&&(a=i.layout.span),i.encode(t[i.property],e,r),a+o.encode(t[o.property],e,r+a)}return s.encode(t,e,r)}addVariant(t,e,r){const s=new u_(this,t,e,r);return this.registry[t]=s,s}getVariant(t,e){let r=t;return Buffer.isBuffer(t)&&(e===void 0&&(e=0),r=this.discriminator.decode(t,e)),this.registry[r]}}class u_ extends Ne{constructor(t,e,r,s){if(!(t instanceof Ef))throw new TypeError("union must be a Union");if(!Number.isInteger(e)||0>e)throw new TypeError("variant must be a (non-negative) integer");if(typeof r=="string"&&s===void 0&&(s=r,r=null),r){if(!(r instanceof Ne))throw new TypeError("layout must be a Layout");if(t.defaultLayout!==null&&0<=r.span&&r.span>t.defaultLayout.span)throw new Error("variant span exceeds span of containing union");if(typeof s!="string")throw new TypeError("variant must have a String property")}let i=t.span;0>t.span&&(i=r?r.span:0,0<=i&&t.usesPrefixDiscriminator&&(i+=t.discriminator.layout.span)),super(i,s),this.union=t,this.variant=e,this.layout=r||null}getSpan(t,e){if(0<=this.span)return this.span;e===void 0&&(e=0);let r=0;return this.union.usesPrefixDiscriminator&&(r=this.union.discriminator.layout.span),r+this.layout.getSpan(t,e+r)}decode(t,e){const r=this.makeDestinationObject();if(e===void 0&&(e=0),this!==this.union.getVariant(t,e))throw new Error("variant mismatch");let s=0;return this.union.usesPrefixDiscriminator&&(s=this.union.discriminator.layout.span),this.layout?r[this.property]=this.layout.decode(t,e+s):this.property?r[this.property]=!0:this.union.usesPrefixDiscriminator&&(r[this.union.discriminator.property]=this.variant),r}encode(t,e,r){r===void 0&&(r=0);let s=0;if(this.union.usesPrefixDiscriminator&&(s=this.union.discriminator.layout.span),this.layout&&!t.hasOwnProperty(this.property))throw new TypeError("variant lacks property "+this.property);this.union.discriminator.encode(this.variant,e,r);let i=s;if(this.layout&&(this.layout.encode(t[this.property],e,r+s),i+=this.layout.getSpan(e,r+s),0<=this.union.span&&i>this.union.span))throw new Error("encoded variant overruns containing union");return i}fromArray(t){if(this.layout)return this.layout.fromArray(t)}}class l_ extends Ne{constructor(t,e){if(!(t instanceof Mr&&t.isCount()||Number.isInteger(t)&&0<=t))throw new TypeError("length must be positive integer or an unsigned integer ExternalLayout");let r=-1;t instanceof Mr||(r=t),super(r,e),this.length=t}getSpan(t,e){let r=this.span;return 0>r&&(r=this.length.decode(t,e)),r}decode(t,e){e===void 0&&(e=0);let r=this.span;return 0>r&&(r=this.length.decode(t,e)),t.slice(e,e+r)}encode(t,e,r){let s=this.length;if(this.length instanceof Mr&&(s=t.length),!(Buffer.isBuffer(t)&&s===t.length))throw new TypeError(s_("Blob.encode",this)+" requires (length "+s+") Buffer as src");if(r+s>e.length)throw new RangeError("encoding overruns Buffer");return e.write(t.toString("hex"),r,s,"hex"),this.length instanceof Mr&&this.length.encode(s,e,r),s}}var h_=((n,t,e)=>new gf(n,t,e)),f_=(n=>new Wi(1,n)),ur=(n=>new Wi(4,n)),d_=(n=>new o_(n)),fr=(n=>new a_(n)),ge=((n,t,e)=>new c_(n,t,e)),Rf=((n,t,e)=>new Ef(n,t,e)),Kn=((n,t)=>new l_(n,t));class p_ extends Vi{constructor(t){super(-1,t),this.property=t,this.layout=ge([ur("length"),ur("lengthPadding"),Kn(h_(ur(),-8),"chars")],this.property)}encode(t,e,r=0){if(t==null)return this.layout.span;const s={chars:Buffer.from(t,"utf8")};return this.layout.encode(s,e,r)}decode(t,e=0){return this.layout.decode(t,e).chars.toString()}getSpan(t,e=0){return ur().span+ur().span+new or(new Uint8Array(t).slice(e,e+4),10,"le").toNumber()}}function Gi(n){return new p_(n)}function He(n){return Kn(32,n)}const Le=Rf(ur("instruction"));Le.addVariant(0,ge([fr("lamports"),fr("space"),He("owner")]),"createAccount");Le.addVariant(1,ge([He("owner")]),"assign");Le.addVariant(2,ge([fr("lamports")]),"transfer");Le.addVariant(3,ge([He("base"),Gi("seed"),fr("lamports"),fr("space"),He("owner")]),"createAccountWithSeed");Le.addVariant(4,ge([He("authorized")]),"advanceNonceAccount");Le.addVariant(5,ge([fr("lamports")]),"withdrawNonceAccount");Le.addVariant(6,ge([He("authorized")]),"initializeNonceAccount");Le.addVariant(7,ge([He("authorized")]),"authorizeNonceAccount");Le.addVariant(8,ge([fr("space")]),"allocate");Le.addVariant(9,ge([He("base"),Gi("seed"),fr("space"),He("owner")]),"allocateWithSeed");Le.addVariant(10,ge([He("base"),Gi("seed"),He("owner")]),"assignWithSeed");Le.addVariant(11,ge([fr("lamports"),Gi("seed"),He("owner")]),"transferWithSeed");Math.max(...Object.values(Le.registry).map(n=>n.span));class y_ extends Vi{constructor(t,e,r,s){super(t.span,s),this.layout=t,this.decoder=e,this.encoder=r}decode(t,e){return this.decoder(this.layout.decode(t,e))}encode(t,e,r){return this.layout.encode(this.encoder(t),e,r)}getSpan(t,e){return this.layout.getSpan(t,e)}}function eu(n){return new y_(Kn(32),t=>new rt(t),t=>t.toBuffer(),n)}ge([ur("version"),ur("state"),eu("authorizedPubkey"),eu("nonce"),ge([d_("lamportsPerSignature")],"feeCalculator")]);function g_(n){return new TextDecoder().decode(yi(n))}var m_=Object.freeze({__proto__:null,hash:g_});function w_(n,t,e){const r=ht.Buffer.concat([n.toBuffer(),ht.Buffer.from(t),e.toBuffer()]);return new rt(yi(r))}var __=Object.freeze({__proto__:null,createWithSeedSync:w_});const vf=new rt("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"),Af=new rt("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL");function b_({mint:n,owner:t}){return rt.findProgramAddressSync([t.toBuffer(),vf.toBuffer(),n.toBuffer()],Af)[0]}var E_=Object.freeze({__proto__:null,TOKEN_PROGRAM_ID:vf,ASSOCIATED_PROGRAM_ID:Af,associatedAddress:b_}),_o={exports:{}};(function(n,t){var e=typeof self<"u"?self:jw,r=(function(){function i(){this.fetch=!1,this.DOMException=e.DOMException}return i.prototype=e,new i})();(function(i){(function(o){var a={searchParams:"URLSearchParams"in i,iterable:"Symbol"in i&&"iterator"in Symbol,blob:"FileReader"in i&&"Blob"in i&&(function(){try{return new Blob,!0}catch{return!1}})(),formData:"FormData"in i,arrayBuffer:"ArrayBuffer"in i};function l(c){return c&&DataView.prototype.isPrototypeOf(c)}if(a.arrayBuffer)var p=["[object Int8Array]","[object Uint8Array]","[object Uint8ClampedArray]","[object Int16Array]","[object Uint16Array]","[object Int32Array]","[object Uint32Array]","[object Float32Array]","[object Float64Array]"],m=ArrayBuffer.isView||function(c){return c&&p.indexOf(Object.prototype.toString.call(c))>-1};function S(c){if(typeof c!="string"&&(c=String(c)),/[^a-z0-9\-#$%&'*+.^_`|~]/i.test(c))throw new TypeError("Invalid character in header field name");return c.toLowerCase()}function R(c){return typeof c!="string"&&(c=String(c)),c}function _(c){var f={next:function(){var E=c.shift();return{done:E===void 0,value:E}}};return a.iterable&&(f[Symbol.iterator]=function(){return f}),f}function I(c){this.map={},c instanceof I?c.forEach(function(f,E){this.append(E,f)},this):Array.isArray(c)?c.forEach(function(f){this.append(f[0],f[1])},this):c&&Object.getOwnPropertyNames(c).forEach(function(f){this.append(f,c[f])},this)}I.prototype.append=function(c,f){c=S(c),f=R(f);var E=this.map[c];this.map[c]=E?E+", "+f:f},I.prototype.delete=function(c){delete this.map[S(c)]},I.prototype.get=function(c){return c=S(c),this.has(c)?this.map[c]:null},I.prototype.has=function(c){return this.map.hasOwnProperty(S(c))},I.prototype.set=function(c,f){this.map[S(c)]=R(f)},I.prototype.forEach=function(c,f){for(var E in this.map)this.map.hasOwnProperty(E)&&c.call(f,this.map[E],E,this)},I.prototype.keys=function(){var c=[];return this.forEach(function(f,E){c.push(E)}),_(c)},I.prototype.values=function(){var c=[];return this.forEach(function(f){c.push(f)}),_(c)},I.prototype.entries=function(){var c=[];return this.forEach(function(f,E){c.push([E,f])}),_(c)},a.iterable&&(I.prototype[Symbol.iterator]=I.prototype.entries);function O(c){if(c.bodyUsed)return Promise.reject(new TypeError("Already read"));c.bodyUsed=!0}function x(c){return new Promise(function(f,E){c.onload=function(){f(c.result)},c.onerror=function(){E(c.error)}})}function M(c){var f=new FileReader,E=x(f);return f.readAsArrayBuffer(c),E}function H(c){var f=new FileReader,E=x(f);return f.readAsText(c),E}function P(c){for(var f=new Uint8Array(c),E=new Array(f.length),T=0;T<f.length;T++)E[T]=String.fromCharCode(f[T]);return E.join("")}function q(c){if(c.slice)return c.slice(0);var f=new Uint8Array(c.byteLength);return f.set(new Uint8Array(c)),f.buffer}function G(){return this.bodyUsed=!1,this._initBody=function(c){this._bodyInit=c,c?typeof c=="string"?this._bodyText=c:a.blob&&Blob.prototype.isPrototypeOf(c)?this._bodyBlob=c:a.formData&&FormData.prototype.isPrototypeOf(c)?this._bodyFormData=c:a.searchParams&&URLSearchParams.prototype.isPrototypeOf(c)?this._bodyText=c.toString():a.arrayBuffer&&a.blob&&l(c)?(this._bodyArrayBuffer=q(c.buffer),this._bodyInit=new Blob([this._bodyArrayBuffer])):a.arrayBuffer&&(ArrayBuffer.prototype.isPrototypeOf(c)||m(c))?this._bodyArrayBuffer=q(c):this._bodyText=c=Object.prototype.toString.call(c):this._bodyText="",this.headers.get("content-type")||(typeof c=="string"?this.headers.set("content-type","text/plain;charset=UTF-8"):this._bodyBlob&&this._bodyBlob.type?this.headers.set("content-type",this._bodyBlob.type):a.searchParams&&URLSearchParams.prototype.isPrototypeOf(c)&&this.headers.set("content-type","application/x-www-form-urlencoded;charset=UTF-8"))},a.blob&&(this.blob=function(){var c=O(this);if(c)return c;if(this._bodyBlob)return Promise.resolve(this._bodyBlob);if(this._bodyArrayBuffer)return Promise.resolve(new Blob([this._bodyArrayBuffer]));if(this._bodyFormData)throw new Error("could not read FormData body as blob");return Promise.resolve(new Blob([this._bodyText]))},this.arrayBuffer=function(){return this._bodyArrayBuffer?O(this)||Promise.resolve(this._bodyArrayBuffer):this.blob().then(M)}),this.text=function(){var c=O(this);if(c)return c;if(this._bodyBlob)return H(this._bodyBlob);if(this._bodyArrayBuffer)return Promise.resolve(P(this._bodyArrayBuffer));if(this._bodyFormData)throw new Error("could not read FormData body as text");return Promise.resolve(this._bodyText)},a.formData&&(this.formData=function(){return this.text().then(L)}),this.json=function(){return this.text().then(JSON.parse)},this}var J=["DELETE","GET","HEAD","OPTIONS","POST","PUT"];function Q(c){var f=c.toUpperCase();return J.indexOf(f)>-1?f:c}function tt(c,f){f=f||{};var E=f.body;if(c instanceof tt){if(c.bodyUsed)throw new TypeError("Already read");this.url=c.url,this.credentials=c.credentials,f.headers||(this.headers=new I(c.headers)),this.method=c.method,this.mode=c.mode,this.signal=c.signal,!E&&c._bodyInit!=null&&(E=c._bodyInit,c.bodyUsed=!0)}else this.url=String(c);if(this.credentials=f.credentials||this.credentials||"same-origin",(f.headers||!this.headers)&&(this.headers=new I(f.headers)),this.method=Q(f.method||this.method||"GET"),this.mode=f.mode||this.mode||null,this.signal=f.signal||this.signal,this.referrer=null,(this.method==="GET"||this.method==="HEAD")&&E)throw new TypeError("Body not allowed for GET or HEAD requests");this._initBody(E)}tt.prototype.clone=function(){return new tt(this,{body:this._bodyInit})};function L(c){var f=new FormData;return c.trim().split("&").forEach(function(E){if(E){var T=E.split("="),N=T.shift().replace(/\+/g," "),A=T.join("=").replace(/\+/g," ");f.append(decodeURIComponent(N),decodeURIComponent(A))}}),f}function U(c){var f=new I,E=c.replace(/\r?\n[\t ]+/g," ");return E.split(/\r?\n/).forEach(function(T){var N=T.split(":"),A=N.shift().trim();if(A){var g=N.join(":").trim();f.append(A,g)}}),f}G.call(tt.prototype);function F(c,f){f||(f={}),this.type="default",this.status=f.status===void 0?200:f.status,this.ok=this.status>=200&&this.status<300,this.statusText="statusText"in f?f.statusText:"OK",this.headers=new I(f.headers),this.url=f.url||"",this._initBody(c)}G.call(F.prototype),F.prototype.clone=function(){return new F(this._bodyInit,{status:this.status,statusText:this.statusText,headers:new I(this.headers),url:this.url})},F.error=function(){var c=new F(null,{status:0,statusText:""});return c.type="error",c};var z=[301,302,303,307,308];F.redirect=function(c,f){if(z.indexOf(f)===-1)throw new RangeError("Invalid status code");return new F(null,{status:f,headers:{location:c}})},o.DOMException=i.DOMException;try{new o.DOMException}catch{o.DOMException=function(f,E){this.message=f,this.name=E;var T=Error(f);this.stack=T.stack},o.DOMException.prototype=Object.create(Error.prototype),o.DOMException.prototype.constructor=o.DOMException}function b(c,f){return new Promise(function(E,T){var N=new tt(c,f);if(N.signal&&N.signal.aborted)return T(new o.DOMException("Aborted","AbortError"));var A=new XMLHttpRequest;function g(){A.abort()}A.onload=function(){var d={status:A.status,statusText:A.statusText,headers:U(A.getAllResponseHeaders()||"")};d.url="responseURL"in A?A.responseURL:d.headers.get("X-Request-URL");var u="response"in A?A.response:A.responseText;E(new F(u,d))},A.onerror=function(){T(new TypeError("Network request failed"))},A.ontimeout=function(){T(new TypeError("Network request failed"))},A.onabort=function(){T(new o.DOMException("Aborted","AbortError"))},A.open(N.method,N.url,!0),N.credentials==="include"?A.withCredentials=!0:N.credentials==="omit"&&(A.withCredentials=!1),"responseType"in A&&a.blob&&(A.responseType="blob"),N.headers.forEach(function(d,u){A.setRequestHeader(u,d)}),N.signal&&(N.signal.addEventListener("abort",g),A.onreadystatechange=function(){A.readyState===4&&N.signal.removeEventListener("abort",g)}),A.send(typeof N._bodyInit>"u"?null:N._bodyInit)})}return b.polyfill=!0,i.fetch||(i.fetch=b,i.Headers=I,i.Request=tt,i.Response=F),o.Headers=I,o.Request=tt,o.Response=F,o.fetch=b,Object.defineProperty(o,"__esModule",{value:!0}),o})({})})(r),r.fetch.ponyfill=!0,delete r.fetch.polyfill;var s=r;t=s.fetch,t.default=s.fetch,t.fetch=s.fetch,t.Headers=s.Headers,t.Request=s.Request,t.Response=s.Response,n.exports=t})(_o,_o.exports);var R_=Yw(_o.exports);async function v_(n,t,e=5){const r=`https://api.apr.dev/api/v0/program/${t.toString()}/latest?limit=${e}`,[s,i]=await Promise.all([If(n,t),R_(r)]),o=(await i.json()).filter(l=>!l.aborted&&l.state==="Built"&&l.verified==="Verified");if(o.length===0)return null;const a=o[0];return s.slot.toNumber()!==a.verified_slot?null:a}async function If(n,t){const e=await n.getAccountInfo(t);if(e===null)throw new Error("program account not found");const{program:r}=bo(e.data),s=await n.getAccountInfo(r.programdataAddress);if(s===null)throw new Error("program data account not found");const{programData:i}=bo(s.data);return i}const A_=mt.rustEnum([mt.struct([],"uninitialized"),mt.struct([mt.option(mt.publicKey(),"authorityAddress")],"buffer"),mt.struct([mt.publicKey("programdataAddress")],"program"),mt.struct([mt.u64("slot"),mt.option(mt.publicKey(),"upgradeAuthorityAddress")],"programData")],void 0,mt.u32());function bo(n){return A_.decode(n)}var I_=Object.freeze({__proto__:null,verifiedBuild:v_,fetchData:If,decodeUpgradeableLoaderState:bo}),J_=Object.freeze({__proto__:null,sha256:m_,rpc:Ww,publicKey:__,bytes:vw,token:E_,features:Jw,registry:I_});const Eo="Program log: ",Sf="Program data: ",S_=Eo.length,k_=Sf.length;class T_{constructor(t,e,r){this._programId=t,this._provider=e,this._eventParser=new kf(t,r),this._eventCallbacks=new Map,this._eventListeners=new Map,this._listenerIdCount=0}addEventListener(t,e,r){var s;let i=this._listenerIdCount;return this._listenerIdCount+=1,this._eventListeners.has(t)||this._eventListeners.set(t,[]),this._eventListeners.set(t,((s=this._eventListeners.get(t))!==null&&s!==void 0?s:[]).concat(i)),this._eventCallbacks.set(i,[t,e]),this._onLogsSubscriptionId!==void 0||(this._onLogsSubscriptionId=this._provider.connection.onLogs(this._programId,(o,a)=>{if(!o.err)for(const l of this._eventParser.parseLogs(o.logs)){const p=this._eventListeners.get(l.name);p&&p.forEach(m=>{const S=this._eventCallbacks.get(m);if(S){const[,R]=S;R(l.data,a.slot,o.signature)}})}},r)),i}async removeEventListener(t){const e=this._eventCallbacks.get(t);if(!e)throw new Error(`Event listener ${t} doesn't exist!`);const[r]=e;let s=this._eventListeners.get(r);if(!s)throw new Error(`Event listeners don't exist for ${r}!`);if(this._eventCallbacks.delete(t),s=s.filter(i=>i!==t),this._eventListeners.set(r,s),s.length===0&&this._eventListeners.delete(r),this._eventCallbacks.size===0){if(this._eventListeners.size!==0)throw new Error(`Expected event listeners size to be 0 but got ${this._eventListeners.size}`);this._onLogsSubscriptionId!==void 0&&(await this._provider.connection.removeOnLogsListener(this._onLogsSubscriptionId),this._onLogsSubscriptionId=void 0)}}}class kf{constructor(t,e){this.coder=e,this.programId=t}*parseLogs(t,e=!1){const r=new x_(t),s=new O_;let i=r.next();for(;i!==null;){let[o,a,l]=this.handleLog(s,i,e);o&&(yield o),a&&s.push(a),l&&s.pop(),i=r.next()}}handleLog(t,e,r){return t.stack.length>0&&t.program()===this.programId.toString()?this.handleProgramLog(e,r):[null,...this.handleSystemLog(e)]}handleProgramLog(t,e){if(t.startsWith(Eo)||t.startsWith(Sf)){const r=t.startsWith(Eo)?t.slice(S_):t.slice(k_),s=this.coder.events.decode(r);if(e&&s===null)throw new Error(`Unable to decode event ${r}`);return[s,null,!1]}else return[null,...this.handleSystemLog(t)]}handleSystemLog(t){const e=t.split(":")[0];return e.match(/^Program (.*) success/g)!==null?[null,!0]:e.startsWith(`Program ${this.programId.toString()} invoke`)?[this.programId.toString(),!1]:e.includes("invoke")?["cpi",!1]:[null,!1]}}class O_{constructor(){this.stack=[]}program(){if(!this.stack.length)throw new Error("Expected the stack to have elements");return this.stack[this.stack.length-1]}push(t){this.stack.push(t)}pop(){if(!this.stack.length)throw new Error("Expected the stack to have elements");this.stack.pop()}}class x_{constructor(t){this.logs=t}next(){if(this.logs.length===0)return null;let t=this.logs[0];return this.logs=this.logs.slice(1),t}}function ji(n,t){var e,r;let s={};const i=n.args?n.args.length:0;if(t.length>i){if(t.length!==i+1)throw new Error(`provided too many arguments ${t} to instruction ${n?.name} expecting: ${(r=(e=n.args)===null||e===void 0?void 0:e.map(o=>o.name))!==null&&r!==void 0?r:[]}`);s=t.pop()}return[t,s]}class ki{static build(t,e,r){if(t.name==="_inner")throw new wr("the _inner name is reserved");const s=(...i)=>{const[o,a]=ji(t,[...i]);Dl(t.accounts,a.accounts),N_(t,...i);const l=s.accounts(a.accounts);return a.remainingAccounts!==void 0&&l.push(...a.remainingAccounts),ia("debug-logs")&&console.log("Outgoing account metas:",l),new xt({keys:l,programId:r,data:e(t.name,xw(t,...o))})};return s.accounts=i=>ki.accountsArray(i,t.accounts,r,t.name),s}static accountsArray(t,e,r,s){return t?e.map(i=>{if(_r(i)){const m=t[i.name];return ki.accountsArray(m,i.accounts,r,s).flat()}let o;try{o=Ue(t[i.name])}catch{throw new Error(`Wrong input type for account "${i.name}" in the instruction accounts object${s!==void 0?' for instruction "'+s+'"':""}. Expected PublicKey or string.`)}const a=i.optional&&o.equals(r),l=!!(i.writable&&!a),p=!!(i.signer&&!a);return{pubkey:o,isWritable:l,isSigner:p}}).flat():[]}}function N_(n,...t){}class C_{static build(t,e){return(...s)=>{var i,o,a;const[,l]=ji(t,[...s]),p=new At;if(l.preInstructions&&l.instructions)throw new Error("instructions is deprecated, use preInstructions");return(i=l.preInstructions)===null||i===void 0||i.forEach(m=>p.add(m)),(o=l.instructions)===null||o===void 0||o.forEach(m=>p.add(m)),p.add(e(...s)),(a=l.postInstructions)===null||a===void 0||a.forEach(m=>p.add(m)),p}}}class B_{static build(t,e,r,s){return async(...o)=>{var a;const l=e(...o),[,p]=ji(t,[...o]);if(s.sendAndConfirm===void 0)throw new Error("This function requires 'Provider.sendAndConfirm' to be implemented.");try{return await s.sendAndConfirm(l,(a=p.signers)!==null&&a!==void 0?a:[],p.options)}catch(m){throw pf(m,r)}}}}class M_{static build(t,e,r,s){var i;return((i=t.accounts)!==null&&i!==void 0?i:[]).reduce((o,a)=>(o[a.name]=new L_(t,a,r,s,e),o),{})}}class L_{get size(){return this._size}get programId(){return this._programId}get provider(){return this._provider}get coder(){return this._coder}constructor(t,e,r,s,i){this._idlAccount=e,this._programId=r,this._provider=s??Ii(),this._coder=i??new yf(t),this._size=this._coder.accounts.size(e.name)}async fetchNullable(t,e){const{data:r}=await this.fetchNullableAndContext(t,e);return r}async fetchNullableAndContext(t,e){const r=await this.getAccountInfoAndContext(t,e),{value:s,context:i}=r;return{data:s&&s.data.length!==0?this._coder.accounts.decode(this._idlAccount.name,s.data):null,context:i}}async fetch(t,e){const{data:r}=await this.fetchNullableAndContext(t,e);if(r===null)throw new Error(`Account does not exist or has no data ${t.toString()}`);return r}async fetchAndContext(t,e){const{data:r,context:s}=await this.fetchNullableAndContext(t,e);if(r===null)throw new Error(`Account does not exist ${t.toString()}`);return{data:r,context:s}}async fetchMultiple(t,e){return(await this.fetchMultipleAndContext(t,e)).map(s=>s?s.data:null)}async fetchMultipleAndContext(t,e){return(await na(this._provider.connection,t.map(s=>Ue(s)),e)).map(s=>{if(s==null)return null;const{account:i,context:o}=s;return{data:this._coder.accounts.decode(this._idlAccount.name,i.data),context:o}})}async all(t){const e=this.coder.accounts.memcmp(this._idlAccount.name,t instanceof Buffer?t:void 0),r=[];return e?.offset!=null&&e?.bytes!=null&&r.push({memcmp:{offset:e.offset,bytes:e.bytes}}),e?.dataSize!=null&&r.push({dataSize:e.dataSize}),(await this._provider.connection.getProgramAccounts(this._programId,{commitment:this._provider.connection.commitment,filters:[...r,...Array.isArray(t)?t:[]]})).map(({pubkey:i,account:o})=>({publicKey:i,account:this._coder.accounts.decode(this._idlAccount.name,o.data)}))}subscribe(t,e){const r=bn.get(t.toString());if(r)return r.ee;const s=new fw;t=Ue(t);const i=this._provider.connection.onAccountChange(t,o=>{const a=this._coder.accounts.decode(this._idlAccount.name,o.data);s.emit("change",a)},e);return bn.set(t.toString(),{ee:s,listener:i}),s}async unsubscribe(t){let e=bn.get(t.toString());if(!e){console.warn("Address is not subscribed");return}bn&&await this._provider.connection.removeAccountChangeListener(e.listener).then(()=>{bn.delete(t.toString())}).catch(console.error)}async createInstruction(t,e){const r=this.size;if(this._provider.publicKey===void 0)throw new Error("This function requires the Provider interface implementor to have a 'publicKey' field.");return ye.createAccount({fromPubkey:this._provider.publicKey,newAccountPubkey:t.publicKey,space:e??r,lamports:await this._provider.connection.getMinimumBalanceForRentExemption(e??r),programId:this._programId})}async getAccountInfo(t,e){return await this._provider.connection.getAccountInfo(Ue(t),e)}async getAccountInfoAndContext(t,e){return await this._provider.connection.getAccountInfoAndContext(Ue(t),e)}}const bn=new Map;class P_{static build(t,e,r,s,i,o,a){return async(...p)=>{var m;const S=e(...p),[,R]=ji(t,[...p]);let _;if(s.simulate===void 0)throw new Error("This function requires 'Provider.simulate' to be implemented.");try{_=await s.simulate(S,R.signers,(m=R.options)===null||m===void 0?void 0:m.commitment)}catch(x){throw pf(x,r)}if(_===void 0)throw new Error("Unable to simulate transaction");const I=_.logs;if(!I)throw new Error("Simulated logs not found");const O=[];if(a.events){let x=new kf(o,i);for(const M of x.parseLogs(I))O.push(M)}return{events:O,raw:I}}}}function to(n){return new Tf(Kn(8),t=>sa.fromBuffer(t),t=>t.toBuffer(),n)}function oi(n){return new Tf(Kn(32),t=>new rt(t),t=>t.toBuffer(),n)}function eo(n,t){return new U_(n,t)}class Tf extends Vi{constructor(t,e,r,s){super(t.span,s),this.layout=t,this.decoder=e,this.encoder=r}decode(t,e){return this.decoder(this.layout.decode(t,e))}encode(t,e,r){return this.layout.encode(this.encoder(t),e,r)}getSpan(t,e){return this.layout.getSpan(t,e)}}class U_ extends Vi{constructor(t,e){super(-1,e),this.layout=t,this.discriminator=ur()}encode(t,e,r=0){return t==null?this.layout.span+this.discriminator.encode(0,e,r):(this.discriminator.encode(1,e,r),this.layout.encode(t,e,r+4)+4)}decode(t,e=0){const r=this.discriminator.decode(t,e);if(r===0)return null;if(r===1)return this.layout.decode(t,e+4);throw new Error("Invalid coption "+this.layout.property)}getSpan(t,e=0){return this.layout.getSpan(t,e+4)+4}}class sa extends or{toBuffer(){const t=super.toArray().reverse(),e=Buffer.from(t);if(e.length===8)return e;if(e.length>=8)throw new Error("u64 too large");const r=Buffer.alloc(8);return e.copy(r),r}static fromBuffer(t){if(t.length!==8)throw new Error(`Invalid buffer length: ${t.length}`);return new sa([...t].reverse().map(e=>`00${e.toString(16)}`.slice(-2)).join(""),16)}}const D_=ge([oi("mint"),oi("owner"),to("amount"),eo(oi(),"delegate"),(n=>{const t=Rf(f_("discriminator"),null,n);return t.addVariant(0,ge([]),"uninitialized"),t.addVariant(1,ge([]),"initialized"),t.addVariant(2,ge([]),"frozen"),t})("state"),eo(to(),"isNative"),to("delegatedAmount"),eo(oi(),"closeAuthority")]);function H_(n){return D_.decode(n)}class F_{constructor(t,e,r,s,i,o,a,l){this._args=t,this._accounts=e,this._provider=r,this._programId=s,this._idlIx=i,this._idlTypes=a,this._customResolver=l,this._accountStore=new z_(r,o,s)}args(t){this._args=t}async resolve(){this.resolveEventCpi(this._idlIx.accounts),this.resolveConst(this._idlIx.accounts);let t=0;for(;await this.resolvePdasAndRelations(this._idlIx.accounts)+await this.resolveCustom()>0;)if(t++,t===16){const e=o=>_r(o)?o.accounts.some(e):!!(o.address||o.pda||o.relations),r=(o,a=[],l=[])=>{for(const p of o)_r(p)?l.push(...r(p.accounts,[...a,p.name])):l.push([...a,p.name]);return l},s=this._idlIx.accounts.filter(e),i=r(s).filter(o=>!this.get(o)).map(o=>o.reduce((a,l)=>a+"."+l)).map(o=>`\`${o}\``).join(", ");throw new Error(["Reached maximum depth for account resolution.",`Unresolved accounts: ${i}`].join(" "))}}resolveOptionals(t){Object.assign(this._accounts,this.resolveOptionalsHelper(t,this._idlIx.accounts))}get(t){const e=t.reduce((r,s)=>r&&r[s],this._accounts);if(e&&e.toBase58)return e}set(t,e){let r=this._accounts;t.forEach((s,i)=>{var o;i===t.length-1&&(r[s]=e),r[s]=(o=r[s])!==null&&o!==void 0?o:{},r=r[s]})}resolveOptionalsHelper(t,e){const r={};for(const s of e){const i=s.name,o=t[i];o!==void 0&&(Of(o)?_r(s)?r[i]=this.resolveOptionalsHelper(o,s.accounts):r[i]=xf(o):o!==null?r[i]=Ue(o):s.optional&&(r[i]=this._programId))}return r}async resolveCustom(){if(this._customResolver){const{accounts:t,resolved:e}=await this._customResolver({args:this._args,accounts:this._accounts,provider:this._provider,programId:this._programId,idlIx:this._idlIx});return this._accounts=t,e}return 0}resolveEventCpi(t,e=[]){for(const r in t){const s=t[r];_r(s)&&this.resolveEventCpi(s.accounts,[...e,s.name]);const i=+r+1;if(i===t.length)return;const o=t[r].name,a=t[i].name;if(o==="eventAuthority"&&a==="program"){const l=[...e,o],p=[...e,a];this.get(l)||this.set(l,rt.findProgramAddressSync([Buffer.from("__event_authority")],this._programId)[0]),this.get(p)||this.set(p,this._programId);return}}}resolveConst(t,e=[]){for(const r of t){const s=r.name;if(_r(r))this.resolveConst(r.accounts,[...e,s]);else{const i=r;if((i.signer||i.address)&&!this.get([...e,s])){if(i.signer){if(!this._provider.publicKey)throw new Error("This function requires the `Provider` interface implementor to have a `publicKey` field.");this.set([...e,s],this._provider.publicKey)}i.address&&this.set([...e,s],Ue(i.address))}}}}async resolvePdasAndRelations(t,e=[]){let r=0;for(const s of t){const i=s.name;if(_r(s))r+=await this.resolvePdasAndRelations(s.accounts,[...e,i]);else{const o=s;if((o.pda||o.relations)&&!this.get([...e,i])){r++;try{if(o.pda){const a=await Promise.all(o.pda.seeds.map(m=>this.toBuffer(m,e)));if(a.some(m=>!m))continue;const l=await this.parseProgramId(o,e),[p]=rt.findProgramAddressSync(a,l);this.set([...e,i],p)}}catch{}try{if(o.relations){const a=this.get([...e,o.relations[0]]);if(a){const l=await this._accountStore.fetchAccount({publicKey:a});this.set([...e,i],l[i])}}}catch{}}}}return r}async parseProgramId(t,e=[]){var r;if(!(!((r=t.pda)===null||r===void 0)&&r.program))return this._programId;const s=await this.toBuffer(t.pda.program,e);if(!s)throw new Error(`Program seed not resolved: ${t.name}`);return new rt(s)}async toBuffer(t,e=[]){switch(t.kind){case"const":return this.toBufferConst(t);case"arg":return await this.toBufferArg(t);case"account":return await this.toBufferAccount(t,e);default:throw new Error(`Unexpected seed: ${t}`)}}toBufferConst(t){return this.toBufferValue("bytes",t.value)}async toBufferArg(t){const[e,...r]=t.path.split("."),s=this._idlIx.args.findIndex(a=>a.name===e);if(s===-1)throw new Error(`Unable to find argument for seed: ${e}`);const i=r.reduce((a,l)=>(a??{})[l],this._args[s]);if(i===void 0)return;const o=this.getType(this._idlIx.args[s].type,r);return this.toBufferValue(o,i)}async toBufferAccount(t,e=[]){const[r,...s]=t.path.split("."),i=this.get([...e,r]);if(!i)return;if(!s.length)return this.toBufferValue("pubkey",i);if(!t.account)throw new Error(`Seed account is required in order to resolve type: ${t.path}`);let a=await this._accountStore.fetchAccount({publicKey:i,name:t.account}),l=s;for(;l.length>0;)a=a[l[0]],l=l.slice(1);if(a===void 0)return;const p=this.getType({defined:{name:t.account}},s);return this.toBufferValue(p,a)}toBufferValue(t,e){switch(t){case"u8":case"i8":return Buffer.from([e]);case"u16":case"i16":return new or(e).toArrayLike(Buffer,"le",2);case"u32":case"i32":return new or(e).toArrayLike(Buffer,"le",4);case"u64":case"i64":return new or(e).toArrayLike(Buffer,"le",8);case"u128":case"i128":return new or(e).toArrayLike(Buffer,"le",16);case"u256":case"i256":return new or(e).toArrayLike(Buffer,"le",32);case"string":return Buffer.from(e);case"pubkey":return e.toBuffer();case"bytes":return Buffer.from(e);default:if(t?.array)return Buffer.from(e);throw new Error(`Unexpected seed type: ${t}`)}}getType(t,e=[]){var r;const s=(r=t?.defined)===null||r===void 0?void 0:r.name;if(s){if(s==="tokenAccount")switch(e.at(0)){case"mint":case"owner":return"pubkey";case"amount":case"delagatedAmount":return"u64";default:throw new Error(`Unknown token account path: ${e}`)}const i=this._idlTypes.find(m=>m.name===s);if(!i)throw new Error(`Type not found: ${s}`);const[o,...a]=e,p=i.type.fields.find(m=>m.name===o);if(!p)throw new Error(`Field not found: ${o}`);return this.getType(p.type,a)}return t}}class z_{constructor(t,e,r){this._provider=t,this._cache=new Map,this._idls={},this._idls[r.toBase58()]=e}async fetchAccount({publicKey:t,name:e}){const r=t.toBase58();if(!this._cache.has(r)){const s=await this._provider.connection.getAccountInfo(t);if(s===null)throw new Error(`Account not found: ${r}`);if(e==="tokenAccount"){const i=H_(s.data);this._cache.set(r,i)}else{const i=await this.getAccountsNs(s.owner);if(i){const o=Object.values(i)[0];if(o){const a=o.coder.accounts.decodeAny(s.data);this._cache.set(r,a)}}}}return this._cache.get(r)}async getAccountsNs(t){const e=t.toBase58();if(!this._idls[e]){const r=await Nn.fetchIdl(t,this._provider);if(r){const s=new Nn(r,this._provider);this._idls[e]=s.account}}return this._idls[e]}}class K_{static build(t,e,r,s,i,o,a,l,p,m,S){return(...R)=>new q_(R,s,i,o,a,l,t,e,r,p,m,S)}}function Of(n){return typeof n=="object"&&n!==null&&!("_bn"in n)}function xf(n,t){const e={};for(const r in n){const s=n[r];if(s===null)throw new Error("Failed to resolve optionals due to IDL type mismatch with input accounts!");e[r]=Of(s)?xf(s):Ue(s)}return e}class q_{constructor(t,e,r,s,i,o,a,l,p,m,S,R){this._args=t,this._ixFn=e,this._txFn=r,this._rpcFn=s,this._simulateFn=i,this._viewFn=o,this._accounts={},this._remainingAccounts=[],this._signers=[],this._preInstructions=[],this._postInstructions=[],this._resolveAccounts=!0,this._accountsResolver=new F_(t,this._accounts,a,l,p,m,S,R)}args(t){this._args=t,this._accountsResolver.args(t)}accounts(t){return this.accountsPartial(t)}accountsPartial(t){return this._resolveAccounts=!0,this._accountsResolver.resolveOptionals(t),this}accountsStrict(t){return this._resolveAccounts=!1,this._accountsResolver.resolveOptionals(t),this}signers(t){return this._signers=this._signers.concat(t),this}remainingAccounts(t){return this._remainingAccounts=this._remainingAccounts.concat(t),this}preInstructions(t,e=!1){return e?this._preInstructions=t.concat(this._preInstructions):this._preInstructions=this._preInstructions.concat(t),this}postInstructions(t){return this._postInstructions=this._postInstructions.concat(t),this}async pubkeys(){return this._resolveAccounts&&await this._accountsResolver.resolve(),this._accounts}async instruction(){return this._resolveAccounts&&await this._accountsResolver.resolve(),this._ixFn(...this._args,{accounts:this._accounts,signers:this._signers,remainingAccounts:this._remainingAccounts,preInstructions:this._preInstructions,postInstructions:this._postInstructions})}async transaction(){return this._resolveAccounts&&await this._accountsResolver.resolve(),this._txFn(...this._args,{accounts:this._accounts,signers:this._signers,remainingAccounts:this._remainingAccounts,preInstructions:this._preInstructions,postInstructions:this._postInstructions})}async simulate(t){return this._resolveAccounts&&await this._accountsResolver.resolve(),this._simulateFn(...this._args,{accounts:this._accounts,signers:this._signers,remainingAccounts:this._remainingAccounts,preInstructions:this._preInstructions,postInstructions:this._postInstructions,options:t})}async view(t){if(this._resolveAccounts&&await this._accountsResolver.resolve(),!this._viewFn)throw new Error(["Method does not support views.","The instruction should return a value, and its accounts must be read-only"].join(" "));return this._viewFn(...this._args,{accounts:this._accounts,signers:this._signers,remainingAccounts:this._remainingAccounts,preInstructions:this._preInstructions,postInstructions:this._postInstructions,options:t})}async rpc(t){return this._resolveAccounts&&await this._accountsResolver.resolve(),this._rpcFn(...this._args,{accounts:this._accounts,signers:this._signers,remainingAccounts:this._remainingAccounts,preInstructions:this._preInstructions,postInstructions:this._postInstructions,options:t})}async rpcAndKeys(t){return{signature:await this.rpc(t),pubkeys:await this.pubkeys()}}async prepare(){return{instruction:await this.instruction(),signers:this._signers,pubkeys:await this.pubkeys()}}}class $_{static build(t,e,r,s){const i=e.accounts.find(l=>l.writable),o=!!e.returns;return i||!o?void 0:async(...l)=>{let p=await r(...l);const m=`Program return: ${t} `;let S=p.raw.find(O=>O.startsWith(m));if(!S)throw new Error("View expected return log");let R=Qo(S.slice(m.length)),_=e.returns;if(!_)throw new Error("View expected return type");return Rt.fieldLayout({type:_},s.types).decode(R)}}}class V_{static build(t,e,r,s,i){const o={},a={},l={},p={},m={},S={},R=Ow(t),_=t.accounts?M_.build(t,e,r,s):{};return t.instructions.forEach(I=>{const O=ki.build(I,(J,Q)=>e.instruction.encode(J,Q),r),x=C_.build(I,O),M=B_.build(I,x,R,s),H=P_.build(I,x,R,s,e,r,t),P=$_.build(r,I,H,t),q=K_.build(s,r,I,O,x,M,H,P,_,t.types||[],i?.(I)),G=I.name;a[G]=O,l[G]=x,o[G]=M,p[G]=H,m[G]=q,P&&(S[G]=P)}),[o,a,l,_,p,m,S]}}class Nn{get programId(){return this._programId}get idl(){return this._idl}get rawIdl(){return this._rawIdl}get coder(){return this._coder}get provider(){return this._provider}constructor(t,e=Ii(),r,s){this._idl=Tw(t),this._rawIdl=t,this._provider=e,this._programId=Ue(t.address),this._coder=r??new yf(this._idl),this._events=new T_(this._programId,e,this._coder);const[i,o,a,l,p,m,S]=V_.build(this._idl,this._coder,this._programId,e,s);this.rpc=i,this.instruction=o,this.transaction=a,this.account=l,this.simulate=p,this.methods=m,this.views=S}static async at(t,e){const r=Ue(t),s=await Nn.fetchIdl(r,e);if(!s)throw new Error(`IDL not found for program: ${t.toString()}`);return new Nn(s,e)}static async fetchIdl(t,e){e=e??Ii();const r=Ue(t),s=await Aw(r),i=await e.connection.getAccountInfo(s);if(!i)return null;let o=kw(i.data.slice(8));const a=uw(o.data);return JSON.parse(Ul(a))}addEventListener(t,e,r){return this._events.addEventListener(t,e,r)}async removeEventListener(t){return await this._events.removeEventListener(t)}}new rt("11111111111111111111111111111111");export{Ai as A,r_ as B,vg as C,kf as E,rn as K,D as L,rt as P,ye as S,At as T,Vo as V,xt as a,Ro as b,Hd as c,yf as d,Nn as e,ht as f,Yo as g,un as h,or as i,J_ as j,$o as k,Zo as l,vn as m,Fg as n,Kg as r};
