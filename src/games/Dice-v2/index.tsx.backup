import React from 'react'
import { useUserStore } from '../../hooks/data/useUserStore'
import { GAME_CAPABILITIES } from '../../constants'

// Lazy load both renderers
const DiceV2Renderer2D = React.lazy(() => import('./Dice-v2-2D'))
const DiceV2Renderer3D = React.lazy(() => import('./Dice-v2-3D'))

const DiceV2Game: React.FC = () => {
  const getGameRenderMode = useUserStore(state => state.getGameRenderMode)
  const currentMode = getGameRenderMode('dice-v2')
  
  const gameCapabilities = GAME_CAPABILITIES['dice-v2']

  // Determine which renderer to use
  const shouldUse2D = currentMode === '2D' && gameCapabilities.supports2D
  const shouldUse3D = currentMode === '3D' && gameCapabilities.supports3D

  // Fallback to 2D if current mode is not supported
  const effectiveMode = shouldUse2D ? '2D' : shouldUse3D ? '3D' : '2D'

  return (
    <React.Suspense fallback={<div>Loading dice game...</div>}>
      {effectiveMode === '2D' ? <DiceV2Renderer2D /> : <DiceV2Renderer3D />}
    </React.Suspense>
  )
}

export default DiceV2Game
    if (!isDraggingSlider) return

    const rect = (event.currentTarget as HTMLElement).getBoundingClientRect()
    if (!rect) return

    const x = event.clientX - rect.left

    // Calculate scaling to match canvas rendering
    const scaleX = rect.width / CANVAS_WIDTH
    const scaleY = rect.height / CANVAS_HEIGHT
    const scale = Math.min(scaleX, scaleY)

    // Center the canvas
    const offsetX = (rect.width - CANVAS_WIDTH * scale) / 2

    // Convert DOM coordinates to canvas coordinates
    const canvasX = (x - offsetX) / scale

    updateSliderValue(canvasX, CANVAS_WIDTH)
  }, [isDraggingSlider])

  const handleCanvasMouseUp = useCallback(() => {
    setIsDraggingSlider(false)
  }, [])

  const handleCanvasTouchStart = useCallback((event: React.TouchEvent) => {
    event.preventDefault()
    const rect = (event.currentTarget as HTMLElement).getBoundingClientRect()
    if (!rect) return

    const touch = event.touches[0]
    const x = touch.clientX - rect.left
    const y = touch.clientY - rect.top

    // Calculate scaling to match canvas rendering
    const scaleX = rect.width / CANVAS_WIDTH
    const scaleY = rect.height / CANVAS_HEIGHT
    const scale = Math.min(scaleX, scaleY)

    // Center the canvas
    const offsetX = (rect.width - CANVAS_WIDTH * scale) / 2
    const offsetY = (rect.height - CANVAS_HEIGHT * scale) / 2

    // Convert DOM coordinates to canvas coordinates
    const canvasX = (x - offsetX) / scale
    const canvasY = (y - offsetY) / scale

    // Check if touch is on slider area (using canvas coordinates)
    const sliderY = CANVAS_HEIGHT - 120
    const sliderHeight = 60

    // Don't allow slider interaction during gameplay
    if (gamba.isPlaying || luckyNumberState.isAnimating) return

    if (canvasY >= sliderY && canvasY <= sliderY + sliderHeight) {
      setIsDraggingSlider(true)
      updateSliderValue(canvasX, CANVAS_WIDTH)
    }
  }, [])

  const handleCanvasTouchMove = useCallback((event: React.TouchEvent) => {
    event.preventDefault()
    if (!isDraggingSlider) return

    const rect = (event.currentTarget as HTMLElement).getBoundingClientRect()
    if (!rect) return

    const touch = event.touches[0]
    const x = touch.clientX - rect.left

    // Calculate scaling to match canvas rendering
    const scaleX = rect.width / CANVAS_WIDTH
    const scaleY = rect.height / CANVAS_HEIGHT
    const scale = Math.min(scaleX, scaleY)

    // Center the canvas
    const offsetX = (rect.width - CANVAS_WIDTH * scale) / 2

    // Convert DOM coordinates to canvas coordinates
    const canvasX = (x - offsetX) / scale

    updateSliderValue(canvasX, CANVAS_WIDTH)
  }, [isDraggingSlider])

  const handleCanvasTouchEnd = useCallback((event: React.TouchEvent) => {
    event.preventDefault()
    setIsDraggingSlider(false)
  }, [])
  const [luckyNumberState, setLuckyNumberState] = useState<LuckyNumberState>({
    currentNumber: 0,
    targetNumber: 0,
    isAnimating: false,
    animationProgress: 0,
    particles: [],
    randomSequence: [],
    currentSequenceIndex: 0
  })

  // Get graphics settings
  const { settings } = useGraphics()

  // Quality-based settings
  const shouldRenderParticles = settings.quality !== 'low'
  const shouldRenderRunes = settings.quality === 'high' || settings.quality === 'ultra'
  const shouldRenderMysticalCircles = settings.quality !== 'low'
  const particleCount = settings.quality === 'ultra' ? PARTICLE_COUNT : 
                       settings.quality === 'high' ? Math.floor(PARTICLE_COUNT * 0.75) :
                       settings.quality === 'medium' ? Math.floor(PARTICLE_COUNT * 0.5) : 0

  // Accessibility settings
  const enableEffects = settings.enableEffects
  const enableMotion = settings.enableMotion

  // Effects system
  const effectsRef = useRef<GameplayEffectsRef>(null)

  // Canvas animation frame
  const animationFrameRef = useRef<number>()
  const animationStartTimeRef = useRef<number>(0)

  const sounds = useSound({
    win: SOUND_WIN,
    play: SOUND_PLAY,
    lose: SOUND_LOSE,
    tick: SOUND_TICK,
  })

  const odds = Math.floor((rollUnderIndex / BET_ARRAYS_V2['dice-v2'].OUTCOMES) * BET_ARRAYS_V2['dice-v2'].OUTCOMES)
  const multiplier = Number(BigInt(BET_ARRAYS_V2['dice-v2'].OUTCOMES * BPS_PER_WHOLE) / BigInt(rollUnderIndex)) / BPS_PER_WHOLE

  const bet = React.useMemo(() => BET_ARRAYS_V2['dice-v2'].calculateBetArray(rollUnderIndex), [rollUnderIndex])
  const maxWin = multiplier * wager

  // Pool restrictions
  const maxWagerForPool = React.useMemo(() => {
    return pool.maxPayout / multiplier
  }, [pool.maxPayout, multiplier])

  const poolExceeded = maxWin > pool.maxPayout

  const game = GambaUi.useGame()

  // Initialize lucky number state
  useEffect(() => {
    setLuckyNumberState(prev => ({
      ...prev,
      currentNumber: 0,
      targetNumber: 0,
      isAnimating: false,
      animationProgress: 0,
      particles: [],
      randomSequence: [],
      currentSequenceIndex: 0
    }))
  }, [])

  // Animation loop for lucky number and particles
  const animate = useCallback((currentTime: number) => {
    // Skip animation if motion is disabled
    if (!enableMotion) return

    if (animationStartTimeRef.current === 0) {
      animationStartTimeRef.current = currentTime
    }

    const elapsed = currentTime - animationStartTimeRef.current
    const progress = Math.min(elapsed / ANIMATION_DURATION, 1)

    // Calculate which number to show based on elapsed time
    // Show a new number every 80ms for a more visible animation
    const numberDuration = 80 // ms per number
    const totalNumbers = 20
    const currentNumberIndex = Math.min(
      Math.floor(elapsed / numberDuration),
      totalNumbers - 1
    )

    setLuckyNumberState(prev => {
      // Update particles (only if effects are enabled)
      const newParticles = enableEffects ? prev.particles.map(particle => ({
        ...particle,
        x: particle.x + particle.vx,
        y: particle.y + particle.vy,
        life: particle.life - 1,
        vy: particle.vy + 0.1 // gravity
      })).filter(particle => particle.life > 0) : []

      // Check if animation is complete
      const isComplete = progress >= 1 || currentNumberIndex >= totalNumbers - 1

      if (isComplete) {
        // Animation complete
        return {
          ...prev,
          isAnimating: false,
          animationProgress: 1,
          particles: newParticles,
          currentSequenceIndex: totalNumbers - 1
        }
      }

      // Continue animation
      animationFrameRef.current = requestAnimationFrame(animate)

      return {
        ...prev,
        animationProgress: progress,
        particles: newParticles,
        currentSequenceIndex: currentNumberIndex
      }
    })
  }, [ANIMATION_DURATION, enableMotion, enableEffects, shouldRenderParticles])

  // Start lucky number animation with cycling random numbers
  const startLuckyNumberAnimation = useCallback((targetNumber: number) => {
    // If motion is disabled (static mode), skip animation and show result immediately
    if (!enableMotion) {
      setLuckyNumberState(prev => ({
        ...prev,
        targetNumber,
        isAnimating: false,
        animationProgress: 1,
        particles: [],
        randomSequence: [targetNumber],
        currentSequenceIndex: 0
      }))
      return
    }

    // Generate sequence of random numbers for 8-ball style animation
    const sequence: number[] = []
    const totalNumbers = 20 // Show 20 random numbers before the result

    // Add random numbers first (excluding the target number to avoid spoilers)
    for (let i = 0; i < totalNumbers - 1; i++) {
      let randomNum
      do {
        randomNum = Math.floor(Math.random() * 100)
      } while (randomNum === targetNumber) // Avoid showing the result early
      sequence.push(randomNum)
    }

    // Add the actual result at the end
    sequence.push(targetNumber)

    setLuckyNumberState({
      currentNumber: 0,
      targetNumber,
      isAnimating: true,
      animationProgress: 0,
      particles: [],
      randomSequence: sequence,
      currentSequenceIndex: 0
    })

    // Reset timing and start animation
    animationStartTimeRef.current = 0
    animationFrameRef.current = requestAnimationFrame(animate)
  }, [enableMotion])

  // Create particle burst effect
  const createParticleBurst = useCallback((x: number, y: number, color: string) => {
    if (!shouldRenderParticles || particleCount === 0) return

    const newParticles: Particle[] = []
    for (let i = 0; i < particleCount; i++) {
      newParticles.push({
        x,
        y,
        vx: (Math.random() - 0.5) * 10,
        vy: (Math.random() - 0.5) * 10 - 5,
        life: 60 + Math.random() * 60,
        maxLife: 120,
        color,
        size: 2 + Math.random() * 4
      })
    }

    setLuckyNumberState(prev => ({
      ...prev,
      particles: [...prev.particles, ...newParticles]
    }))
  }, [shouldRenderParticles, particleCount])

  // Canvas render function
  const renderCanvas = useCallback(({ ctx, size }: any, clock: any) => {
    // Clear canvas
    ctx.clearRect(0, 0, size.width, size.height)

    // Use current time for animation instead of relying on clock parameter
    const currentTime = performance.now()
    const animationTime = currentTime * 0.001 // Convert to seconds for smoother animation

    // Draw full-screen background first (before any transformations)
    const backgroundGradient = ctx.createRadialGradient(
      size.width / 2, size.height / 2, 0,
      size.width / 2, size.height / 2, Math.max(size.width, size.height) / 2
    )

    // Determine background color based on game state
    const isShowingResult = lastGameResult !== null && !luckyNumberState.isAnimating

    if (isShowingResult && lastGameResult === 'win') {
      // Green background for win
      backgroundGradient.addColorStop(0, '#1a2e1a')  // Dark green center
      backgroundGradient.addColorStop(0.5, '#2e4a2e') // Medium green
      backgroundGradient.addColorStop(1, '#0f230f')   // Dark green edge
    } else if (isShowingResult && lastGameResult === 'lose') {
      // Red background for loss
      backgroundGradient.addColorStop(0, '#2e1a1a')  // Dark red center
      backgroundGradient.addColorStop(0.5, '#4a2e2e') // Medium red
      backgroundGradient.addColorStop(1, '#230f0f')   // Dark red edge
    } else {
      // Black background for idle and playing states
      backgroundGradient.addColorStop(0, '#1a1a2e')
      backgroundGradient.addColorStop(0.5, '#16213e')
      backgroundGradient.addColorStop(1, '#0f0f23')
    }

    ctx.fillStyle = backgroundGradient
    ctx.fillRect(0, 0, size.width, size.height)

    // Romantic degen background elements
    ctx.save()
    ctx.globalAlpha = 0.15

    // Large romantic dice symbol (top-left)
    ctx.fillStyle = 'rgba(212, 165, 116, 0.3)'
    ctx.font = '120px serif'
    ctx.textAlign = 'center'
    ctx.save()
    ctx.translate(size.width * 0.12, size.height * 0.15)
    ctx.rotate(-15 * Math.PI / 180)
    ctx.fillText('‚öÉ', 0, 0)
    ctx.restore()

    // Large romantic dice symbol (bottom-right)
    ctx.fillStyle = 'rgba(184, 51, 106, 0.25)'
    ctx.font = '100px serif'
    ctx.save()
    ctx.translate(size.width * 0.88, size.height * 0.85)
    ctx.rotate(25 * Math.PI / 180)
    ctx.fillText('‚öÑ', 0, 0)
    ctx.restore()

    // Medium romantic dice symbols
    ctx.fillStyle = 'rgba(139, 90, 158, 0.2)'
    ctx.font = '60px serif'
    ctx.save()
    ctx.translate(size.width * 0.75, size.height * 0.25)
    ctx.rotate(45 * Math.PI / 180)
    ctx.fillText('‚öÇ', 0, 0)
    ctx.restore()

    ctx.save()
    ctx.translate(size.width * 0.25, size.height * 0.75)
    ctx.rotate(-30 * Math.PI / 180)
    ctx.fillText('‚öÅ', 0, 0)
    ctx.restore()

    // Small romantic dice symbols scattered
    ctx.fillStyle = 'rgba(212, 165, 116, 0.15)'
    ctx.font = '40px serif'
    const smallDice = ['‚öÄ', '‚öÅ', '‚öÇ', '‚öÉ', '‚öÑ', '‚öÖ']
    for (let i = 0; i < 8; i++) {
      const x = (i * size.width) / 8 + size.width / 16
      const y = size.height * 0.3 + Math.sin(i * 0.8) * 60
      ctx.save()
      ctx.translate(x, y)
      ctx.rotate((i * 45) * Math.PI / 180)
      ctx.fillText(smallDice[i % smallDice.length], 0, 0)
      ctx.restore()
    }

    ctx.restore()

    // Calculate scaling to fit canvas in container
    const scaleX = size.width / CANVAS_WIDTH
    const scaleY = size.height / CANVAS_HEIGHT
    const scale = Math.min(scaleX, scaleY)

    // Center the canvas
    const offsetX = (size.width - CANVAS_WIDTH * scale) / 2
    const offsetY = (size.height - CANVAS_HEIGHT * scale) / 2

    ctx.save()
    ctx.translate(offsetX, offsetY)
    ctx.scale(scale, scale)

    // Draw mystical background elements (conditional based on quality)
    if (shouldRenderMysticalCircles) {
      ctx.strokeStyle = 'rgba(138, 43, 226, 0.3)'
      ctx.lineWidth = 2
      for (let i = 0; i < 8; i++) {
        // Use static positions if motion is disabled
        const angle = enableMotion ? (animationTime * 1 + i * Math.PI / 4) % (Math.PI * 2) : (i * Math.PI / 4)
        const radius = enableMotion ? 150 + Math.sin(animationTime * 2 + i) * 50 : 150
        const x = CANVAS_WIDTH / 2 + Math.cos(angle) * radius
        const y = CANVAS_HEIGHT / 2 + Math.sin(angle) * radius

        ctx.beginPath()
        ctx.arc(x, y, 30 + i * 10, 0, Math.PI * 2)
        ctx.stroke()
      }
    }

    // Draw floating runes/symbols (conditional based on quality)
    if (shouldRenderRunes) {
      ctx.fillStyle = 'rgba(255, 215, 0, 0.6)'
      ctx.font = '24px serif'
      ctx.textAlign = 'center'
      const runes = ['‚ú¶', '‚úß', '‚ú©', '‚ú™', '‚ú´', '‚ú¨', '‚ú≠', '‚úÆ', '‚úØ', '‚ú∞']
      for (let i = 0; i < 10; i++) {
        // Use static positions if motion is disabled
        const baseAngle = i * Math.PI / 5
        const x = enableMotion ? 
          Math.sin(animationTime * 0.1 + i) * 200 + CANVAS_WIDTH / 2 : 
          Math.cos(baseAngle) * 200 + CANVAS_WIDTH / 2
        const y = enableMotion ? 
          Math.cos(animationTime * 0.1 + i) * 150 + CANVAS_HEIGHT / 2 : 
          Math.sin(baseAngle) * 150 + CANVAS_HEIGHT / 2
        ctx.save()
        ctx.translate(x, y)
        const rotation = enableMotion ? animationTime * 1.5 + i : i * 0.5
        ctx.rotate(rotation)
        ctx.fillText(runes[i % runes.length], 0, 0)
        ctx.restore()
      }
    }

    // Draw particles (conditional based on quality and effects)
    if (shouldRenderParticles && enableEffects) {
      luckyNumberState.particles.forEach(particle => {
        const alpha = particle.life / particle.maxLife
        ctx.save()
        ctx.globalAlpha = alpha
        ctx.fillStyle = particle.color
        ctx.beginPath()
        ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2)
        ctx.fill()
        ctx.restore()
      })
    }

    // Draw lucky number display
    const centerX = CANVAS_WIDTH / 2
    const centerY = CANVAS_HEIGHT / 2

    // Outer glow ring
    const glowGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, NUMBER_DISPLAY_SIZE / 2 + 20)
    glowGradient.addColorStop(0, 'rgba(212, 165, 116, 0.8)')
    glowGradient.addColorStop(1, 'rgba(212, 165, 116, 0)')
    ctx.fillStyle = glowGradient
    ctx.beginPath()
    ctx.arc(centerX, centerY, NUMBER_DISPLAY_SIZE / 2 + 20, 0, Math.PI * 2)
    ctx.fill()

    // Main number circle
    ctx.fillStyle = '#000000'
    ctx.beginPath()
    ctx.arc(centerX, centerY, NUMBER_DISPLAY_SIZE / 2, 0, Math.PI * 2)
    ctx.fill()

    // Number circle border
    ctx.strokeStyle = '#d4a574'
    ctx.lineWidth = 4
    ctx.beginPath()
    ctx.arc(centerX, centerY, NUMBER_DISPLAY_SIZE / 2, 0, Math.PI * 2)
    ctx.stroke()

    // Inner mystical ring
    ctx.strokeStyle = 'rgba(139, 90, 158, 0.6)'
    ctx.lineWidth = 2
    ctx.beginPath()
    ctx.arc(centerX, centerY, NUMBER_DISPLAY_SIZE / 2 - 10, 0, Math.PI * 2)
    ctx.stroke()

    // Display number
    let displayNumber = 0 // Default to 0 when no game is active
    if (luckyNumberState.isAnimating) {
      // Show animation numbers or target number during animation
      if (luckyNumberState.randomSequence.length > 0 && luckyNumberState.currentSequenceIndex < luckyNumberState.randomSequence.length) {
        displayNumber = luckyNumberState.randomSequence[luckyNumberState.currentSequenceIndex]
      } else if (luckyNumberState.targetNumber > 0) {
        displayNumber = luckyNumberState.targetNumber
      } else if (resultIndex >= 0) {
        displayNumber = resultIndex
      }
    } else if (luckyNumberState.targetNumber > 0) {
      // Show final result when animation is complete
      displayNumber = luckyNumberState.targetNumber
    } else if (resultIndex >= 0) {
      // Show result when available
      displayNumber = resultIndex
    }

    ctx.fillStyle = '#d4a574'
    ctx.font = `bold ${NUMBER_DISPLAY_SIZE * 0.4}px Arial`
    ctx.textAlign = 'center'
    ctx.textBaseline = 'middle'
    ctx.fillText(displayNumber.toString(), centerX, centerY)

    ctx.restore()
  }, [luckyNumberState, rollUnderIndex, hasPlayed, gamba.isPlaying, lastGameResult, resultIndex, shouldRenderParticles, shouldRenderRunes, shouldRenderMysticalCircles, enableEffects, enableMotion])

  const play = async () => {
    if (wager <= 0) {
      console.error('‚ùå BLOCKED: Cannot play with zero wager')
      return
    }

    // Reset game state for new game
    setHasPlayed(false)
    setResultIndex(-1)
    setLastGameResult(null)

    // Reset lucky number state
    setLuckyNumberState(prev => ({
      ...prev,
      currentNumber: 0,
      targetNumber: 0,
      isAnimating: false,
      animationProgress: 0,
      particles: [],
      randomSequence: [],
      currentSequenceIndex: 0
    }))

    // Reset animation timing
    animationStartTimeRef.current = 0
    if (animationFrameRef.current) {
      cancelAnimationFrame(animationFrameRef.current)
      animationFrameRef.current = undefined
    }

    sounds.play('play')

    // Use RTP config to get the bet array
    const betArray = BET_ARRAYS_V2['dice-v2'].calculateBetArray(rollUnderIndex)

    console.log('üé≤ BET ARRAY DEBUG:', {
      rollUnderIndex,
      betArray: betArray.slice(0, 10), // Show first 10 elements
      nonZeroCount: betArray.filter(x => x > 0).length,
      maxBet: Math.max(...betArray),
      wager
    })

    await game.play({ wager, bet: betArray })

    const result = await game.result()
    const win = result.payout > 0

    // Store the game result for background color
    setLastGameResult(win ? 'win' : 'lose')

    // Generate deterministic lucky number using RTP config logic
    const seed = `${result.resultIndex}:${result.payout}:${result.multiplier}:${rollUnderIndex}`
    const rng = makeDeterministicRng(seed)

    let luckyNumber: number
    if (win) {
      // Winning numbers are below rollUnderIndex
      luckyNumber = Math.floor(rng() * rollUnderIndex)
    } else {
      // Losing numbers are rollUnderIndex and above
      luckyNumber = rollUnderIndex + Math.floor(rng() * (BET_ARRAYS_V2['dice-v2'].OUTCOMES - rollUnderIndex))
    }

    console.log('üé≤ DICE RESULT:', {
      resultIndex: result.resultIndex,
      payout: result.payout,
      multiplier: result.multiplier,
      win,
      rollUnderIndex,
      luckyNumber,
      seed
    })

    // Set result index for display
    setResultIndex(luckyNumber)

    // Update comprehensive game statistics
    const profit = result.payout - wager
    const isWin = result.payout > 0
    
    setGameStats(prev => ({
      gamesPlayed: prev.gamesPlayed + 1,
      wins: prev.wins + (isWin ? 1 : 0),
      losses: prev.losses + (isWin ? 0 : 1),
      sessionProfit: prev.sessionProfit + profit,
      bestWin: Math.max(prev.bestWin, profit)
    }))

    // Start lucky number animation with a small delay to ensure state is ready
    // If motion is disabled, skip the delay and show result immediately
    const animationDelay = enableMotion ? 50 : 0
    setTimeout(() => startLuckyNumberAnimation(luckyNumber), animationDelay)

    // Handle win/lose effects after animation and mark game as played
    // If motion is disabled, use shorter timeout since animation completes immediately
    const effectsDelay = enableMotion ? ANIMATION_DURATION + 100 : 100
    setTimeout(() => {
      setHasPlayed(true)
      
      // Update session statistics
      setGameCount(prev => prev + 1)
      setTotalProfit(prev => prev + (result.payout - wager))
      if (win) {
        setWinCount(prev => prev + 1)
      }

      console.log('üé≤ ANIMATION COMPLETE - Final result:', luckyNumber)

      if (win) {
        sounds.play('win')
        if (enableEffects) {
          effectsRef.current?.winFlash('#00ff00', 1.5)
          createParticleBurst(CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2, '#ffd700')
          effectsRef.current?.screenShake(1, 600)
        }
      } else {
        sounds.play('lose')
        if (enableEffects) {
          effectsRef.current?.loseFlash('#ff4444', 0.8)
          createParticleBurst(CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2, '#ff6b6b')
          effectsRef.current?.screenShake(0.5, 400)
        }
      }
    }, effectsDelay)
  }

  // Reset game to allow new wager
  const resetGame = () => {
    setHasPlayed(false)
    setResultIndex(-1)
    setLastGameResult(null)
    setLuckyNumberState(prev => ({
      ...prev,
      currentNumber: 0,
      targetNumber: 0,
      isAnimating: false,
      animationProgress: 0,
      particles: [],
      randomSequence: [],
      currentSequenceIndex: 0
    }))
    // Reset animation timing
    animationStartTimeRef.current = 0
    if (animationFrameRef.current) {
      cancelAnimationFrame(animationFrameRef.current)
      animationFrameRef.current = undefined
    }
  }

  // Reset session statistics
  const resetSession = () => {
    setTotalProfit(0)
    setGameCount(0)
    setWinCount(0)
    resetGame()
  }

  // Cleanup animation on unmount
  useEffect(() => {
    return () => {
      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current)
      }
    }
  }, [])

  // Handle slider dragging
  useEffect(() => {
    if (!isDraggingSlider) return

    const handleMouseMove = (e: MouseEvent) => {
      const sliderElement = document.querySelector('[data-slider-track]') as HTMLElement
      if (!sliderElement) return

      const rect = sliderElement.getBoundingClientRect()
      const x = e.clientX - rect.left
      const percentage = Math.max(0, Math.min(1, x / rect.width))
      const newValue = Math.min(100, Math.max(1, Math.round(percentage * 100)))
      setRollUnderIndex(newValue)
    }

    const handleMouseUp = () => {
      setIsDraggingSlider(false)
      sounds.play('tick')
    }

    document.addEventListener('mousemove', handleMouseMove)
    document.addEventListener('mouseup', handleMouseUp)

    return () => {
      document.removeEventListener('mousemove', handleMouseMove)
      document.removeEventListener('mouseup', handleMouseUp)
    }
  }, [isDraggingSlider])

  return (
    <>
      {/* Stats Portal - positioned above game screen */}
      <GambaUi.Portal target="stats">
        <GameStatsHeader
          gameName="Dice"
          gameMode="V2"
          rtp="95"
          stats={gameStats}
          onReset={handleResetStats}
          isMobile={isMobile}
        />
      </GambaUi.Portal>

      <GambaUi.Portal target="screen">
        <div style={{
          width: '100%',
          height: '100%',
          position: 'relative',
          background: 'linear-gradient(135deg, #0a0511 0%, #0d0618 25%, #0f081c 50%, #0a0511 75%, #0a0511 100%)',
          perspective: '100px'
        }}>
          {/* Canvas Game Area - now starts from top since header is outside */}
          <div style={{
            position: 'absolute',
            top: '20px',
            left: '20px',
            right: '20px',
            bottom: '120px', // Leave space for slider below
            borderRadius: '10px',
            overflow: 'hidden',
            border: '2px solid rgba(212, 165, 116, 0.4)'
          }}>
            <GambaUi.Canvas
              style={{
                width: '100%',
                height: '100%',
                cursor: gamba.isPlaying || luckyNumberState.isAnimating ? 'not-allowed' : (isDraggingSlider ? 'grabbing' : 'grab')
              }}
              render={renderCanvas}
              onMouseDown={handleCanvasMouseDown}
              onMouseMove={handleCanvasMouseMove}
              onMouseUp={handleCanvasMouseUp}
              onMouseLeave={handleCanvasMouseUp}
              onTouchStart={handleCanvasTouchStart}
              onTouchMove={handleCanvasTouchMove}
              onTouchEnd={handleCanvasTouchEnd}
            />
          </div>

          <GameControlsSection>
            {/* WIN Zone Section */}
            <div style={{
              flex: '0 0 120px',
              height: '100%',
              background: 'linear-gradient(135deg, rgba(76, 175, 80, 0.15) 0%, rgba(46, 125, 50, 0.25) 50%, rgba(76, 175, 80, 0.15) 100%)',
              borderRadius: '12px',
              border: '2px solid rgba(76, 175, 80, 0.4)',
              display: 'flex',
              flexDirection: 'column',
              justifyContent: 'center',
              alignItems: 'center',
              boxShadow: '0 4px 16px rgba(76, 175, 80, 0.2), inset 0 1px 0 rgba(76, 175, 80, 0.3)',
              backdropFilter: 'blur(8px)'
            }}>
              <div style={{
                fontSize: '14px',
                fontWeight: 'bold',
                color: '#81c784',
                textShadow: '0 2px 4px rgba(0, 0, 0, 0.3)',
                marginBottom: '4px'
              }}>
                WIN ZONE
              </div>
              <div style={{
                fontSize: '12px',
                color: 'rgba(129, 199, 132, 0.9)',
                fontWeight: '600'
              }}>
                {`1 - ${Math.min(99, rollUnderIndex)}`}
              </div>
            </div>

            {/* Slider Section */}
            <div style={{
              flex: '1',
              height: '100%',
              background: 'linear-gradient(135deg, rgba(10, 5, 17, 0.9) 0%, rgba(139, 90, 158, 0.1) 50%, rgba(10, 5, 17, 0.9) 100%)',
              borderRadius: '12px',
              border: '2px solid rgba(212, 165, 116, 0.5)',
              display: 'flex',
              flexDirection: 'column',
              justifyContent: 'center',
              alignItems: 'center',
              padding: '8px 16px',
              boxShadow: '0 4px 16px rgba(10, 5, 17, 0.4), inset 0 1px 0 rgba(212, 165, 116, 0.2)',
              backdropFilter: 'blur(10px)',
              position: 'relative'
            }}>
              {/* Slider Track */}
              <div
                data-slider-track
                style={{
                  width: '100%',
                  height: '24px',
                  background: `linear-gradient(to right, 
                    rgba(76, 175, 80, 0.8) 0%, 
                    rgba(76, 175, 80, 0.8) ${(Math.min(99, rollUnderIndex) / 100) * 100}%, 
                    rgba(244, 67, 54, 0.8) ${(Math.min(99, rollUnderIndex) / 100) * 100}%, 
                    rgba(244, 67, 54, 0.8) 100%)`,
                  borderRadius: '12px',
                  position: 'relative',
                  border: '2px solid rgba(212, 165, 116, 0.5)',
                  cursor: gamba.isPlaying || luckyNumberState.isAnimating ? 'not-allowed' : 'pointer',
                  boxShadow: 'inset 0 2px 4px rgba(0, 0, 0, 0.2)',
                  overflow: 'visible'
                }}
                onClick={(e) => {
                  if (gamba.isPlaying || luckyNumberState.isAnimating) return
                  const rect = e.currentTarget.getBoundingClientRect()
                  const x = e.clientX - rect.left
                  const percentage = Math.max(0, Math.min(1, x / rect.width))
                  const newValue = Math.min(100, Math.max(1, Math.round(percentage * 100)))
                  setRollUnderIndex(newValue)
                  sounds.play('tick')
                }}
              >
                {/* Min Label */}
                <div style={{
                  position: 'absolute',
                  left: '8px',
                  top: '50%',
                  transform: 'translateY(-50%)',
                  color: '#d4a574',
                  fontSize: '10px',
                  fontWeight: 'bold',
                  textShadow: '0 1px 2px rgba(0, 0, 0, 0.5)',
                  zIndex: 5
                }}>
                  1
                </div>

                {/* 25% Label */}
                <div style={{
                  position: 'absolute',
                  left: '25%',
                  top: '50%',
                  transform: 'translate(-50%, -50%)',
                  color: '#d4a574',
                  fontSize: '10px',
                  fontWeight: 'bold',
                  textShadow: '0 1px 2px rgba(0, 0, 0, 0.5)',
                  zIndex: 5
                }}>
                  25
                </div>

                {/* 50% Label */}
                <div style={{
                  position: 'absolute',
                  left: '50%',
                  top: '50%',
                  transform: 'translate(-50%, -50%)',
                  color: '#d4a574',
                  fontSize: '10px',
                  fontWeight: 'bold',
                  textShadow: '0 1px 2px rgba(0, 0, 0, 0.5)',
                  zIndex: 5
                }}>
                  50
                </div>

                {/* 75% Label */}
                <div style={{
                  position: 'absolute',
                  left: '75%',
                  top: '50%',
                  transform: 'translate(-50%, -50%)',
                  color: '#d4a574',
                  fontSize: '10px',
                  fontWeight: 'bold',
                  textShadow: '0 1px 2px rgba(0, 0, 0, 0.5)',
                  zIndex: 5
                }}>
                  75
                </div>

                {/* Max Label */}
                <div style={{
                  position: 'absolute',
                  right: '8px',
                  top: '50%',
                  transform: 'translateY(-50%)',
                  color: '#d4a574',
                  fontSize: '10px',
                  fontWeight: 'bold',
                  textShadow: '0 1px 2px rgba(0, 0, 0, 0.5)',
                  zIndex: 5
                }}>
                  99
                </div>

                {/* Slider Handle */}
                <div style={{
                  position: 'absolute',
                  left: `${(Math.min(99, rollUnderIndex) / 99) * 100}%`,
                  top: '50%',
                  transform: 'translate(-50%, -50%)',
                  width: '28px',
                  height: '28px',
                  background: 'linear-gradient(135deg, #ffd700 0%, #ffb74d 50%, #ff6b35 100%)',
                  borderRadius: '50%',
                  border: '3px solid rgba(212, 165, 116, 0.9)',
                  boxShadow: '0 4px 16px rgba(0, 0, 0, 0.4), 0 0 0 2px rgba(255, 215, 0, 0.3)',
                  cursor: gamba.isPlaying || luckyNumberState.isAnimating ? 'not-allowed' : 'pointer',
                  zIndex: 15,
                  transition: 'transform 0.1s ease'
                }}
                onMouseDown={(e) => {
                  if (gamba.isPlaying || luckyNumberState.isAnimating) return
                  setIsDraggingSlider(true)
                  e.preventDefault()
                }}
                >
                  {/* Current Value Label on Handle */}
                  <div style={{
                    position: 'absolute',
                    top: '-35px',
                    left: '50%',
                    transform: 'translateX(-50%)',
                    background: 'rgba(10, 5, 17, 0.95)',
                    color: '#d4a574',
                    padding: '4px 8px',
                    borderRadius: '8px',
                    fontSize: '12px',
                    fontWeight: 'bold',
                    border: '1px solid rgba(212, 165, 116, 0.5)',
                    boxShadow: '0 4px 12px rgba(0, 0, 0, 0.3)',
                    whiteSpace: 'nowrap',
                    zIndex: 20
                  }}>
                    {rollUnderIndex}
                  </div>
                </div>
              </div>
            </div>

            {/* LOSE Zone Section */}
            <div style={{
              flex: '0 0 120px',
              height: '100%',
              background: 'linear-gradient(135deg, rgba(244, 67, 54, 0.15) 0%, rgba(211, 47, 47, 0.25) 50%, rgba(244, 67, 54, 0.15) 100%)',
              borderRadius: '12px',
              border: '2px solid rgba(244, 67, 54, 0.4)',
              display: 'flex',
              flexDirection: 'column',
              justifyContent: 'center',
              alignItems: 'center',
              boxShadow: '0 4px 16px rgba(244, 67, 54, 0.2), inset 0 1px 0 rgba(244, 67, 54, 0.3)',
              backdropFilter: 'blur(8px)'
            }}>
              <div style={{
                fontSize: '14px',
                fontWeight: 'bold',
                color: '#ef5350',
                textShadow: '0 2px 4px rgba(0, 0, 0, 0.3)',
                marginBottom: '4px'
              }}>
                LOSE ZONE
              </div>
              <div style={{
                fontSize: '12px',
                color: 'rgba(239, 83, 80, 0.9)',
                fontWeight: '600'
              }}>
                {Math.min(99, rollUnderIndex) + 1} - {BET_ARRAYS_V2['dice-v2'].OUTCOMES}
              </div>
            </div>
          </GameControlsSection>

          <GameplayFrame
            ref={effectsRef}
            style={{
              position: 'absolute',
              top: 0,
              left: 0,
              right: 0,
              bottom: 0,
              pointerEvents: 'none',
              zIndex: 1000
            }}
            {...(useGameMeta('dice') && {
              title: useGameMeta('dice')!.name,
              description: useGameMeta('dice')!.description
            })}
          />
        </div>
      </GambaUi.Portal>

      <GambaUi.Portal target="controls">
        <MobileControls
          wager={wager}
          setWager={setWager}
          onPlay={hasPlayed ? resetGame : play}
          playDisabled={gamba.isPlaying || (!hasPlayed && luckyNumberState.isAnimating) || poolExceeded}
          playText={hasPlayed ? "New Game" : "Roll Lucky Number"}
        />

        <DesktopControls
          wager={wager}
          setWager={setWager}
          onPlay={hasPlayed ? resetGame : play}
          playDisabled={gamba.isPlaying || (!hasPlayed && luckyNumberState.isAnimating) || poolExceeded}
          playText={hasPlayed ? "New Game" : "Roll Lucky Number"}
        >
          <EnhancedWagerInput value={wager} onChange={setWager} multiplier={multiplier} />
          <EnhancedPlayButton disabled={gamba.isPlaying || (!hasPlayed && luckyNumberState.isAnimating) || poolExceeded} onClick={hasPlayed ? resetGame : play}>
            {hasPlayed ? "New Game" : "Roll Lucky Number"}
          </EnhancedPlayButton>
        </DesktopControls>
      </GambaUi.Portal>
    </>
  )
}
